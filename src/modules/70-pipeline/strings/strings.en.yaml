verificationResult: 'Verification result:'
estimatedTimeRemaining: 'Estimated time remaining:'
progressPercentage: 'Progress percentage:'
discard: '{{ $.common.discard }}'
serviceDependencyText: Service Dependency
serviceDependenciesText: Service Dependencies
stepLabel: '{{name}} (ID: {{identifier}})'
enableVerificationOptions: Enable verification options
closeStepConfig: Step Config
stepConfigHasChanges: Form has some unsaved changed, Do you want to apply the changes?
clickHere: Click here
stepDetails: Step details
scriptInputVariables: Script Input Variables
scriptOutputVariables: Script Output Variables
executionTarget: Execution Target
collapseIsDisabledWhileStageIsRunning: Collapse is disable while stage is running
onlyPositiveInteger: Only positive integer values
depth: Depth
sslVerify: SSL Verify
noPipelineText: There are no pipelines in your project
noDeploymentText: There are no deployments in your project
runModalNoPipelineText: There are no pipelines in your project. Please create a new pipeline
noBuildsText: There are no builds in your project
runAPipeline: Run a Pipeline
regionPlaceholder: Select Region
repositoryUrlPlaceholder: Enter Repository URL
lastSevenDays: In Last 7 days
neverRan: This pipeline never ran
startedOn: Started On
poweredByHarness: powered by Harness
outOf: Out Of
clickToExpandErrorDetails: Click to expand error details
approvalStage:
  settingUpStage: Getting stage data
filters:
  pipelineNamePlaceholder: Enter Pipeline Name
  deploymentTypePlaceholder: Search/Select Deployment Type
  servicePlaceholder: Search/Select Service
  environmentPlaceholder: Search/Select Environment
  builtTypePlaceholder: Select Build Type
selectStagePlaceholder: Search/Select Stage
rightBar:
  editCodebaseConfiguration: Edit Codebase Configuration
barrierStep:
  barrierReference: Barrier Reference
  barrierReferenceRequired: Barrier Reference is required
  barrierReferencePlaceholder: Select or Enter Barrier Reference
timeRemainingSuffix: remaining till timeout
approvalStep:
  message: 'Approval Message'
  approvers: 'Approver(s)'
  ensureUserGroups: To use Harness Approvals, please make sure your project has user groups.
  approversWithColon: '{{$.pipeline.approvalStep.approvers}}:'
  approverInputs: 'Inputs to be provided by approver'
  includePipelineExecutionHistory: 'Include pipeline execution history in approval details'
  addUserGroups: Enter User Group
  fetchingUserGroups: Select User Group
  fetchUserGroupsFailed: Failed to fetch User Groups
  minimumCount: 'Number of approvers that are required at this step'
  disallowPipelineExecutor: 'Disallow the executor from approving the pipeline'
  addApproverInputs: Add Approver Inputs
  execution:
    inputsTitle: Approval inputs
    statusMsg: '{{ count }} of {{ total }} approvals complete'
  validation:
    approvalMessage: Approval message is required.
    userGroups: 'Please provide user groups.'
    minimumCountOne: 'Minimum count cannot be less than one.'
    minimumCountRequired: 'Minimum count is required.'
  status:
    APPROVE: Approved
    REJECT: Rejected
  notAuthorizedExecution: User is not authorized to approve/reject the pipeline
  disallowedApproverExecution: This approval step has been configured to disallow pipeline executors to approve this stage.
jiraApprovalStep:
  connectToJira: Connect to Jira
  connectorRef: Jira Connector
  jiraConnectorPlaceholder: Select Jira Connector
  project: Jira Project
  issueType: Issue Type
  issueTypePlaceholder: Select Issue Type
  issueKey: Issue Key
  issueKeyPlaceholder: Enter Issue Key
  fetchingProjectsPlaceholder: Fetching Projects...
  fetchProjectsError: Failed to fetch projects
  fetchingIssueTypePlaceholder: Fetching Issue Types...
  fetchIssueTypesError: Failed to fetch issue types
  approvalCriteria: Approval Criteria
  rejectionCriteria: Rejection Criteria
  rejectionCriteriaOptional: Rejection Criteria (optional)
  jexlExpressionLabelApproval: If the JEXL Expression evaluates to true, approve this step
  jexlExpressionLabelRejection: If the JEXL Expression evaluates to true, reject this step
  jexlExpressionPlaceholder: |
    Example: <+issue.Status> == "Done"
  fetchingFields: Fetching fields...
  match: Match
  allConditions: All conditions
  anyCondition: Any condition
  jiraField: Jira Field
  jexlExpressionApprovalCriteria: JEXL Expression for approval criteria
  jexlExpressionRejectionCriteria: JEXL Expression for rejection criteria
  execution:
    criteriaMsg: Approval/Rejection Criteria Listed Below
    wasApproved: 'Approval Criteria was met for Jira Ticket:'
    wasRejected: 'Rejection Criteria was met for Jira Ticket:'
    jiraTicket: 'JIRA Ticket Pending Approval:'
    allConditionsMsg: 'If all of the following conditions are met:'
    anyConditionsMsg: 'If any of the following conditions is met:'
    conditions:
      equals: '{{ key }} equals'
      not_equals: '{{ key }} does not equals'
      in: '{{ key }} is in'
      not_in: '{{ key }} is not in'
  validations:
    connectorRef: Jira Connector is required
    project: Project is required
    issueKey: Issue Key is required
    issueType: Issue Type is required
    approvalCriteriaCondition: At least one condition is required
    expression: Expression value is required
jiraCreateStep:
  fields: Jira Fields
  summaryPlaceholder: Enter a Title or Summary
  addFields: Add Jira Fields
  selectFieldsHeading: Select fields you would like to add.
  fieldSelectorAdd: '+ Fields'
  selectFromFieldList: Select from Field List
  provideFieldList: Provide Field List
  selectFieldListHelp: Select your project and issue type to list available fields to choose from.
  fetchingFields: Fetching your fields
  fieldsSelectorPlaceholder: Your fields will be populated here
  selectProject: Select Project
  validations:
    summary: Summary is required
jiraUpdateStep:
  statusTransitionAccordion: Status and Transition (optional)
  transitionLabel: Transition Name
  transitionPlaceholder: Enter Transition Name
  fetchingStatus: Fetching Status List...
  selectStatus: Select Status
  projectIssueTypeDisclaimer:
    Please ensure the values for your project and issuetype matches the values in your issue key. If the
    values don’t match, there will be an error at runtime.
  validations:
    status: Status is required with transition.
manifestType:
  manifestTyperequired: Manifest Type is required
  gitConnectorLabel: 'Git'
  bitBucketLabel: 'Bitbucket'
  httpHelmRepoConnectorLabel: 'HTTP Helm'
  manifestIdentifier: Manifest Identifier
  manifestPlaceholder: Enter Manifest Identifier
  manifestSource: Manifest Source
  manifestDetails: Manifest Details
  manifestRepoType: '{{ $.manifestsText }} {{ $.typeLabel }}'
  specifyManifestRepoType: 'Specify {{ $.manifestsText }} {{ $.typeLabel }}'
  specifyManifestStore: 'Specify {{ $.manifestsText }} {{$.store}}'
  selectManifestStore: '{{$.select}} {{ $.manifestsText }} {{$.store}}'
  helmSkipResourceVersion: By selecting this option, Harness will no longer version ConfigMaps and Secrets for this Service.
  manifestPathPlaceholder: Enter File/Folder Path
  pluginPathHelperText: Enter the path to the dedicated directory for the plugin on the Delegate host(s). For example, '$HOME/plugin'. The default directory is named $XDG_CONFIG_HOME/kustomize/plugin and its value is $HOME/.config
  kustomizePathHelperText: Enter the path from the root of the Source Provider repo to the folder containing kustomization.yaml
  helmCommandFlags: By Default, Harness versions ConfigMaps and Secrets that are deployed into the Kubernetes Cluster.
  helmCommandFlagLabel: Helm Command Flags (optional)
  helmCommandType: Command Type
  helmCommandTypePlaceholder: Enter Command Type
  helmVersionRequired: 'Helm Version is required'
  commandFlagRequired: 'Command Flag is required'
  folderPathRequired: Folder Path is required
  chartPathRequired: Chart Path is required
  kustomizePathRequired: Kustomize Path is required
  kustomizeFolderPathRequired: Kustomize Folder Path is required
  pathRequired: File Path is required
  bucketNameRequired: Bucket Name is required
  path: '{{$.common.path}}'
  osTemplatePath: Template File Path
  osTemplatePathPlaceHolder: Enter Template File Path
  osTemplatePathRequired: Template File Path is required
  bucketNamePlaceholder: Enter Bucket Name
  bucketPlaceHolder: Select or Add bucket name
  pathPlaceholder: Enter File Path
  chartPathPlaceholder: Enter Chart Path
  bucketName: Bucket Name
  gitFetchTypeLabel: Git Fetch Type
  commitId: Commit Id
  branchPlaceholder: Enter Branch Name
  commitPlaceholder: Enter Commit Id
  filePathPlaceholder: Enter File or Folder Path
  kustomizeFolderPath: Kustomize Folder Path
  kustomizeFolderPathPlaceholder: Enter Kustomize Folder Path
  kustomizePluginPathPlaceholder: Enter Kustomize Plugin Path
  repoNamePlaceholder: Enter Repository Name
  http:
    chartName: 'Chart Name'
    chartVersion: 'Chart Version'
    chartNameRequired: 'Chart Name is required'
    chartNamePlaceHolder: 'Enter Chart Name'
    chartVersionPlaceHolder: 'Enter Chart Version'
    chartVersionRequired: 'Chart Version is required'
manifestTypeLabels:
  K8sManifest: K8s Manifest
  ValuesYaml: Values YAML
  HelmChartLabel: Helm Chart
  KustomizeLabel: Kustomize
  OpenshiftTemplate: Openshift Template
  OpenshiftParam: Openshift Param
manifestToConnectorLabelMap:
  AWSLabel: '{{ $.common.aws }}'
  GCPLabel: GCP
failureStrategies:
  performAction: '{{ $.common.performAction }}'
  title: Failure Strategy
  helpText: |
    Define one or more failure strategies to control the behavior of your pipeline when your step execution encounters an error.
  addedAllStrategies: You have added all possible failure strategies. There are no more options to add.
  tabHasErrors: The current settings have errors. Please review the error messages displayed and resolve the issues.
  onFailureOfType: On failure of type
  fieldLabels:
    retryCountLabel: Retry count
    retryIntervalsLabel: Retry intervals
    onTimeoutLabel: Post timeout action
    onRetryFailureLabel: Post retry failure action
  strategiesLabel:
    Retry: '{{ $.retry }}'
    Abort: '{{ $.abort }}'
    Ignore: Ignore Failure
    StageRollback: Rollback Stage
    StepGroupRollback: Rollback Step Group
    ManualIntervention: Manual Intervention
    MarkAsSuccess: Mark As Success
  errorTypeLabels:
    Authentication: Authentication Errors
    Authorization: Authorization Errors
    Connectivity: Connectivity Errors
    Timeout: Timeout Errors
    Verification: Verification Failures
    DelegateProvisioning: Delegate Provisioning Errors
    AllErrors: All Errors
    Unknown: Unknown Errors
  validation:
    errorsRequired: At least one failure type is required
    errorsMinimum: '{{ $.pipeline.failureStrategies.validation.errorsRequired }}'
    actionRequired: Action is required
    retryCountInteger: Retry Count must be a positive integer
    retryCountRequired: Retry Count is required
    retryCountMinimum: Retry Count must be greater or equal to 1
    retryCountMaximum: Retry Count cannot be more than {{ count }}
    retryIntervalRequired: Retry Interval is Required
    retryIntervalMinimum: At least one retry interval is Required
    retryIntervalMaxmimum: Number of retry intervals cannot be more than the retry count
    timeoutRequired: Timeout is required
    onRetryFailureRequired: Retry failure action is required
    onTimeoutRequired: Post timeout action is required
selectOrCreatePipeline:
  pipelineNameRequired: Please select a pipeline
  setupHeader: Create or Select a Pipeline
  selectAPipeline: Select an existing Pipeline
createANewPipeline: Create a new pipeline
createPipeline:
  setupHeader: Setup Pipeline
  setupSubtitle: Let’s get you started on your pipeline.
  setupLater: Setup Later
  learnMore: Learn More
selectOrCreateForm:
  description: Define pipelines that enable you to improve your deployment times, manage your integrations and view your services all in one place.
execution:
  stagesExecuted: Stages executed (most recent first)
  upcomingStagesPrefix: 'Upcoming stages: '
  stepTitlePrefix: 'Step: '
  stageTitlePrefix: 'Stage: '
  noInputsText: No inputs found
  retryStepCount: 'Retry #{{ num }}'
  currentExecution: Current Execution
  timePrefix: 'Execution Time: '
  ignoreFailedWarningText: A failed step was ignored because the step’s Failure Strategy is Ignore Failure. The step’s failure did not impact the Pipeline’s success.
  iotab:
    noInputText: No input found for current step
    noOutputText: No output found for current step
  pipelineActionMessages:
    abortedMessage: Pipeline has been aborted successfully
    pausedMessage: Pipeline execution will pause once the currently running steps have completed.
    resumedMessage: Pipeline has been resumed successfully
  stageActionMessages:
    abortedMessage: Stage "{{stageName}}" has been aborted successfully
    pausedMessage: Stage "{{stageName}}" execution will pause once the currently running steps have completed.
    resumedMessage: Stage  "{{stageName}}" has been resumed successfully
  actions:
    resumePipeline: Resume Pipeline
    rerunPipeline: Re-run Pipeline
    pausePipeline: Pause Pipeline
    abortPipeline: Abort Pipeline
    resumeStage: Resume Stage
    rerunStage: Re-run Stage
    pauseStage: Pause Stage
    abortStage: Abort Stage
    downloadLogs: Download logs
  layouts:
    bottom: Align to bottom
    right: Align to right
    float: Floating window
    minimize: Minimize window
resourceConstraints:
  title: Resource Constraint
  infoText: 'You have {{executioncount}} executions in queue that have to complete before your execution begins. Only one execution on a K8s namespace is allowed at a time.'
  currentlyExecuting: ' ( currently executing )'
  yourPipeline: ' ( you execution )'
targets:
  title: Targets
barriers:
  syncBarriers: Synchronization Barriers
  flowControl: Flow Control
  addBarrier: Add Barrier
  tooltips:
    barrierWaiting: 'Waiting for another barrier '
    timeout: 'to Timeout'
  validation:
    barrierNamerequired: 'Enter name of barrier'
executionStatus:
  Failed: FAILED
  Success: SUCCESS
  Aborted: ABORTED
  Error: ERROR
  Paused: PAUSED
  Pausing: PAUSING
  Waiting: WAITING
  Aborting: ABORTING
  Running: RUNNING
  Queued: QUEUED
  Skipped: SKIPPED
  Starting: STARTING
  Expired: EXPIRED
  Suspended: SUSPENDED
  NotStarted: NOT STARTED
  ApprovalRejected: REJECTED
  Unknown: UNKNOWN
executionFilters:
  labels:
    Aborted: Aborted
    Expired: Expired
    Failed: '{{ $.failed }}'
    Running: Running
    Success: '{{ $.success }}'
    ApprovalRejected: Approval Rejected
    Paused: Paused
    ApprovalWaiting: Waiting on approval
    InterventionWaiting: Waiting on intervention
    Waiting: Waiting for resources
logs:
  sectionName: 'Section {{index}}'
  errorText: Something has gone wrong while fetching logs
  retry: '{{ $.retry }}'
conditionalExecution:
  title: Conditional Execution
  subTitle: Use conditions to determine when this {{entity}} is executed.
  statusOption:
    success: Execute this {{entity}} if the {{parentEntity}} execution is successful thus far
    all: Always execute this {{entity}}
    failure: Execute this {{entity}} only if prior {{parentEntity}} or {{entity}} failed
  condition: And execute this {{entity}} only if the following JEXL Condition evaluates to True
  toolTip:
    stageTitle: Conditions for stage execution
    stepTitle: Conditions for step execution
    resolvedVariables: RESOLVED VARIABLES
  belowExpression: below expression is true
startTime: Start time
duration: Duration
and: AND
gitDetails: git details
triggers:
  aboutTriggers: Triggers are used to automate the execution of pipelines based on some event like new artifact/manifest, or run on a schedule or an external webhook.
  addNewTrigger: Add New Trigger
  triggersLabel: 'Triggers'
  triggersSubLabel: 'All Trigger Types'
  searchPlaceholder: 'Search Triggers'
  noTriggersFound: 'No Triggers Found'
  newTrigger: + New Trigger
  pipelineExecutionInput: Pipeline Execution Input
  lastActivationDetails: Last Activation Details
  lastActivationAt: 'Last activation at'
  showAllTriggers: 'Show all Triggers'
  onNewWebhookTitle: 'On New Webhook'
  onNewArtifactTitleWhole: 'On New Artifact'
  onNewManifestTitleWhole: 'On New Manifest'
  onNewArtifactTitle: 'On New {{artifact}}'
  onNewScheduleTitle: 'On New Schedule'
  newArtifactLabel: 'New Artifact'
  newManifestLabel: 'New Manifest'
  onScheduleLabel: 'On Schedule'
  cronLabel: 'Cron'
  scheduledLabel: 'Scheduled'
  triggerConfigurationLabel: 'Trigger Configuration'
  pipelineInputLabel: 'Pipeline Input'
  updateTrigger: 'Update Trigger'
  createTrigger: 'Create Trigger'
  deleteTrigger: 'Delete Trigger'
  confirmDelete: 'Are you sure you want to delete trigger' # followed by name
  pageNotFound: 'Page not found'
  triggerLabel: 'Trigger'
  lastActivationLabel: 'LAST ACTIVATION'
  activityActivation: '{{numActivations}} Activations in'
  activityDays: 'Last {{numDays}} days'
  copyAsUrl: 'Copy as Webhook URL'
  copyAsCurl: 'Copy as cURL Command'
  cannotParseTriggersData: 'Cannot parse trigger data'
  cannotParseInputValues: 'Cannot parse pipeline input values'
  validation:
    triggerName: 'Trigger Name is required.'
    identifier: 'Identifier is required.'
    event: 'Event is required.'
    connector: 'Connector is required.'
    repoName: 'Repository Name is required for Connector with Account URL Type.'
    actions: 'Actions is required.'
    operator: 'Operator is required with Matches Value.'
    matchesValue: 'Matches Value is required with Operator.'
    payloadConditions: 'Each payload condition requires values for Attribute, Operator, and Matches Value.'
    headerConditions: 'Each header condition requires values for Attribute, Operator, and Matches Value.'
    selectedArtifact: '{{artifact}} is required.'
    eventConditions: 'Each event condition requires values for Attribute, Operator, and Matches Value.'
    cronExpression: 'Valid cron expression is required.'
  toast:
    successfulCreate: 'Successfully created {{name}}.'
    successfulUpdate: 'Successfully updated {{name}}.'
    toggleEnable: 'Successfully {{enabled}} {{name}}.'
    webhookUrlCopied: 'Webhook URL is copied to clipboard.'
    webhookCurlCopied: 'Webhook cURL Command is copied to clipboard.'
  triggerConfigurationPanel:
    title: 'Trigger Configuration: On New Webhook'
    triggerName: 'Trigger Name'
    listenOnNewWebhook: 'Listen on New Webhook'
    payloadType: 'Payload Type'
    event: 'Event'
    actions: Actions
    anyActions: Any Actions
    autoAbortPush: 'If a branch is updated, Harness will automatically cancel active builds for the same branch if invoked by the same Trigger.'
    autoAbortPR: 'If a PR is updated, Harness will automatically cancel active builds for the same PR if invoked by the same Trigger.'
    autoAbortIssueComment: 'If a PR is updated with a new comment, Harness will automatically cancel active builds for the same PR.'
    eventPlaceholder: Select Event
  conditionsPanel:
    subtitle: 'Specify the conditions for executing the pipeline - you can choose to trigger the pipeline only when your artifact build or tag or label matches a certain value or pattern.'
    subtitleManifest: 'Specify the conditions for executing the pipeline - you can choose to trigger the pipeline only when your manifest version matches a certain value or pattern.'
    sourceBranch: Source Branch
    sourceBranchPlaceholder: Enter Source Branch
    targetBranch: Target Branch
    targetBranchPlaceholder: Enter Target Branch
    changedFiles: 'Changed Files'
    branchName: 'Branch Name'
    tagName: 'Tag Name'
    headerConditions: 'Header Conditions'
    payloadConditions: 'Payload Conditions'
    attribute: 'Attribute'
    operator: 'Operator'
    matchesValue: 'Matches Value'
    jexlCondition: 'JEXL Condition'
    jexlConditionPlaceholder: Enter JEXL Condition
    matchesValuePlaceholder: Enter Matches Value
    manifestVersion: Manifest version
    artifactBuild: Artifact Build
  pipelineInputPanel:
    noRuntimeInputs: 'No Runtime Inputs'
    automaticallyExtractedFromText: Automatically extracted from event payload
    selectedExisitingOrProvide: 'Select an existing Input Set or provide new set of values'
    existing: Use Existing Input Sets
    provide: Provide Values
    whatAreInputsets: What are Input Sets?
  triggerOverviewPanel:
    title: 'Trigger Overview'
  schedulePanel:
    title: 'Schedule'
    minutesLabel: 'Minutes'
    hourlyTabTitle: '{{$.common.hourly}}'
    dailyTabTitle: '{{$.common.daily}}'
    weeklyTabTitle: 'Weekly'
    monthlyTabTitle: '{{$.common.monthly}}'
    yearlyTabTitle: '{{$.common.yearly}}'
    runEvery: 'Run every'
    runDailyAt: 'Run daily at'
    runAt: 'Run at'
    runOn: 'Run on'
    runOnSpecificDay: 'Run on a specific day at monthly interval'
    runOnSpecificDayMonth: 'Run on a specific day and month'
    startingWith: 'Starting with'
    enterCustomCron: 'Enter a custom cron expression'
    minutesParentheses: 'minute(s)'
    minutesAfterTheHour: 'minute(s) after the hour'
    hoursAnd: 'hours(s) and'
    ofEvery: 'of every'
    onThe: 'on the'
    monthsParentheses: 'month(s)'
    hoursLabel: 'Hours'
    dayOfMonthLabel: 'Day of month'
    monthLabel: 'Month'
    dayOfWeekLabel: 'Day of week'
    MON: 'MON'
    TUE: 'TUE'
    WED: 'WED'
    THU: 'THU'
    FRI: 'FRI'
    SAT: 'SAT'
    SUN: 'SUN'
    expressionBreakdown: 'Expression Breakdown'
    cronExpression: 'Cron Expression'
  artifactTriggerConfigPanel:
    artifact: 'Artifact'
    artifactRepository: '{{artifact}} Repository'
    buildTag: 'Build/Tag'
    configureInput: 'Configure Input'
    listenOnNewArtifact: 'Listen on New {{artifact}}'
    plusSelect: '+ Select {{artifact}}'
    selectAnArtifact: 'Select an Artifact Reference'
    selectAManifest: 'Select a Manifest Reference'
    configureArtifactRuntimeInputs: 'Configure {{artifact}} Runtime Inputs'
    noSelectableArtifactsFound: 'No selectable {{artifact}}s found. Please add one in the pipeline.'
    noArtifacts: No artifacts for selected stage.
    configureInputs: Configure inputs
    hasRuntimeInputs: 'Has Runtime Inputs'
    runtimeInput: 'Runtime Input'
    chartVersionRuntimeInput: Some {{artifact}} references may be unselectable because Chart Version must be a runtime input.
    artifactReferenceUnique: 'Some {{artifact}} references may not be available for selection because they must be unique and not from a previous stage'
dashboards:
  failedBuilds: Failed Builds
  activeBuilds: Active Builds
  workloads: Workloads
  failedDeployments: Failed Deployments
  activeDeployments: Active Deployments
  pendingDeployments: Pending Approval/Manual Intervention
  noRepositories: No Repositories found
  noFailedBuilds: No Failed Builds found
  noActiveBuilds: No Active Builds found
  noWorkloads: 'No Workloads found'
  noFailedDeployments: 'No Failed Deployments found'
  noActiveDeployments: 'No Active Deployments found'
  noPendingDeployments: 'No Pending Deployments found'
  buildExecutions: Build Executions
  buildHealth: Build health
  totalBuilds: Total Builds
  testCycleTimeSaved: Test Cycle Time Saved
  successfulBuilds: Successful Builds
  pipelineHealth: Pipeline health
  totalExecutions: Total Executions
  successRate: Success Rate
  meanDuration: Mean Duration
  medianDuration: Median Duration
savingInProgress: Saving in progress...
gitExperience:
  skipNow: SKIP NOW
  selectRepoBranch: Please select Repository and Branch from the pipeline edit modal
  noPipelineFound: The pipeline does not exist in the selected Branch.
  selectDiffBranch: Please select a different Branch.
testsReports:
  callgraphTitle: Call Graph
  expandGraph: Expand graph
  codeChanges: Code changes ({{count}})
  unchangedMethods: Unchanged methods ({{count}})
  directCall: Direct call
  indirectCall: Indirect call
  sourceMethod: Source Class
  resource: Resource
  callgraphField:
    package: Package
    class: Class
    method: '{{ $.methodLabel }}'
    params: Params
    file: '{{ $.secret.labelFile }}'
    type: '{{ $.typeLabel }}'
  viewCallgraph: View Callgraph
  testMethods: Test methods
  changedTestMethods: Changed/New Test methods
  changedSourceMethods: Changed/New Source methods
  selectedTestMethods: Selected Test Methods
  sourceMethods: Source methods
  calls: Calls
  description: Failure Description
  type: Failure Type
  status: '{{ $.status }}'
  executionOverview: Test Execution Overview
  numberOfSelectedTests: 'Selected Tests'
  totalDuration: Total Duration
  testDuration: Test Duration
  timeSaved: Time Saved
  totalExecutedTest: Total Executed Tests
  selectionBreakdown: Test Selection Breakdown
  selectionBreakdownInfo: Shows aggregated data on how tests were selected
  totalWithColon: 'TOTAL:'
  failedWithColon: 'FAILED:'
  successWithColon: 'SUCCESS:'
  skippedWithColon: 'SKIPPED:'
  skipped: Skipped
  correlatedWithCodeChanges: Correlated with Code Changes
  newTests: New Tests
  updatedTests: Updated Tests
  coverage: Files Coverage
  coverageInfo: List of files that were added or changed in the build which don't have a proper testing coverage
  onlyUncoveredFiles: Only Uncovered Files
  filename: FILENAME
  commitId: COMMIT ID
  failedTests: Failed Tests
  failureMessage: Failure Message
  stackTrace: Stack Trace
  consoleOutput: Console Output
  testSuite: 'Test Suite:'
  totalTests: Total Tests
  testCaseName: TEST NAME
  className: CLASS NAME
  result: RESULT
  testCasesExecution: Tests Execution
  testExecutions: Test Executions
  testCasesExecutionInfo: Shows a list of executed tests and result. In case of error, hover the test to see additional information
  noFailedTestsFound: No failed tests found
  showOnlyFailedTests: Show only failed tests
  hangTight: Hang tight! Report is being generated...
  nothing: Nothing here!
  notfound: No tests were found to analyze.
  willBeDisplayedIfAvailable: Test reports will be displayed here if they are configured and available.
  learnMore: Learn how to enable Unit test reporting
  resultLabel: Test Execution Result
  resultInfo: Heat Map showing a graphical over of the test results
  sortBy: 'Sort by:'
uniqueIdentifier: Identifier must be unique
inputSets:
  applyInputSet: Apply Input Set
  applyInputSets: Apply Input Sets
  applyingInputSets: Applying Inputs Sets
  noRuntimeInputsCurrently: No runtime inputs in the pipeline currently
  noRuntimeInputsWhileExecution: No runtime inputs were present in the pipeline during this execution
  inputSetPlaceholder: Enter Input Sets
  selectPlaceholder: Select Input Set(s)
  aboutInputSets: Harness Input Sets are collections of variables/values that can be provided to one or more Pipelines before execution.
provisionerSteps: Provisioner Steps
addStage:
  title: Select stage type
  description: Hover over stage type for more info.
pipelineSteps:
  customStage: Custom Stage
  chainedPipeline: Chained Pipeline
  deployStageDescription: Deploy services, serverless functions or execute workloads.
  featureStageDescription: Enable or disable functionality remotely without redeploying code.
  approvalStageDescription: Approve or reject changes during Pipeline executions.
aboutYourStage:
  stageNamePlaceholder: Enter Stage Name
infraSpecifications:
  namespacePlaceholder: Enter Namespace
  serviceAccountName: Service Account Name
  serviceAccountNamePlaceholder: Enter Service Account Name
  initTimeout: Init Timeout
  initTimeoutPlaceholder: Enter Init Timeout
imagePathLabel: Image Path
artifactsSelection:
  artifactDetails: Artifact Details
  artifactTyperequired: Artifact Type is required
  existingDocker:
    sidecarId: Sidecar Identifier
    sidecarIdPlaceholder: Enter Artifact Identifier
    imageNamePlaceholder: Enter Image Path
    enterTagRegex: Enter Tag Regex
  validation:
    imagePath: Image Path is a required
    region: Region is required
    tag: Tag is required
    tagRegex: Tag Regex is required
    sidecarId: Sidecar Identifier is required
overrideSets:
  createOverrideSet: Create Override Set
  overrideSetPlaceholder: Enter Override Set Name
  overrideSetError: Override Set is required
  createOverrideSetPlus: + Create New Override Set
  configure: Configure pre-defined Override Sets (Advanced)
  overrideSetInfo: Override sets provide flexibility when specifying the service configuration. It can be used when stages requires different configuration from the initial specifications.
keyPlaceholder: Enter Key
operatorPlaceholder: Select Operator
variable:
  variableNamePlaceholder: Enter Variable Name
  typePlaceholder: Enter Type
moveStage:
  title: 'Move Pipeline Stage'
  description: 'Propagation is set up between this stage and another stage. Moving the parent/child stage out of sequence resets any propagated settings to their defaults. Do you want to continue?'
verification:
  currentTest: Current test
  testsRan: Tests ran
  baselineTest: Baseline test
  metricsInViolation: Metrics in violation
  logClustersInViolation: Log Clusters in violation
  metricViewPlaceholder: Filter for a metric or transaction
  anomalousMetrics: Anomalous Metrics
  anomalousLogClusters: Anomalous Log Clusters
  healthSourcePlaceholder: Filter by Health Source
  refreshViewForNewData: Latest incoming data available.
  toGetLatest: to get latest
  noMetrics: No Metrics or Transactions
  waitForAnalysis: Please wait a few moments for analysis to begin...
  analysisTab:
    metrics: 'Metrics'
    logs: 'Logs'
  logs:
    logCluster: Log cluster
    filterByClusterType: Filter by cluster type
    knownEvent: Known Event
    unknownEvent: Unknown Event
    unexpectedFrequency: Unexpected Frequency
    noAnalysis: No analysis
    clusterType: CLUSTER TYPE
    sampleMessage: MESSAGE
    messageFrequency: MESSAGE FREQUENCY
    messageCount: COUNT
    actions: ACTIONS
    risk: RISK
    copyURL: Copy url
    urlCopied: URL copied
    share: share
    sampleEvent: Sample event
    trend: trend
stepCommonFields:
  runAsUser: Run as User
  ifNotPresent: 'If Not Present'
  validation:
    mustBeANumber: '{{label}} must be a number'
ciCodebase:
  prCloneStrategy: Pull Request Clone Strategy
tagDependencyRequired: required to fetch the tags
myDeploymentsText: My Deployments
myBuildsText: My Builds
noBuckets: No buckets found with given region
gitRepos: Git Repos
buildRepo: Build Repo
stepDescription:
  HTTP: Run HTTP requests containing URLs, methods, headers, assertions, and variables.
  SHELLSCRIPT: Execute scripts in the shell session. The scripts can be executed on the pod/instance running a Harness Delegate or on a remote host in the infrastructure.
  Barrier: Synchronize multiple Pipelines to coordinate deployments systematically.
  K8sRollingRollback: Roll back the workloads deployed by the stage.
  K8sBlueGreenDeploy: Deploy your new app version to the stage environment.
  K8sCanaryDeploy: Define how many pods are deployed for a Canary test of your new service version.
  K8sBGSwapServices: Swap services to route production traffic to the new version of the application and stage traffic to the old version.
  K8sScale: Update the number of pods running for a workload by count or percentage.
  K8sApply: Deploy individual Kubernetes workloads from your stage's Service.
  K8sCanaryDelete: Clean up the workload deployed by the Canary Deployment step.
  K8sDelete: Delete Kubernetes resources by name, manifest path, and release name.
  K8sRollingDeploy: Use a rolling update to schedule new pods on nodes with available resources. This step uses the number of replicas you specified in the Deployment manifest.
  Plugin: Use Docker containers to perform predefined tasks like deploy code, publish artifacts, send notifications, and more.
  Run: Execute one or more commands on a container image in a CI stage.
  GCR: Build an image and push it to Google Container Registry (GCR).
  ECR: Build an image and push it to AWS Elastic Container Registry (ECR).
  SaveCacheGCS: Preserve files and directories between builds using Google Cloud Storage (GCS).
  RestoreCacheGCS: Restore saved files and directories between builds using Google Cloud Storage (GCS).
  SaveCacheS3: Preserve files and directories between builds using AWS S3.
  RestoreCacheS3: Restore saved files and directories between builds using AWS S3.
  DockerHub: Build a Docker image from a Dockerfile and push it to a Docker registry.
  GCS: Upload artifacts to Google Cloud Storage (GCS).
  S3: Upload artifacts to AWS S3.
  JFrogArtifactory: Upload artifacts to JFrog Artifactory.
  RunTests: Execute unit, integration, and other tests on a CI container image.
  HarnessApproval: Add manual approvals as steps and stages.
  JiraApproval: Use Jira issues to approve steps and stages.
  Verify: Verify a deployment using your monitoring tools.
  JiraCreate: Create a Jira issue as a step in the execution of a Pipeline.
  JiraUpdate: Update a Jira issue as a step in the execution of a Pipeline.
  TerraformRollback: Roll back your provisioned infrastructure and resources and return your environment to its pre-deployment state.
  TerraformDestroy: Remove any infrastructure you've provisioned using Harness.
  TerraformPlan: Run a Terraform script as a Terraform plan.
  TerraformApply: Apply a Terraform plan or script.
  ResourceConstraint: Queue the number of resources Harness requests during a deployment by placing capacity limits on the requests.
  FlagConfiguration: Create a Boolean or Multivariate Feature Flag.
executionStrategy:
  executionStrategies: Execution Strategies
  useStrategy: Use Strategy
  strategies:
    rolling:
      description: All pods/instances in a single environment are incrementally replaced with a new service version without downtime.
      learnMoreLink: https://ngdocs.harness.io/article/0zsf97lo3c-deployment-concepts#rolling_deployment
      steps:
        step1:
          description: Test the new version.
        step2:
          description: Approve the new version.
        step3:
          description: Replace new version.
    blueGreen:
      description: 'Two identical environments for staging and production traffic run simultaneously with different versions of the service. Deployment of a new service version is first done to the staging environment. Once the new version is verified, network traffic is switched between the two environments. The staging environment is now the production environment.'
      learnMoreLink: https://ngdocs.harness.io/article/0zsf97lo3c-deployment-concepts#blue_green_deployment
      steps:
        step1:
          description: Maintain two identical fleets of servers.
        step2:
          description: Verify the services in the blue environment.
        step3:
          description: After verification, switch the load balancer to point to the newly-deployed fleet.
    canary:
      description: 'Harness performs a two phase deployment: Phase 1 adds new pods/instances with the new service version to a single environment. Phase 2 performs a Rolling Update in the same environment.'
      learnMoreLink: https://ngdocs.harness.io/article/0zsf97lo3c-deployment-concepts#canary_deployment
      steps:
        step1:
          title: 'Canary deployment:'
          description: 'Add canary pods until they guarantee you their safety'
        step2:
          title: 'Canary delete:'
          description: 'Update 50% new instances in phase 2 and verify it.'
        step3:
          title: 'Rolling Update:'
          description: 'Update all new instances in phase 3 and verify it.'
    default:
      actualName: '{{$.common.default}}'
      displayName: Blank Canvas
      description: A blank slate for custom processes. You can use any combination of steps. Only recommended for advanced users.
      learnMoreLink: https://ngdocs.harness.io/article/0zsf97lo3c-deployment-concepts#basic_deployment
    common:
      steps:
        step1:
          title: 'Step 1:'
        step2:
          title: 'Step 2:'
        step3:
          title: 'Step 3:'
