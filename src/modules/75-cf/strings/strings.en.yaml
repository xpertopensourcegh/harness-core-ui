continuous: '{{$.common.purpose.cf.continuous}}'
shared:
  individual: Individual
  target: '{{ $.pipelineSteps.targetLabel }}'
  targets: '{{ $.pipeline.targets.title }}'
  targetManagement: Target Management
  segment: Target group
  segments: Target Groups
  environment: environment
  lastEvaluated: Last Evaluated
  variation: Variation
  variations: Variations
  prerequisites: Prerequisites
  selectEnvironment: Select environment
  evaluations: Evaluations
  flags: Flags
  rules: Rules
  archived: archived
  selected: '{{ counter }} selected'
  pleaseSelectVariation: Please select a variation first.
  getStarted: '{{ $.getStarted }}'
  quickGuide: Quick Guide
messages:
  flagCreated: Flag created.
  flagUpdated: Flag updated.
  flagDeleted: Flag deleted.
  flagArchived: Flag archived.
  targetCreated: Target(s) created.
  targetUpdated: Target updated.
  targetDeleted: Target deleted.
  segmentCreated: Target group created.
  segmentUpdated: Target group updated.
  segmentDeleted: Target group deleted.
rbac:
  category: '{{$.featureFlagsText}}'
  featureflag:
    label: Feature flags
    edit: '{{ $.edit }}'
    delete: '{{ $.delete }}'
    toggle: Toggle
  targetgroup:
    label: '{{ $.cf.shared.targetManagement }}'
    edit: '{{ $.edit }}'
    delete: '{{ $.delete }}'
creationModal:
  jsonType: JSON
  variationSettingsHeading: Variation settings
  flagType: Flag Type
  defaultRules: Default rules for the flag
  flagOn: If the flag is ON, serve
  flagOff: If the flag is OFF, serve
  saveAndClose: '{{$.common.saveAndClose}}'
  nameIsRequired: Variation name is required
  valueIsRequired: Variation value is required
  idIsRequired: Variation identifier is required
  defaultVariationIsRequired: Default variation is required
  mustBeNumber: Value must be a number
  mustBeValidJSON: Value must be a valid JSON object.
  dataType: Data type
  defaultRulesTooltip: Define which variation users will see by default when the flag is ON or OFF
  testFlagOption: Test the Flag
  aboutFlag:
    aboutFlagHeading: About the flag
    permaFlag: This is a permanent flag
    nameRequired: Flag name is required
    idRequired: Flag identifier is required
    ffNamePlaceholder: Enter Feature Flag name...
    ffRegex: '{{$.common.validation.formatMustBeAlphanumeric}}'
    tagsOptional: Tags (optional)
    tagsPlaceholder: Add Tags
    permaFlagTooltip: A flag is permanent if you wish to keep it in your code for the long term. We won't remind you to these types of flags.
testTheFlag:
  testFlagHeading: Test the flag
  setupAppText: "Let's set up your application and code so that it can communicate with our platform"
  selectSdk: Select Your SDK
  sdkClient: Client
  sdkServer: Server
  selectSdkLanguage: Select the language
  installNode: Install Node.js dependency
  initClient: Initialize Client SDK
  codeSample: Place this sample code we generated of your feature flag into your code
  codeSampleNote: Please note that in the above example, it is whatever gets generated. This is just an example. This area can contain some minor notes if necessary.
  verify: '{{ $.verify }}'
  verifyText: "Once you're done, run your application so that we can verify that we are able to receive analytic events for your feature."
  testFlagTargetHeading: Testing feature flag on production environment
  confirmClose: Are you sure you want to close this modal?
editVariation:
  title: Edit Variations
  subTitle: '{{ type }} ({{ count }} variations)'
  add: + Variation
  defaultRulesDesc: "Changes will only apply to newly created environments. Existing environments won't be affected"
  envNote: Changes will only apply to newly created environments. Existing environments won’t be affected.
  applyToExistingEnvironments: Also apply to existing environments
addPrerequisites:
  addPrerequisitesHeading: Add Prerequisites
  addPrerequisitesDesc: The following must be met before your flag can be enabled
  selectFlag: Select a Flag
  selectVariation: Select a Variation
  editPrerequisitesHeading: Edit Prerequisites
editDetails:
  editDetailsHeading: Edit Flag Details
  permaFlag: '{{ $.cf.creationModal.aboutFlag.permaFlag }}'
boolean: Boolean
multivariate: Multivariate
featureNotReady: This feature is not yet ready. Please check back later.
noFlag: You currently have no flags
noTarget: There are currently no targets
noTargetForEnv: There are currently no targets for this environment
homepage:
  slogan: 'Take your feature rollout processes to the next level using our Harness Continuous Features.'
  learnMore: Learn more about Feature Flags
clause:
  operators:
    and: and
    in: '{{ $.common.in }}'
    startsWith: 'starts with'
    endsWith: 'ends with'
    match: 'match'
    contains: 'contains'
    equal: 'equals'
    equalSensitive: 'equals (sensitive)'
    matchSegment: 'Match Target Group'
featureFlags:
  newFlag: + Flag
  typeOfFlag: Select the Type of Flag You Want to Create
  startVariation: Start by selecting the variation type that the flag will use
  booleanBtnText: This is a simple ON/OFF toggle
  multi: '{{ $.cf.multivariate }}'
  multiBtnText: This is suitable for experiments
  percentageRollout: 'Percentage Rollout'
  turnOnHeading: Turn ON Flag
  turnOffHeading: Turn OFF Flag
  turnOnMessage: 'Please confirm that you want to turn on <strong>{{name}}</strong> on <strong>{{env}}</strong> environment.'
  turnOffMessage: 'Please confirm that you want to turn off <strong>{{name}}</strong> on <strong>{{env}}</strong> environment.'
  defaultWillBeServed: '<strong>{{defaultVariation}}</strong> will be served.'
  customRuleMessage: There are custom rules configured for this flag, please review the rules on detail page.
  defaultServedOn: '{{defaultVariation}} when flag is ON'
  defaultServedOff: '{{defaultVariation}} when flag is OFF'
  createdDate: 'Created: {{date}}'
  modifiedDate: 'Modified: {{date}}'
  prerequisitesDesc: '(what’s required before enabling flags)'
  ifFlagOnServe: 'If the flag is <strong>ON</strong>, serve '
  ifFlagOffServe: 'If the flag is <strong>OFF</strong>, serve '
  bucketBy: Bucket by <strong>{{targetField}}</strong>
  bucketOverflow: Cannot set above 100%
  serveVariationToTarget: '+ Serve variation to Target'
  serveVariationToTargetLabel: Serve Variation to Target
  customRuleOnRequest: '+ On Request, check for condition and serve variation'
  toTarget: to target
  ifClause: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}'
  ifClauseServe: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}, serve'
  ifClauseServePercentageRollout: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}, serve <strong>percentage rollout</strong>'
  andClause: '- and <strong>{{attribute}}</strong> {{operator}} {{values}}'
  commaSeparator: ', '
  serve: serve
  servePercentageRollout: serve <strong>percentage rollout</strong>
  deleteFlag: Delete Flag
  deleteFlagMessage: Are you sure you want to delete flag <strong>{{name}}</strong>? This action cannot be undone.
  archiveFlag: Archive Flag
  archiveFlagMessage: Are you sure you want to archive flag <strong>{{name}}</strong>? This action cannot be undone.
  flagOff: Flag is OFF
  flagOn: Flag is ON
  flagWillTurnOn: Turn flag on for this environment upon save
  flagWillTurnOff: Turn flag off for this environment upon save
  targeting: Targeting
  activity: '{{ $.activity }}'
  results: Results
  makeSure: Make sure your code is deployed
  rules:
    editRules: Edit Rules
    flagOn: '{{ $.cf.creationModal.flagOn }}'
    flagOff: '{{ $.cf.creationModal.flagOff }}'
    defaultRules: Default Rules
    customRules: Custom Rules (Serve specific targets differently)
    serveVariationToTarget: '{{ $.cf.featureFlags.serveVariationToTargetLabel }}'
    add: '{{ $.add }}'
    toTarget: '{{ $.cf.featureFlags.toTarget }}'
    following: to following
    serveToFollowing: 'serve to following:'
    onRequest: On Request
    onRequestVariation: 'On Request, check for condition and serve variation'
  flagFilters:
    environment: '{{ $.environment }}'
    envDefault: Production (Default)
    any: Any
    term: Term
    switchOnOff: Switch (ON/OFF)
    status: '{{ $.status }}'
    createdDate: '{{ $.cf.targets.createdDate }}'
    modifiedDate: Modified Date
    owner: Owner
    ownerOrPinPlaceholder: Individual or Team
    creator: Creator
    tagsPlaceholder: '{{ $.valueLabel }}'
    flagsBy: Only list flags pinned by
    target: '{{ $.pipelineSteps.targetLabel }}'
    individualTargets: Individual Target or Target Group
    apply: '{{ $.filters.apply }}'
    saveFilters: Save Filters
    overwriteRadio: Overwrite Existing
    createFilter: Create New Filter
    defaultFilter: Default Filter
    defaultFilterText: This filter will be applied by default when this listing is viewed everytime
    filterVisible: Who can see this filter?
    onlyMe: Only Me
    everyone: '{{ $.filters.visibleToEveryone }}'
    save: '{{ $.save }}'
    cancel: '{{ $.cancel }}'
  metrics:
    title: 'Metrics '
    noMetrics: No metrics
    evaluations: '{{ count }} evaluations'
    evaluationStatistics: Evaluation Statistic
    flagEvaluations: Flag Evaluations ({{ count }})
    targetServed: Target Served  ({{ count }})
    noData: No metrics found in this time range.
    totalEvaluations: Total Evaluations
featureFlagDetail:
  variationCount: '{{ count }} variations'
targets:
  ID: '{{ $.common.ID }}'
  name: name
  targetSegment: Target Group
  lastActivity: '{{ $.lastActivity }}'
  createdDate: Created Date
  create: + Target(s)
  list: Add a target
  upload: Upload a list of targets (CSV files only)
  enterName: 'Enter target name'
  enterValue: 'Enter target identifier'
  addTargetsLabel: Add Target(s)
  addTargets: + Add Target(s)
  noTargetFound: 'No target found in this environment. Click the button above to create target(s).'
  noSegmentFound: 'No target group found in this environment. Click the button above to create a target group.'
  uploadHeadline: Please upload a CSV file according to our <a href="https://docs.harness.io" target="_blank" rel="noreferrer">template</a>.
  uploadHelp: 'Target CSV entry format: Name,Identifier'
  uploadYourFile: Click to upload your file
  uploadStats: <strong>Targets</strong> ({{ count }})
  noneDefined: None Defined
  deleteTarget: Delete Target
  deleteTargetMessage: Are you sure you want to delete target <strong>{{name}}</strong>? This action cannot be undone.
  deleteTargetSuccess: Target <strong>{{name}}</strong> deleted.
  pageDescription: This list displays targets manually added or impacted by flags.
targetDetail:
  title: 'Targets: Individual'
  environmentLine: '<strong>Environment</strong>: {{name}}'
  createdOnDate: Created on {{ date }}, {{ time }} PST
  targetSetting: Target Settings
  flagSetting: Flag Settings
  attribute: ATTRIBUTE
  attributes: Attributes ({{ counter }})
  learnMore: To learn how to mark specific target attributes or information as private, read <a href="https://docs.harness.io" target="_blank" rel="noreferrer">documentation</a>.
  manuallyAdded: MANUALLY ADDED
  addToSegment: Add to Target Group
  autoAdded: AUTOMATICALLY ADDED THROUGH CONDITIONS
  exclusionList: EXCLUSION LIST
  excludefromSegment: Exclude from Target Group
  removeSegment: Remove from list
  noSegmentAdded: No Target Group added
  noSegmentMatched: No Target Group matched
  noSegmentExcluded: No Target Group excluded
  addTargetToSegment: Add Target to Target Group
  excludeTargetFromSegment: Exclude Target from Target Group
  exclude: Exclude
  removeFromIncludeListTitle: Remove from include list
  removeFromIncludeList: Are you sure you want to remove target <strong>{{targetName}}</strong> from include target group <strong>{{ segmentName}}</strong>? This action cannot be undone.
  removeFromExcludeListTitle: Remove from exclusion list
  removeFromExcludeList: Are you sure you want to remove target <strong>{{targetName}}</strong> from exclusion target group <strong>{{ segmentName}}</strong>? This action cannot be undone.
  noFlagConfigured: No feature flags configured for this target
  searchPlaceholder: Search Feature Flags...
  deleteTargetSuccess: Target <strong>{{name}}</strong> deleted.
selectSegmentModal:
  searchSegmentPlaceholder: Search for Target Group by Name or Description
  flagsUsingSegment: '{{ counter }} flag'
  flagsUsingThisSegment: FLAGS USING THIS TARGET GROUP
  empty: No Target Group found
segments:
  create: + Target Group
  targetDefinition: Target Definition
  usingSegment: Flags using this target group
  usingSegmentWithCount: Flags using this target group ({{ count }})
  modalTitle: Create a Target Group
  displayIcon: Display Icon
  uploadImage: Upload an image
  delete:
    message: 'Are you sure you want to delete target group <strong>{{segmentName}}</strong>? This action cannot be undone.'
    title: Delete Target Group
  nameRequired: Target Group name is required
  idRequired: Target Group identifier is required
  noSegment: There are currently no target groups
  noSegmentForEnv: There are currently no target groups for this environment
  pageDescription: Target Groups allow you to serve flag variations to a list of targets in bulk.
environments:
  title: '{{ $.environments }}'
  empty: 'There are currently no environments'
  modifiedBy: 'Modified by'
  adminEnvironments: 'Admin: Environments'
  delete:
    message: 'Are you sure you want to delete environment <strong>{{name}}</strong>?'
    title: 'Delete Environment'
  create:
    title: 'Create an Environment'
    description: 'An environment is the representation of your production or non-production infrastructure'
    envTypeLabel: 'Environment type'
    nameLabel: 'Name of your environment'
  apiKeys:
    addKeyTitle: Create SDK Key
    message: 'Secrets are only visible right after creation and redacted once you leave the page. Please make sure to copy and store your secret somewhere safe'
    title: 'SDK Keys'
    addKey: '+ Add Key'
    clientType: '{{ $.cf.testTheFlag.sdkClient }}'
    serverType: '{{ $.cf.testTheFlag.sdkServer }}'
    deleteTitle: 'Confirm Key Delete'
    deleteMessage: 'Are you sure you want to delete Key: {{keyName}}? You cannot recover it afterwards'
    keyType: 'Key Type'
    noKeysFound: 'No SDK Keys found in this environment. Click the button below to create a Key'
auditLogs:
  title: Audit Logs
  summaryHeading: 'Module: Feature Flags • Project: {{project}} • Environment: {{environment}}'
  last7days: Last 7 days
  searchPlaceholder: Search Activity
  viewEventSummary: View Event Summary
  timePST: 'TIME (PST)'
  user: USER
  action: ACTION
  moduleFF: 'Module: Feature Flags'
  flagCreated: Feature activation created
  segmentCreated: Target Group created
  flagUpdated: Feature activation updated
  unknown: Unknown activity
  empty: No activity found during this time.
  eventSummary: Event Summary
  createdMessageFF: 'created feature flag'
  createdMessageFFUpdate: 'updated feature flag'
  createdMessageSegment: 'created target group'
  yamlDifference: YAML Difference
  changeDetails: Change details
  events:
    updateClause: A clause was updated for a rule
    reorderRules: Rules reordered
    updateDefaultServe:
      bucketBy: Default serve updated for bucket by '{{bucketBy}}'
      variation: Default serve updated with variation '{{variation}}'
    addTargetsToVariationTargetMap: Target '{{target}}' was added for Variation '{{variation}}'
    updateDescription: Description updated to '{{description}}'
    updateName: Name updated to '{{name}}'
    updatePermanent: Permanent set to '{{permanent}}'
    addRule: A rule was added with clauses '{{clauses}}'
    updateRule: Rule updated
    removeRule: Rule removed
    addVariation: Variation '{{variation}}' added
    updateVariation: Variation '{{variation}}' updated
    deleteVariation: Variation '{{variation}}' deleted
    setDefaultOnVariation: Default on variation set to '{{variation}}'
    setDefaultOffVariation: Default off variation set to '{{variation}}'
    addSegmentToVariationTargetMap: Target Group '{{segment}}' added for Variation '{{variation}}'
    setFeatureFlagStateOn: Flag turned on
    setFeatureFlagStateOff: Flag turned off
    tagUpdated: Tags updated
    addPrerequisite: Prerequisite '{{name}}' added
    removePrerequisite: Prerequisite '{{name}}' removed
    updatePrerequisite: Prerequisite '{{name}}' updated
    removeTargetsToVariationTargetMap: Variation '{{variation}}' removed for targets '{{targets}}'
    clearVariationTargetMapping: Variation target mapping removed
    updateOffVariation: Off variation updated to '{{variation}}'
    removeClause: A clause was removed
noEnvironment:
  title: No Environment Available
  message: Create an environment and let’s start configuring the targeting rules of your flag
pipeline:
  default: Default Setting # Placeholder, not a real text
  stages:
    setup:
      title: Flag Setup # Placeholder, not a real text
    execution:
      title: Flag Execution # Placeholder, not a real text
segmentDetail:
  directlyAdded: Directly Added
  autoAdded: Automatically Added Through Conditions
  removeFomFlag: Remove from Flag
  noFlagsUseThisSegment: No Flags use this target group.
  addToFlag: + Add to Flag
  addSegmentToFlag: Add Target Group to Flag
selectFlagsModal:
  empty: No feature flags found.
  searchPlaceholder: Search for Flag by name or description
onboarding:
  listeningToEvent: We’re listening for your flag event...
  simpliestFlag: Our Simplest Flag
  simpliestFlagDescription: 'You’re creating our simplest feature flag type: Boolean Flag. This flag type is commonly used as a feature toggle, which effectively shows/hides features from your targets.'
  otherTypes: Check out other flag types
  connected: "\r\n\r\nSDK is connected\r\nFlag variation is served\r\n\r\nVerification complete."
  behindTheSenes: In case you’re wondering what’s happening behind the scenes…
  waitForConnect: Waiting for SDK...{{ message }}
  allSet: Congratulations! You’re all set!
  tryTarget: Try out our robust <a href='{{ link }}'>targeting rules for this flag</a> for more granular rollouts.
  backToStart: Back to Start Guide
  title: Continuous Features Quick Guide
  subTitle: Everything you need to know in less than 15 minutes.
  upAndRunning: Get a flag up and running in 3 steps
  tryItOut: Try it Out
  createAFlag: '1. Create a Flag'
  setUpApp: '2. Set Up Your Application'
  testYourFlag: '3. Test Your Flag'
  letsStart: Let's start off by creating a simple flag
  inputLabel: Give your flag a memorable name
  successLabel: 'You have created <strong>{{name}}</strong> with ID: <strong>{{identifier}}</strong>'
  setupLabel: Set up your application and code to communicate with our platform.
  selectLanguage: Select your language
  selectEnvironment: Select your environment
  createEnv: + Create an environment
  envCreated: Environment Created
  sdkKeyLabel: Please create an SDK key for your environment
  sdkButtonLabel: + Create SDK Key
  keyDescriptionServer: We generated a secret as the server-side SDK key of your new environment for you to use in your code below. This secret will be redacted once you leave the page, so make sure to copy and store your secret somewhere safe.
  keyDescriptionClient: We generated a client-side SDK key of your new environment for you to use in your code below.
  secret: SDK Secret
  clientKey: Client SDK Key
  setUpYourCode: Set up your code
  listenToEvent: We’re listening for the event of your feature flag.
  toggleLabel: Toggle your flag ON/OFF and verify that the event we received has the same value.
  help:
    heading1: The Importance of Your Flag ID
    text1: Your flag ID is required to reference the flag in your code.
    heading2: Installing an SDK to Your Environment
    text2: Your flag is automatically available for use in all environments of your project. However, you need to install our SDK to environments you wish to initiate your flag in.
    getStarted: Get started with SDKs
    test:
      heading: About Flag Events
      text1: Every time a feature flag is evaluated by your application or platform, it creates an event to let our service know that the flag was used.
      text2: Flag events are necessary to provide more information about the overall health and performance of your flags.
      readmore: Read more...
  readme:
    java: |
      # 1. <a href="https://search.maven.org/artifact/io.harness/ff-java-server-sdk">Download our SDK</a> and add the CF Client SDK to your project

      ```
      <dependency>
        <groupId>io.harness.cf</groupId>
        <artifactId>cf-client-sdk-java</artifactId>
        <version>0.0.3</version>
      </dependency>
      ```

      # 2. Import the CF Cient SDK

      ```
      import com.CfClient.*;
      ```

      # 3. Authorize your application to connect to our CF client with the SDK key of your environment

      The CfClient SDK downloads and stores the latest values automatically every 60 seconds.

      ```
      // Please replace this value with the SDK Key of
      // your 'Development' environment
      CfClient cfClient = new CfClient("{{apiKey}}"");
      ```

      # 4. Place this sample code we generated of your feature flag into your code.

      ```
      public class HelloWorld {
        public static void main(String[] args) throws Exception {
          String apiKey = "{{apiKey}}";
          CfClient cfClient = new CfClient(apiKey);

          Target target = Target.builder().name("User1").identifier("user1@example.com").build();

          while (true) {
            Thread.sleep(2000);
            boolean result = cfClient.boolVariation("toggle", target, false);
            System.out.println("Boolean variation is "+ result);
          }
        }
      }
      ```

      Once you’re done, run your application so that we can verify that we are able to receive analytic events for your feature.
    javascript: |
      # Install our <a href="https://github.com/drone/ff-javascript-client-sdk">SDK</a> into your project

      ```
      npm i @harnessio/ff-javascript-client-sdk
      ```

      If you use yarn

      ```
      yarn add @harnessio/ff-javascript-client-sdk
      ```

      # Usage

      ```
      import { initialize, Event } from '@harnessio/ff-javascript-client-sdk'
      ```

      Initialize SDK with api key and target information.

      ```
      initialize(FeatureFlagSDKKey: string, target: Target, options?: Options)
      ```

      In which Target and Options are defined as:

      ```
      interface Target {
        identifier: string
        name?: string
        anonymous?: boolean
        attributes?: object
      }

      interface Options {
        baseUrl?: string
        debug?: boolean
      }
      ```

      For example:

      ```
      const cf = initialize('{{apiKey}}', {
        identifier: YOUR-TARGET-IDENTIFIER,      // Target identifier
        name: YOUR-TARGET-NAME,                  // Optional target name
        attributes: {                            // Optional target attributes
          email: 'sample@sample.com'
        }
      })
      ```

      # Listening to events from the cf instance.

      ```
      cf.on(Event.READY, flags => {
        // Event happens when connection to server is established
        // flags contains all evaluations against SDK key
      })

      cf.on(Event.CHANGED, flagInfo => {
        // Event happens when a changed event is pushed
        // flagInfo contains information about the updated feature flag
      })

      cf.on(Event.DISCONNECTED, () => {
        // Event happens when connection is disconnected
      })

      cf.on(Event.ERROR, () => {
        // Event happens when connection some error has occurred
      })
      ```

      # Getting value for a particular feature flag

      ```
      // second argument is default value when variation does not exist
      const value = cf.variation('Dark_Theme', false)
      ```

      # Cleaning up

      Remove a listener of an event by cf.off.

      ```
      cf.off(Event.ERROR, () => {
        // Do something when an error occurs
      })
      ```

      Remove all listeners:

      ```
      cf.off()
      ```

      On closing your application, call cf.close() to close the event stream.

      ```
      cf.close();
      ```
    golang: |
      # Install

      ```
      go get github.com/wings-software/ff-client-sdk-go
      ```

      # Usage

      First we need to import lib with harness alias `import harness "github.com/wings-software/ff-client-sdk-go/pkg/api"`

      Next we create client instance for interaction with api `client := harness.NewClient(sdkKey)`

      Target definition can be user, device, app etc.

      ```
      target := dto.NewTargetBuilder("{{apiKey}}").
      Firstname("John").
      Lastname("doe").
      Email("johndoe@acme.com").
      Country("USA").
      Custom("height", 160).
      Build()
      ```

      Evaluating Feature Flag `showFeature, err := client.BoolVariation(featureFlagKey, target, false)`
    android: |
      # Setup

      Add following snippet to root project's `build.gradle` file:

      ```
      buildscript {
          repositories {
              mavenCentral()
          }
      ```

      In app module's `build.gradle` file add dependency for Harness's SDK
      `implementation 'io.harness:ff-android-client-sdk:0.0.2'`

      After this step, the SDK elements, primarily `CfClient` should be accessible in main application.

      # **_Initialization_**

      `CfClient` is base class that provides all features of SDK. This is singleton and it is acessed with `CfClient.getInstance()`.

      ```Kotlin
      val sdkConfiguration = CfConfiguration.builder()
          .baseUrl("BASE_API_URL")
          .pollingInterval(30) //time in seconds
          .enableStream(true)
          .streamUrl("STREAM_URL")
          .build()

      val target = Target().identifier("target")

      CfClient.getInstance().initialize(context, "YOUR_API_KEY", sdkConfiguration, target)
      ```

      `target` represents a desired target for which we want features to be evaluated.

      `"YOUR_API_KEY"` is a authentication key, needed for access to Harness services.

      **Your Harness SDK is now initialized. Congratulations!!!**

      # **_Public API Methods_** ###

      The Public API exposes a few methods that you can utilize:

      ```
      public void initialize(Context context, String clientId, CfConfiguration configuration, CloudCache cloudCache, AuthCallback authCallback)

      public boolean boolEvaluation(String evaluationId, boolean defaultValue)

      public String stringEvaluation(String evaluationId, String defaultValue)

      public double numberEvaluation(String evaluationId, double defaultValue)

      public JSONObject jsonVariation(String evaluationId, JSONObject defaultValue)

      public void registerEventsListener(EventsListener listener)

      public void unregisterEventsListener(EventsListener observer)

      public void destroy()
      ```

      ## Fetch evaluation's value

      It is possible to fetch a value for a given evaluation. Evaluation is performed based on different type. In case there is no evaluation with provided id, the default value is returned.

      Use appropriate method to fetch the desired Evaluation of a certain type.

      ### <u>_boolEvaluation(String evaluationId, boolean defaultValue)_</u>

      ```Kotlin
      //get boolean evaluation
      val evaluation: Boolean = CfClient.getInstance().boolVariation("demo_evaluation", false)
      ```

      ### <u>_numberEvaluation(String evaluationId, double defaultValue)_</u>

      ```Kotlin
      //get number evaluation
      val numberEvaluation: Double = CfClient.getInstance().numberVariation("demo_number_evaluation", 0)
      ```

      ### <u>_stringEvaluation(String evaluationId, String defaultValue)_</u>

      ```Kotlin
      //get String evaluation
      val stringEvaluation: String = CfClient.getInstance().stringVariation("demo_string_evaluation", "demo_value")
      ```

      ## _Register for events_

      This method provides a way to register a listener for different events that might be triggered by SDK, indicating specific change in SDK itself.

      ```Kotlin
      private final EventsListener eventsListener = statusEvent -> {
          if (statusEvent.getEventType() == EVALUATION_CHANGE) {
              Evaluation evaluation = statusEvent.extractPayload();
          }
      }

      CfClient.getInstance().registerEventsListener(eventsListener)
      ```

      Triggered event will have one of the following types:

      ```Java
      public enum EVENT_TYPE {
              SSE_START,
              SSE_END,
              EVALUATION_CHANGE,
              EVALUATION_RELOAD
          }
      ```

      Following table provides summary on possible event types and corresponding responses.

      ```
      | EVENT_TYPE        | Response          |
      | -------------     |:-------:          |
      | SSE_START         | -                 |
      | SSE_END           | -                 |
      | EVALUATION_CHANGE | `Evaluation`      |
      | EVALUATION_RELOAD | `List<Evaluation>`|
      ```

      To avoid unexpected behaviour, when listener is not needed anymore, a caller should call
      `CfClient.getInstance().unregisterEventsListener(eventsListener)`. This way the sdk will remove desired listener from internal list.

      ## _Shutting down the SDK_

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method

      ```Kotlin
      CfClient.getInstance().destroy()
      ```
    ios: |
      # _Installing the `ff-ios-client-sdk`_
      Installing ff-ios-client-sdk is possible with `Swift Package Manager (SPM), CocoaPods and Carthage`

      ## <u>_Swift Package Manager (SPM)_</u>

      The [Swift Package Manager](https://swift.org/package-manager/) is a dependency manager integrated into the `swift` compiler and `Xcode`.

      To integrate `ff-ios-client-sdk` into an Xcode project, go to the project editor, and select `Swift Packages`. From here hit the `+` button and follow the prompts using  `https://github.com/drone/ff-ios-client-sdk.git` as the URL.

      To include `ff-ios-client-sdk` in a Swift package, simply add it to the dependencies section of your `Package.swift` file. And add the product `ff-ios-client-sdk` as a dependency for your targets.

      ```Swift
      dependencies: [
          .package(url: "https://github.com/drone/ff-ios-client-sdk.git", .upToNextMinor(from: "0.0.5"))
      ]
      ```

      ## <u>_CocoaPods_</u>

      The [CocoaPods](https://cocoapods.org//) CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 81 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.

      CocoaPods is built with Ruby and it will be installable with the default Ruby available on macOS. You can use a Ruby Version manager, however we recommend that you use the standard Ruby available on macOS unless you know what you're doing.

      Using the default Ruby install will require you to use sudo when installing gems. (This is only an issue for the duration of the gem installation, though.)

      ```Swift
      $ sudo gem install cocoapods
      ```

      Once cocoapods are installed, from your root project folder, create a `Podfile`, which will be located in your project's root folder, by entering the next command in your terminal:

      ```Swift
      $ pod init
      ```

      To import `ff-ios-client-sdk` to your `.xcproject`, simply add `ff-ios-client-sdk` to your newly created Podfile and save the Podfile changes.

      ```Swift
      platform :ios, '10.0'
      use_frameworks!

      target 'MyApp' do
        pod 'ff-ios-client-sdk'
      end
      ```

      Only thing left to do is to install your packages by running the next command.

      ```Swift
      $ pod install
      ```

      NOTE: A new `.xcworkspace` will be created and you should use that, instead of your `.xcodeproj` from now on in order to utilize the imported Pods.

      ## <u>_Carthage_</u>

      Carthage is intended to be the simplest way to add frameworks to your Cocoa application.
      Carthage builds your dependencies and provides you with binary frameworks, but you retain full control over your project structure and setup. Carthage does not automatically modify your project files or your build settings.

      In order to integrate `ff-ios-client-sdk` into your app, there are a few steps to follow.
      Navigate to the root folder of your project and create a `Cartfile`. This is the file where you would input all of your dependencies that you plan to use with Carthage. You can create it by entering

      ```Swift
      $ touch Cartfile
      ```

      in Terminal at your project's root folder. Once you open the `Cartfile`, you can copy/paste below line and save the changes.

      ```Swift
      github "drone/ff-ios-client-sdk"
      ```

      Now, you need to run

      ```Swift
      $ carthage update --no-build
      ```

      This command will fetch the source for `ff-ios-client-sdk` from the repository specified in the `Cartfile`.

      You will now have a new folder, named `Carthage` at the same location your `Cartfile` and your `.xcodeproj` are.

      Within the `Carthage` folder, you will see another `Checkout` folder where the source code is located.

      Next, we need to create a project for `ff-ios-client-sdk` dependency. We can do this easily by entering the following in the termial.

      ```Swift
      //From your project's root folder
      $ cd Carthage/Checkouts/ff-ios-client-sdk
      ```

      followed by

      ```Swift
      $ swift package generate-xcodeproj
      ```
      ...or, you can enter it all on the same line.

      ```Swift
      //From your project's root folder
      $ cd Carthage/Checkouts/ff-ios-client-sdk && swift package generate-xcodeproj
      ```

      Go back into your project's root folder and enter the next command:

      ```Swift
      $ carthage build --use-xcframeworks --platform iOS
      ```

      This command will build the project and place it in the `Build` folder next to `Checkouts`.
      On your application targets’ `General` settings tab, in the `Frameworks, Libraries, and Embedded Content` section, drag and drop the `.xcframework` file from the `Carthage/Build` folder. In the `"Embed"` section, select `"Embed & Sign"`.

      Only thing left to do is:

      ```Swift
      import ff_ios_client_sdk
      ```
      ...wherever you need to use `ff-ios-client-sdk`

      When a new version of `ff-ios-client-sdk` is available and you wish to update this dependency, run

      ```Swift
      $ carthage update --use-xcframeworks --platform iOS
      ```
      And your embedded library will be updated.

      # _Using the `ff-ios-client-sdk`_

      In order to use `ff-ios-client-sdk` in your application, there are a few steps that you would need to take.

      ## **_Initialization_**

      1. Setup your configuration by calling `CfConfiguration`'s static method `builder()` and pass-in your prefered configuration settings through possible chaining methods. The chaining needs to be ended with `build()` method. (See the `build()`'s description for possible chaining methods and their default values.)
      2. Setup your target by calling `CfTarget`'s static method `builder()` and pass-in your prefered target settings through possible chaining methods. The chaining needs to be ended with `build()` method. (See the `build()`'s description for possible chaining methods and their default values). Target's `identifier` is mandatory and represents the `Account` from which you wish to receive evaluations.

      2. Call `CfClient.sharedInstance.initialize(apiKey:configuration:target:cache:onCompletion:)` and pass in your Harness CF `apiKey`, previously created configuration object, target and an optional cache object adopting `StorageRepositoryProtocol`.

          If `cache` object is omitted, internal built-in cache will be used. You can also omitt `onCompletion` parameter if you don't need initialization/authorization information.

      **Your `ff-ios-client-sdk` is now initialized. Congratulations!!!**

      Upon successful initialization and authorization, the completion block of `CfClient.sharedInstance.initialize(apiKey:configuration:target:cache:onCompletion:)` will deliver `Swift.Result<Void, CFError>` object. You can then switch through it's `.success(Void)` and `.failure(CFError)` cases and decide on further steps depending on a result.

      ### <u>_initialize(apiKey:configuration:cache:onCompletion:)_</u>

      ```Swift
      let configuration = CfConfiguration.builder().setStreamEnabled(true).build()
      let target = CfTarget.builder().setIdentifier("YOUR_ACCOUNT_IDENTIFIER").build()
      CfClient.sharedInstance.initialize(apiKey: "YOUR_API_KEY", configuration: configuration, target: target) { (result) in
          switch result {
              case .failure(let error):
                  //Do something to gracefully handle initialization/authorization failure
              case .success:
                  //Continue to the next step after successful initialization/authorization
          }
      }
      ```

      ## **_Implementation_**

      The Public API exposes few methods that you can utilize:
      Please note that all of the below methods are called on `CfClient.sharedInstance`

      ```
      public func initialize(apiKey:configuration:target:cache:onCompletion:)` -> Called first as described above in the **_initialization_** section. `(Mandatory)

      public func registerEventsListener(events:onCompletion:)` -> Called in the ViewController where you would like to receive the events. `(Mandatory)

      public func destroy()

      // Fetching from cache methods

      public func stringVariation(evaluationId:defaultValue:completion:)

      public func boolVariation(evaluationId:defaultValue:completion:)

      public func numberVariation(evaluationId:defaultValue:completion:)

      public func jsonVariation(evaluationId:defaultValue:completion:)
      ```


      ### <u>_registerEventsListener(events:onCompletion:)_</u>

      `events` is an array of events that you would like to subscribe to. It defaults to `*`, which means ALL events.
      In order to be notified of the SSE events sent from the server, you need to call `CfClient.sharedInstance.registerEventsListener()` method

      **NOTE**: Registering to events is usually done in `viewDidLoad()` method when events are required in only one ViewController _OR_ `viewDidAppear()` if there are more than one registration calls throughout the app, so the events could be re-registered for the currently visible ViewController.

      The completion block of this method will deliver `Swift.Result<EventType, CFError>` object. You can use `switch` statement within it's `.success(EventType)` case to distinguish which event has been received and act accordingly as in the example below or handle the error gracefully from it's `.failure(CFError)` case.

      ```Swift
      CfClient.sharedInstance.registerEventsListener() { (result) in
          switch result {
              case .failure(let error):
                  //Gracefully handle error
              case .success(let eventType):
                  switch eventType {
                      case .onPolling(let evaluations):
                          //Received all evaluation flags -> [Evaluation]
                      case .onEventListener(let evaluation):
                          //Received an evaluation flag -> Evaluation
                      case .onComplete:
                          //Received a completion event, meaning that the
                          //SSE has been disconnected
                      case .onOpen(_):
                          //SSE connection has been established and is active
                      case .onMessage(let messageObj):
                          //An empty Message object has been received
                  }
              }
          }
      }
      ```

      ## _Fetching from cache methods_

      The following methods can be used to fetch an Evaluation from cache, by it's known key. Completion handler delivers `Evaluation` result. If `defaultValue` is specified, it will be returned if key does not exist. If `defaultValue` is omitted, `nil` will be delivered in the completion block. Fetching is done for specified target identifier during initialize() call.

      Use appropriate method to fetch the desired Evaluation of a certain type.

      ### <u>_stringVariation(forKey:defaultValue:completion:)_</u>

      ```Swift
      CfClient.sharedInstance.stringVariation("your_evaluation_id", defaultValue: String?) { (evaluation) in
          //Make use of the fetched `String` Evaluation
      }
      ```

      ### <u>_boolVariation(forKey:defaultValue:completion:)_</u>

      ```Swift
      CfClient.sharedInstance.boolVariation("your_evaluation_id", defaultValue: Bool?) { (evaluation) in
          //Make use of the fetched `Bool` Evaluation
      }
      ```

      ### <u>_numberVariation(forKey:defaultValue:completion:)_</u>

      ```Swift
      CfClient.sharedInstance.numberVariation("your_evaluation_id", defaultValue: Int?) { (evaluation) in
          //Make use of the fetched `Int` Evaluation
      }
      ```

      ### <u>_jsonVariation(forKey:defaultValue:completion:)_</u>

      ```Swift
      CfClient.sharedInstance.jsonVariation("your_evaluation_id", defaultValue: [String:ValueType]?) { (evaluation) in
          //Make use of the fetched `[String:ValueType]` Evaluation
      }
      ```

      `ValueType` can be one of the following:

      ValueType.bool(Bool)`
      ValueType.string(String)
      ValueType.int(Int)
      ValueType.object([String:ValueType])

      ## _Shutting down the SDK_

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method.
      Also, you need to call this method when changing accounts through `CfTarget` object, in order to re-initialize and fetch Evaluations for the right account.

      ```Swift
      CfClient.sharedInstance.destroy()
      ```
    dotnet: |
      # Install

      To be defined...
learnMore: Learn more about Continuous Features
cfTrialHomePage:
  startTrial:
    description: Take your feature release processes to the next level using our Harness Continuous Features.
    startBtn:
      description: Start 14 day CF Enterprise trial
