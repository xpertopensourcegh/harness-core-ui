/*
 * Copyright 2022 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = '2.0'
export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Abort'
}

export interface ApprovalInstanceDetailsDTO {
  [key: string]: any
}

export interface ApprovalInstanceResponse {
  createdAt?: number
  deadline?: number
  details: ApprovalInstanceDetailsDTO
  errorMessage?: string
  id?: string
  lastModifiedAt?: number
  status: 'WAITING' | 'APPROVED' | 'REJECTED' | 'FAILED' | 'EXPIRED'
  type: 'HarnessApproval' | 'JiraApproval' | 'ServiceNowApproval'
}

export interface ApproverInput {
  name?: string
  value: string
}

export interface ApproverInputInfoDTO {
  defaultValue?: string
  name?: string
}

export interface ApproversDTO {
  disallowPipelineExecutor?: boolean
  minimumCount?: number
  userGroups?: string[]
}

export type ArtifactTriggerConfig = NGTriggerSpecV2 & {
  artifactRef?: string
  spec?: ArtifactTypeSpec
  stageIdentifier?: string
  type?: 'Gcr' | 'Ecr' | 'DockerRegistry' | 'Nexus3Registry' | 'ArtifactoryRegistry'
}

export interface ArtifactTypeSpec {
  [key: string]: any
}

export type ArtifactoryRegistrySpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  tag?: string
}

export type AuditFilterProperties = FilterProperties & {
  actions?: (
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'UPSERT'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'CREATE_TOKEN'
    | 'REVOKE_TOKEN'
    | 'LOGIN'
    | 'LOGIN2FA'
    | 'UNSUCCESSFUL_LOGIN'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
  )[]
  endTime?: number
  environments?: Environment[]
  modules?: ('CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE')[]
  principals?: Principal[]
  resources?: ResourceDTO[]
  scopes?: ResourceScopeDTO[]
  startTime?: number
  staticFilter?: 'EXCLUDE_LOGIN_EVENTS' | 'EXCLUDE_SYSTEM_EVENTS'
}

export interface AwsCodeCommitEventSpec {
  [key: string]: any
}

export type AwsCodeCommitPushSpec = AwsCodeCommitEventSpec & {
  connectorRef?: string
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type AwsCodeCommitSpec = WebhookTriggerSpecV2 & {
  spec?: AwsCodeCommitEventSpec
  type?: 'Push'
}

export interface BarrierExecutionInfo {
  identifier?: string
  name?: string
  stages?: StageDetail[]
  started?: boolean
  startedAt?: number
  timeoutIn?: number
}

export interface BarrierInfo {
  name?: string
  stages?: StageDetail[]
  timeoutIn?: number
}

export interface BarrierSetupInfo {
  identifier?: string
  name?: string
  stages?: StageDetail[]
}

export interface BitbucketEventSpec {
  [key: string]: any
}

export type BitbucketPRSpec = BitbucketEventSpec & {
  actions?: ('Create' | 'Update' | 'Merge' | 'Decline')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type BitbucketPushSpec = BitbucketEventSpec & {
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type BitbucketSpec = WebhookTriggerSpecV2 & {
  spec?: BitbucketEventSpec
  type?: 'PullRequest' | 'Push'
}

export interface BuildDetails {
  buildType?: string
}

export interface BuildStore {
  spec?: BuildStoreTypeSpec
  type?: 'Http' | 'S3' | 'Gcs'
}

export interface BuildStoreTypeSpec {
  [key: string]: any
}

export interface CcmConnectorFilter {
  awsAccountId?: string
  azureSubscriptionId?: string
  azureTenantId?: string
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
  gcpProjectId?: string
  k8sConnectorRef?: string
}

export interface ConditionDTO {
  key: string
  operator: 'equals' | 'not equals' | 'in' | 'not in'
  value: string
}

export interface ConnectorCheckResponse {
  connectorIdentifier?: string
  errorInfo?: PreFlightEntityErrorInfo
  fqn?: string
  stageIdentifier?: string
  stageName?: string
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
  stepIdentifier?: string
  stepName?: string
}

export type ConnectorFilterProperties = FilterProperties & {
  categories?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  connectorIdentifiers?: string[]
  connectorNames?: string[]
  description?: string
  inheritingCredentialsFromDelegate?: boolean
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
  )[]
}

export interface ConnectorWrapperResponse {
  checkResponses?: ConnectorCheckResponse[]
  label?: string
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
}

export interface CriteriaSpecDTO {
  [key: string]: any
}

export interface CriteriaSpecWrapperDTO {
  spec: CriteriaSpecDTO
  type: 'Jexl' | 'KeyValues'
}

export type CronTriggerSpec = ScheduledTriggerSpec & {
  expression?: string
}

export type CustomTriggerSpec = WebhookTriggerSpecV2 & {
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
}

export interface DashboardPipelineExecutionInfo {
  pipelineExecutionInfoList?: PipelineExecutionInfo[]
}

export interface DashboardPipelineHealthInfo {
  executions?: PipelineHealthInfo
}

export interface DelegateInfo {
  id?: string
  name?: string
  taskId?: string
  taskName?: string
}

export type DockerRegistrySpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  tag?: string
}

export type EcrSpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  region?: string
  tag?: string
}

export interface EdgeLayoutList {
  currentNodeChildren?: string[]
  nextIds?: string[]
}

export interface EmbeddedUser {
  email?: string
  externalUserId?: string
  name?: string
  uuid?: string
}

export interface EntityGitDetails {
  branch?: string
  filePath?: string
  objectId?: string
  repoIdentifier?: string
  repoName?: string
  rootFolder?: string
}

export interface EntityValidityDetails {
  invalidYaml?: string
  valid?: boolean
}

export interface Environment {
  identifier: string
  type: 'PreProduction' | 'Production'
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface ExecutableResponse {
  [key: string]: any
}

export interface ExecutionErrorInfo {
  [key: string]: any
}

export interface ExecutionGraph {
  nodeAdjacencyListMap?: {
    [key: string]: ExecutionNodeAdjacencyList
  }
  nodeMap?: {
    [key: string]: ExecutionNode
  }
  representationStrategy?: 'camelCase'
  rootNodeId?: string
}

export interface ExecutionInfo {
  endTs?: number
  startTs?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  uuid?: string
}

export interface ExecutionMetadata {
  [key: string]: any
}

export interface ExecutionNode {
  baseFqn?: string
  delegateInfoList?: DelegateInfo[]
  endTs?: number
  executableResponses?: ExecutableResponse[]
  failureInfo?: FailureInfoDTO
  identifier?: string
  interruptHistories?: InterruptEffect[]
  name?: string
  nodeRunInfo?: NodeRunInfo
  outcomes?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  progressData?: {
    [key: string]: { [key: string]: any }
  }
  setupId?: string
  skipInfo?: SkipInfo
  startTs?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  stepDetails?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  stepParameters?: {
    [key: string]: { [key: string]: any }
  }
  stepType?: string
  unitProgresses?: UnitProgress[]
  uuid?: string
}

export interface ExecutionNodeAdjacencyList {
  children?: string[]
  nextIds?: string[]
}

export interface ExecutionTriggerInfo {
  [key: string]: any
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface FailureInfoDTO {
  failureTypeList?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
    | 'POLICY_EVALUATION_FAILURE'
  )[]
  message?: string
  responseMessages?: ResponseMessage[]
}

export interface FailureStrategyActionConfig {
  type: 'Ignore' | 'Retry' | 'MarkAsSuccess' | 'Abort' | 'StageRollback' | 'StepGroupRollback' | 'ManualIntervention'
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig
}

export interface FilterDTO {
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface FilterProperties {
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
  tags?: {
    [key: string]: string
  }
}

export type GcrSpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  registryHostname?: string
  tag?: string
}

export type GcsBuildStoreTypeSpec = BuildStoreTypeSpec & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
}

export interface GithubEventSpec {
  [key: string]: any
}

export type GithubIssueCommentSpec = GithubEventSpec & {
  actions?: ('Create' | 'Edit' | 'Delete')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GithubPRSpec = GithubEventSpec & {
  actions?: ('Close' | 'Edit' | 'Open' | 'Reopen' | 'Label' | 'Unlabel' | 'Synchronize')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GithubPushSpec = GithubEventSpec & {
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GithubSpec = WebhookTriggerSpecV2 & {
  spec?: GithubEventSpec
  type?: 'PullRequest' | 'Push' | 'IssueComment'
}

export interface GitlabEventSpec {
  [key: string]: any
}

export type GitlabPRSpec = GitlabEventSpec & {
  actions?: ('Open' | 'Close' | 'Reopen' | 'Merge' | 'Update' | 'Sync')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GitlabPushSpec = GitlabEventSpec & {
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GitlabSpec = WebhookTriggerSpecV2 & {
  spec?: GitlabEventSpec
  type?: 'MergeRequest' | 'Push'
}

export interface GovernanceMetadata {
  [key: string]: any
}

export interface GraphLayoutNode {
  barrierFound?: boolean
  edgeLayoutList?: EdgeLayoutList
  endTs?: number
  failureInfo?: ExecutionErrorInfo
  failureInfoDTO?: FailureInfoDTO
  module?: string
  moduleInfo?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  name?: string
  nodeGroup?: string
  nodeIdentifier?: string
  nodeRunInfo?: NodeRunInfo
  nodeType?: string
  nodeUuid?: string
  skipInfo?: SkipInfo
  startTs?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  stepDetails?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
}

export interface HarnessApprovalActivity {
  action: 'APPROVE' | 'REJECT'
  approvedAt?: number
  approverInputs?: ApproverInput[]
  comments?: string
  user: EmbeddedUser
}

export interface HarnessApprovalActivityRequest {
  action: 'APPROVE' | 'REJECT'
  approverInputs?: ApproverInput[]
  comments?: string
}

export interface HarnessApprovalInstanceAuthorization {
  authorized?: boolean
  reason?: string
}

export type HarnessApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  approvalActivities?: HarnessApprovalActivity[]
  approvalMessage: string
  approverInputs?: ApproverInputInfoDTO[]
  approvers: ApproversDTO
  includePipelineExecutionHistory?: boolean
}

export type HelmManifestSpec = ManifestTypeSpec & {
  chartName?: string
  chartVersion?: string
  eventConditions?: TriggerEventDataCondition[]
  store?: BuildStore
}

export type HttpBuildStoreTypeSpec = BuildStoreTypeSpec & {
  connectorRef?: string
}

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Ignore'
}

export interface InputSetError {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export interface InputSetErrorWrapper {
  errorPipelineYaml?: string
  type?: string
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export interface InputSetResponse {
  accountId?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  errorResponse?: boolean
  gitDetails?: EntityGitDetails
  identifier?: string
  inputSetErrorWrapper?: InputSetErrorWrapper
  inputSetYaml?: string
  name?: string
  orgIdentifier?: string
  outdated?: boolean
  pipelineIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface InputSetSanitiseResponse {
  inputSetUpdateResponse?: InputSetResponse
  shouldDeleteInputSet?: boolean
}

export interface InputSetSummaryResponse {
  createdAt?: number
  description?: string
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  identifier?: string
  inputSetErrorDetails?: InputSetErrorWrapper
  inputSetType?: 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  isOutdated?: boolean
  lastUpdatedAt?: number
  modules?: string[]
  name?: string
  overlaySetErrorDetails?: {
    [key: string]: string
  }
  pipelineIdentifier?: string
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface InputSetTemplateRequest {
  stageIdentifiers?: string[]
}

export interface InputSetTemplateResponse {
  expressionValues?: {
    [key: string]: string
  }
  inputSetTemplateYaml?: string
  inputSetYaml?: string
  latestTemplateYaml?: string
}

export interface InputSetTemplateWithReplacedExpressionsResponse {
  hasInputSets?: boolean
  inputSetTemplateYaml?: string
  modules?: string[]
  replacedExpressions?: string[]
}

export interface InterruptConfig {
  [key: string]: any
}

export interface InterruptEffect {
  interruptConfig: InterruptConfig
  interruptId: string
  interruptType:
    | 'UNKNOWN'
    | 'ABORT'
    | 'ABORT_ALL'
    | 'PAUSE'
    | 'PAUSE_ALL'
    | 'RESUME'
    | 'RESUME_ALL'
    | 'RETRY'
    | 'IGNORE'
    | 'WAITING_FOR_MANUAL_INTERVENTION'
    | 'MARK_FAILED'
    | 'MARK_SUCCESS'
    | 'NEXT_STEP'
    | 'END_EXECUTION'
    | 'MARK_EXPIRED'
    | 'CUSTOM_FAILURE'
    | 'EXPIRE_ALL'
    | 'UNRECOGNIZED'
  tookEffectAt: number
}

export type JexlCriteriaSpec = CriteriaSpecDTO & {
  expression?: string
}

export type JiraApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  approvalCriteria: CriteriaSpecWrapperDTO
  connectorRef?: string
  issue: JiraIssueKeyNG
  rejectionCriteria: CriteriaSpecWrapperDTO
}

export interface JiraIssueKeyNG {
  key: string
  url: string
}

export interface JsonNode {
  array?: boolean
  bigDecimal?: boolean
  bigInteger?: boolean
  binary?: boolean
  boolean?: boolean
  containerNode?: boolean
  double?: boolean
  float?: boolean
  floatingPointNumber?: boolean
  int?: boolean
  integralNumber?: boolean
  long?: boolean
  missingNode?: boolean
  nodeType?: 'ARRAY' | 'BINARY' | 'BOOLEAN' | 'MISSING' | 'NULL' | 'NUMBER' | 'OBJECT' | 'POJO' | 'STRING'
  null?: boolean
  number?: boolean
  object?: boolean
  pojo?: boolean
  short?: boolean
  textual?: boolean
  valueNode?: boolean
}

export interface LandingDashboardRequestPMS {
  orgProjectIdentifiers: OrgProjectIdentifier[]
}

export interface LastTriggerExecutionDetails {
  lastExecutionStatus?: string
  lastExecutionSuccessful?: boolean
  lastExecutionTime?: number
  message?: string
  planExecutionId?: string
}

export type ManifestTriggerConfig = NGTriggerSpecV2 & {
  manifestRef?: string
  spec?: ManifestTypeSpec
  stageIdentifier?: string
  type?: 'HelmChart'
}

export interface ManifestTypeSpec {
  [key: string]: any
}

export interface ManualFailureSpecConfig {
  onTimeout: OnTimeoutConfig
  timeout: string
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig
  type: 'ManualIntervention'
}

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsSuccess'
}

export interface MeanMedianInfo {
  duration?: number
  rate?: number
}

export interface MergeInputSetRequest {
  inputSetReferences?: string[]
  stageIdentifiers?: string[]
  withMergedPipelineYaml?: boolean
}

export interface MergeInputSetResponse {
  completePipelineYaml?: string
  errorResponse?: boolean
  inputSetErrorWrapper?: InputSetErrorWrapper
  pipelineYaml?: string
}

export interface MergeInputSetTemplateRequest {
  runtimeInputYaml?: string
}

export interface NGTag {
  key: string
  value: string
}

export interface NGTriggerConfigV2 {
  description?: string
  enabled?: boolean
  identifier: string
  inputYaml?: string
  name?: string
  orgIdentifier?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  source?: NGTriggerSourceV2
  tags?: {
    [key: string]: string
  }
}

export interface NGTriggerDetailsResponse {
  buildDetails?: BuildDetails
  description?: string
  enabled?: boolean
  executions?: number[]
  identifier?: string
  lastTriggerExecutionDetails?: LastTriggerExecutionDetails
  name?: string
  registrationStatus?: 'SUCCESS' | 'FAILED' | 'ERROR' | 'TIMEOUT' | 'UNAVAILABLE'
  tags?: {
    [key: string]: string
  }
  triggerStatus?: TriggerStatus
  type?: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled'
  webhookDetails?: WebhookDetails
  webhookUrl?: string
  yaml?: string
}

export interface NGTriggerResponse {
  accountIdentifier?: string
  description?: string
  enabled?: boolean
  errorResponse?: boolean
  errors?: {
    [key: string]: {
      [key: string]: string
    }
  }
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  targetIdentifier?: string
  type?: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled'
  version?: number
  yaml?: string
}

export interface NGTriggerSourceV2 {
  spec?: NGTriggerSpecV2
  type?: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled'
}

export interface NGTriggerSpecV2 {
  [key: string]: any
}

export type NexusRegistrySpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  repositoryFormat?: string
  repositoryName?: string
  tag?: string
}

export interface NodeRunInfo {
  [key: string]: any
}

export interface NotificationChannelWrapper {
  spec?: PmsNotificationChannel
  type?: string
}

export interface NotificationRules {
  enabled?: boolean
  name?: string
  notificationMethod?: NotificationChannelWrapper
  pipelineEvents?: PipelineEvent[]
}

export interface OnFailureConfig {
  action: FailureStrategyActionConfig
  errors: (
    | 'Unknown'
    | 'AllErrors'
    | 'Authentication'
    | 'Connectivity'
    | 'Timeout'
    | 'Authorization'
    | 'Verification'
    | 'DelegateProvisioning'
    | 'PolicyEvaluationFailure'
  )[]
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig
}

export interface OrgProjectIdentifier {
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface OverlayInputSetResponse {
  accountId?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  errorResponse?: boolean
  gitDetails?: EntityGitDetails
  identifier?: string
  inputSetReferences?: string[]
  invalidInputSetReferences?: {
    [key: string]: string
  }
  name?: string
  orgIdentifier?: string
  outdated?: boolean
  overlayInputSetYaml?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface PMSPipelineResponseDTO {
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  modules?: string[]
  resolvedTemplatesPipelineYaml?: string
  version?: number
  yamlPipeline?: string
}

export interface PMSPipelineSummaryResponse {
  createdAt?: number
  description?: string
  entityValidityDetails?: EntityValidityDetails
  executionSummaryInfo?: ExecutionSummaryInfo
  filters?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  gitDetails?: EntityGitDetails
  identifier?: string
  lastUpdatedAt?: number
  modules?: string[]
  name?: string
  numOfStages?: number
  stageNames?: string[]
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface Page {
  content?: { [key: string]: any }[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageFilterDTO {
  content?: FilterDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageInputSetSummaryResponse {
  content?: InputSetSummaryResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageNGTriggerDetailsResponse {
  content?: NGTriggerDetailsResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PagePMSPipelineSummaryResponse {
  content?: PMSPipelineSummaryResponse[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PagePipelineExecutionSummary {
  content?: PipelineExecutionSummary[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface Pageable {
  offset?: number
  pageNumber?: number
  pageSize?: number
  paged?: boolean
  sort?: Sort
  unpaged?: boolean
}

export interface PipelineCountInfo {
  failure?: number
  success?: number
  total?: number
}

export interface PipelineEvent {
  forStages?: string[]
  type?:
    | 'AllEvents'
    | 'PipelineStart'
    | 'PipelineSuccess'
    | 'PipelineFailed'
    | 'PipelineEnd'
    | 'PipelinePaused'
    | 'StageSuccess'
    | 'StageFailed'
    | 'StageStart'
    | 'StepFailed'
}

export interface PipelineExecutionDetail {
  executionGraph?: ExecutionGraph
  pipelineExecutionSummary?: PipelineExecutionSummary
}

export type PipelineExecutionFilterProperties = FilterProperties & {
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
  pipelineName?: string
  status?: (
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  )[]
}

export interface PipelineExecutionInfo {
  count?: PipelineCountInfo
  date?: number
}

export interface PipelineExecutionSummary {
  allowStageExecutions?: boolean
  canRetry?: boolean
  createdAt?: number
  endTs?: number
  executionErrorInfo?: ExecutionErrorInfo
  executionTriggerInfo?: ExecutionTriggerInfo
  failedStagesCount?: number
  gitDetails?: EntityGitDetails
  governanceMetadata?: GovernanceMetadata
  layoutNodeMap?: {
    [key: string]: GraphLayoutNode
  }
  moduleInfo?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  modules?: string[]
  name?: string
  pipelineIdentifier?: string
  planExecutionId?: string
  runSequence?: number
  runningStagesCount?: number
  showRetryHistory?: boolean
  stagesExecuted?: string[]
  stagesExecutedNames?: {
    [key: string]: string
  }
  stagesExecution?: boolean
  startTs?: number
  startingNodeId?: string
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  successfulStagesCount?: number
  tags?: NGTag[]
  totalStagesCount?: number
}

export interface PipelineExpandedJson {
  expandedJson?: string
}

export type PipelineFilterProperties = FilterProperties & {
  description?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
  name?: string
  pipelineIdentifiers?: string[]
  pipelineTags?: NGTag[]
}

export interface PipelineHealthInfo {
  meanInfo?: MeanMedianInfo
  medianInfo?: MeanMedianInfo
  success?: SuccessHealthInfo
  total?: TotalHealthInfo
}

export interface PipelineInputResponse {
  errorInfo?: PreFlightEntityErrorInfo
  fqn?: string
  stageName?: string
  stepName?: string
  success?: boolean
}

export interface PipelineOpaEvaluationContext {
  action?: string
  date?: string
  pipeline?: { [key: string]: any }
  user?: UserOpaEvaluationContext
}

export interface PipelineSaveResponse {
  governanceMetadata?: GovernanceMetadata
  identifier?: string
}

export interface PipelineWrapperResponse {
  label?: string
  pipelineInputResponse?: PipelineInputResponse[]
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
}

export interface PipelinesCount {
  newCount?: number
  totalCount?: number
}

export interface PlanExecution {
  createdAt?: number
  endTs?: number
  governanceMetadata?: GovernanceMetadata
  lastUpdatedAt?: number
  metadata?: ExecutionMetadata
  nextIteration?: number
  nodeId?: string
  nodeType?: 'PLAN' | 'PLAN_NODE' | 'IDENTITY_PLAN_NODE'
  planId?: string
  setupAbstractions?: {
    [key: string]: string
  }
  startTs?: number
  status?:
    | 'NO_OP'
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'IGNORE_FAILED'
    | 'APPROVAL_WAITING'
    | 'RESOURCE_WAITING'
    | 'APPROVAL_REJECTED'
    | 'UNRECOGNIZED'
  uuid?: string
  validUntil?: string
  version?: number
}

export interface PlanExecutionResponseDto {
  gitDetails?: EntityGitDetails
  planExecution?: PlanExecution
}

export interface PmsAbstractStepNode {
  description?: string
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  timeout?: string
  when?: StepWhenCondition
}

export type PmsEmailChannel = PmsNotificationChannel & {
  recipients?: string[]
  userGroups?: string[]
}

export type PmsMSTeamChannel = PmsNotificationChannel & {
  msTeamKeys?: string[]
  userGroups?: string[]
}

export interface PmsNotificationChannel {
  [key: string]: any
}

export type PmsPagerDutyChannel = PmsNotificationChannel & {
  integrationKey?: string
  userGroups?: string[]
}

export type PmsSlackChannel = PmsNotificationChannel & {
  userGroups?: string[]
  webhookUrl?: string
}

export interface PollingSubscriptionStatus {
  detailedMessage?: string
  statusResult?: 'SUCCESS' | 'FAILED' | 'UNKNOWN'
}

export interface PreFlightCause {
  cause?: string
}

export interface PreFlightDTO {
  connectorWrapperResponse?: ConnectorWrapperResponse
  errorInfo?: PreFlightErrorInfo
  pipelineInputWrapperResponse?: PipelineWrapperResponse
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
}

export interface PreFlightEntityErrorInfo {
  causes?: PreFlightCause[]
  description?: string
  resolution?: PreFlightResolution[]
  summary?: string
}

export interface PreFlightErrorInfo {
  count?: number
  message?: string
}

export interface PreFlightResolution {
  resolution?: string
}

export interface Principal {
  identifier: string
  type: 'USER' | 'SYSTEM' | 'API_KEY' | 'SERVICE_ACCOUNT'
}

export interface ResourceConstraintDetail {
  pipelineIdentifier?: string
  planExecutionId?: string
  state?: 'BLOCKED' | 'ACTIVE' | 'FINISHED' | 'REJECTED'
}

export interface ResourceConstraintExecutionInfo {
  capacity?: number
  name?: string
  resourceConstraints?: ResourceConstraintDetail[]
}

export interface ResourceDTO {
  identifier: string
  labels?: {
    [key: string]: string
  }
  type:
    | 'ORGANIZATION'
    | 'PROJECT'
    | 'USER_GROUP'
    | 'SECRET'
    | 'RESOURCE_GROUP'
    | 'USER'
    | 'ROLE'
    | 'ROLE_ASSIGNMENT'
    | 'PIPELINE'
    | 'TRIGGER'
    | 'TEMPLATE'
    | 'INPUT_SET'
    | 'DELEGATE_CONFIGURATION'
    | 'DELEGATE_GROUPS'
    | 'SERVICE'
    | 'ENVIRONMENT'
    | 'DELEGATE'
    | 'SERVICE_ACCOUNT'
    | 'CONNECTOR'
    | 'API_KEY'
    | 'TOKEN'
    | 'DELEGATE_TOKEN'
}

export interface ResourceScopeDTO {
  accountIdentifier?: string
  labels?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseApprovalInstanceResponse {
  correlationId?: string
  data?: ApprovalInstanceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBarrierInfo {
  correlationId?: string
  data?: BarrierInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBoolean {
  correlationId?: string
  data?: boolean
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardPipelineExecutionInfo {
  correlationId?: string
  data?: DashboardPipelineExecutionInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardPipelineHealthInfo {
  correlationId?: string
  data?: DashboardPipelineHealthInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionNode {
  correlationId?: string
  data?: ExecutionNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFilterDTO {
  correlationId?: string
  data?: FilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseHarnessApprovalInstanceAuthorization {
  correlationId?: string
  data?: HarnessApprovalInstanceAuthorization
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetResponse {
  correlationId?: string
  data?: InputSetResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetSanitiseResponse {
  correlationId?: string
  data?: InputSetSanitiseResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetTemplateResponse {
  correlationId?: string
  data?: InputSetTemplateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetTemplateWithReplacedExpressionsResponse {
  correlationId?: string
  data?: InputSetTemplateWithReplacedExpressionsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJsonNode {
  correlationId?: string
  data?: JsonNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBarrierExecutionInfo {
  correlationId?: string
  data?: BarrierExecutionInfo[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBarrierSetupInfo {
  correlationId?: string
  data?: BarrierSetupInfo[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBitbucketPRAction {
  correlationId?: string
  data?: ('Create' | 'Update' | 'Merge' | 'Decline')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBitbucketTriggerEvent {
  correlationId?: string
  data?: ('PullRequest' | 'Push')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGithubIssueCommentAction {
  correlationId?: string
  data?: ('Create' | 'Edit' | 'Delete')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGithubPRAction {
  correlationId?: string
  data?: ('Close' | 'Edit' | 'Open' | 'Reopen' | 'Label' | 'Unlabel' | 'Synchronize')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGithubTriggerEvent {
  correlationId?: string
  data?: ('PullRequest' | 'Push' | 'IssueComment')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGitlabPRAction {
  correlationId?: string
  data?: ('Open' | 'Close' | 'Reopen' | 'Merge' | 'Update' | 'Sync')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGitlabTriggerEvent {
  correlationId?: string
  data?: ('MergeRequest' | 'Push')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListStageExecutionResponse {
  correlationId?: string
  data?: StageExecutionResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListWebhookAction {
  correlationId?: string
  data?: (
    | 'created'
    | 'closed'
    | 'edited'
    | 'updated'
    | 'opened'
    | 'reopened'
    | 'labeled'
    | 'unlabeled'
    | 'deleted'
    | 'synchronized'
    | 'synced'
    | 'merged'
    | 'sync'
    | 'open'
    | 'close'
    | 'reopen'
    | 'merge'
    | 'update'
    | 'pull request created'
    | 'pull request updated'
    | 'pull request merged'
    | 'pull request declined'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListWebhookTriggerType {
  correlationId?: string
  data?: ('Github' | 'Gitlab' | 'Bitbucket' | 'Custom' | 'AwsCodeCommit')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapStringMapStringListString {
  correlationId?: string
  data?: {
    [key: string]: {
      [key: string]: string[]
    }
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapWebhookSourceRepoListWebhookEvent {
  correlationId?: string
  data?: {
    [key: string]: (
      | 'Pull Request'
      | 'Push'
      | 'Issue Comment'
      | 'Delete'
      | 'Merge Request'
      | 'Repository'
      | 'Branch'
      | 'Tag'
    )[]
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMergeInputSetResponse {
  correlationId?: string
  data?: MergeInputSetResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
    | 'POLICY_EVALUATION_FAILURE'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponseNGTriggerDetailsResponse {
  correlationId?: string
  data?: NGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGTriggerResponse {
  correlationId?: string
  data?: NGTriggerResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNotificationRules {
  correlationId?: string
  data?: NotificationRules
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOverlayInputSetResponse {
  correlationId?: string
  data?: OverlayInputSetResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSPipelineResponseDTO {
  correlationId?: string
  data?: PMSPipelineResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSPipelineSummaryResponse {
  correlationId?: string
  data?: PMSPipelineSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFilterDTO {
  correlationId?: string
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageInputSetSummaryResponse {
  correlationId?: string
  data?: PageInputSetSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageNGTriggerDetailsResponse {
  correlationId?: string
  data?: PageNGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePagePMSPipelineSummaryResponse {
  correlationId?: string
  data?: PagePMSPipelineSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePagePipelineExecutionSummary {
  correlationId?: string
  data?: PagePipelineExecutionSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExecutionDetail {
  correlationId?: string
  data?: PipelineExecutionDetail
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExecutionInterrupt {
  correlationId?: string
  data?: PipelineExecutionInterrupt
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExpandedJson {
  correlationId?: string
  data?: PipelineExpandedJson
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineOpaEvaluationContext {
  correlationId?: string
  data?: PipelineOpaEvaluationContext
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineSaveResponse {
  correlationId?: string
  data?: PipelineSaveResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelinesCount {
  correlationId?: string
  data?: PipelinesCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePlanExecutionResponseDto {
  correlationId?: string
  data?: PlanExecutionResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePmsAbstractStepNode {
  correlationId?: string
  data?: PmsAbstractStepNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePreFlightDTO {
  correlationId?: string
  data?: PreFlightDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseResourceConstraintExecutionInfo {
  correlationId?: string
  data?: ResourceConstraintExecutionInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRetryHistoryResponseDto {
  correlationId?: string
  data?: RetryHistoryResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRetryInfo {
  correlationId?: string
  data?: RetryInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRetryLatestExecutionResponseDto {
  correlationId?: string
  data?: RetryLatestExecutionResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStepCategory {
  correlationId?: string
  data?: StepCategory
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseString {
  correlationId?: string
  data?: string
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateStepNode {
  correlationId?: string
  data?: TemplateStepNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseVariableMergeServiceResponse {
  correlationId?: string
  data?: VariableMergeServiceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseWebhookEventProcessingDetails {
  correlationId?: string
  data?: WebhookEventProcessingDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlSchemaResponse {
  correlationId?: string
  data?: YamlSchemaResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig
  type: 'Retry'
}

export interface RetryFailureSpecConfig {
  onRetryFailure: OnRetryFailureConfig
  retryCount: number
  retryIntervals: string[]
}

export interface RetryGroup {
  info?: RetryStageInfo[]
}

export interface RetryHistoryResponseDto {
  errorMessage?: string
  executionInfos?: ExecutionInfo[]
  latestExecutionId?: string
}

export interface RetryInfo {
  errorMessage?: string
  groups?: RetryGroup[]
  resumable?: boolean
}

export interface RetryLatestExecutionResponseDto {
  errorMessage?: string
  latestExecutionId?: string
}

export interface RetryStageInfo {
  createdAt?: number
  identifier?: string
  name?: string
  nextId?: string
  parentId?: string
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
}

export interface RunStageRequestDTO {
  expressionValues?: {
    [key: string]: string
  }
  runtimeInputYaml?: string
  stageIdentifiers?: string[]
}

export type S3BuildStoreTypeSpec = BuildStoreTypeSpec & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
  region?: string
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export type ScheduledTriggerConfig = NGTriggerSpecV2 & {
  spec?: ScheduledTriggerSpec
  type?: string
}

export interface ScheduledTriggerSpec {
  [key: string]: any
}

export interface SchemaErrorResponse {
  message?: string
}

export type ScmErrorMetadataDTO = ErrorMetadataDTO & {
  conflictCommitId?: string
}

export interface ServiceExpressionProperties {
  expression?: string
  serviceName?: string
}

export type ServiceNowApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  approvalCriteria: CriteriaSpecWrapperDTO
  connectorRef?: string
  rejectionCriteria: CriteriaSpecWrapperDTO
  ticket: ServiceNowTicketKeyNG
}

export interface ServiceNowTicketKeyNG {
  key: string
  ticketType: string
  url: string
}

export interface SkipInfo {
  [key: string]: any
}

export interface Sort {
  empty?: boolean
  sorted?: boolean
  unsorted?: boolean
}

export interface StackTraceElement {
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  nativeMethod?: boolean
}

export interface StageDetail {
  name?: string
}

export interface StageExecutionResponse {
  message?: string
  stageIdentifier?: string
  stageName?: string
  stagesRequired?: string[]
  toBeBlocked?: boolean
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StageRollback'
}

export interface StepCategory {
  name?: string
  stepCategories?: StepCategory[]
  stepsData?: StepData[]
}

export interface StepData {
  disabled?: boolean
  featureRestrictionName?:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'K8S_BG_SWAP_SERVICES'
    | 'K8S_BLUE_GREEN_DEPLOY'
    | 'K8S_APPLY'
    | 'K8S_DELETE'
    | 'K8S_CANARY_DELETE'
    | 'K8S_ROLLING_DEPLOY'
    | 'K8S_CANARY_DEPLOY'
    | 'K8S_SCALE'
    | 'K8S_ROLLING_ROLLBACK'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
    | 'SECURITY'
    | 'DEVELOPERS'
    | 'MONTHLY_ACTIVE_USERS'
  name?: string
  type?: string
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StepGroupRollback'
}

export interface StepPalleteFilterWrapper {
  stepPalleteModuleInfos?: StepPalleteModuleInfo[]
}

export interface StepPalleteModuleInfo {
  category?: string
  commonStepCategory?: string
  module?: string
  shouldShowCommonSteps?: boolean
}

export interface StepWhenCondition {
  condition?: string
  stageStatus: 'Success' | 'Failure' | 'All'
}

export interface SuccessHealthInfo {
  percent?: number
  rate?: number
}

export type TemplateFilterProperties = FilterProperties & {
  childTypes?: string[]
  description?: string
  templateEntityTypes?: ('Step' | 'Stage' | 'Pipeline')[]
  templateIdentifiers?: string[]
  templateNames?: string[]
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface TemplateLinkConfig {
  templateInputs?: JsonNode
  templateRef: string
  versionLabel?: string
}

export interface TemplateStepNode {
  description?: string
  identifier: string
  name: string
  template: TemplateLinkConfig
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export interface TotalHealthInfo {
  count?: number
  rate?: number
}

export interface TriggerEventDataCondition {
  key?: string
  operator?: 'In' | 'Equals' | 'NotEquals' | 'NotIn' | 'Regex' | 'EndsWith' | 'StartsWith' | 'Contains'
  value?: string
}

export interface TriggerStatus {
  pollingSubscriptionStatus?: PollingSubscriptionStatus
  validationStatus?: ValidationStatus
  webhookAutoRegistrationStatus?: WebhookAutoRegistrationStatus
}

export interface UnitProgress {
  [key: string]: any
}

export interface UserOpaEvaluationContext {
  email?: string
  name?: string
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export interface ValidationStatus {
  detailedMessage?: string
  statusResult?: 'SUCCESS' | 'FAILED' | 'UNKNOWN'
}

export interface VariableMergeServiceResponse {
  errorResponses?: string[]
  metadataMap?: {
    [key: string]: VariableResponseMapValue
  }
  serviceExpressionPropertiesList?: ServiceExpressionProperties[]
  yaml?: string
}

export interface VariableResponseMapValue {
  yamlOutputProperties?: YamlOutputProperties
  yamlProperties?: YamlProperties
}

export interface WebhookAutoRegistrationStatus {
  detailedMessage?: string
  registrationResult?: 'SUCCESS' | 'FAILED' | 'ERROR' | 'TIMEOUT' | 'UNAVAILABLE'
}

export interface WebhookDetails {
  webhookSecret?: string
  webhookSourceRepo?: string
}

export interface WebhookEventProcessingDetails {
  accountIdentifier?: string
  eventCreatedAt?: number
  eventFound?: boolean
  eventId?: string
  exceptionOccured?: boolean
  message?: string
  orgIdentifier?: string
  payload?: string
  pipelineExecutionId?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  runtimeInput?: string
  status?: string
  triggerIdentifier?: string
}

export type WebhookTriggerConfigV2 = NGTriggerSpecV2 & {
  spec?: WebhookTriggerSpecV2
  type?: 'Github' | 'Gitlab' | 'Bitbucket' | 'Custom' | 'AwsCodeCommit'
}

export interface WebhookTriggerSpecV2 {
  [key: string]: any
}

export interface YamlOutputProperties {
  [key: string]: any
}

export interface YamlProperties {
  [key: string]: any
}

export interface YamlSchemaResponse {
  schema?: JsonNode
  schemaErrorResponse?: SchemaErrorResponse
}

export interface ExecutionSummaryInfo {
  deployments?: number[]
  lastExecutionId?: string
  lastExecutionStatus?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  lastExecutionTs?: number
  numOfErrors?: number[]
}

export type KeyValueCriteriaSpec = CriteriaSpecDTO & {
  conditions: ConditionDTO[]
  matchAnyCondition?: boolean
}

export interface PipelineExecutionInterrupt {
  id?: string
  planExecutionId?: string
  type?:
    | 'AbortAll'
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'ExpireAll'
    | 'Retry'
}

export type FilterDTORequestBody = FilterDTO

export type FilterPropertiesRequestBody = FilterProperties

export type MergeInputSetRequestRequestBody = MergeInputSetRequest

export type NGTriggerConfigV2RequestBody = NGTriggerConfigV2

export type RunStageRequestDTORequestBody = RunStageRequestDTO

export type UpdateInputSetForPipelineBodyRequestBody = string

export type WebhookEndpointBodyRequestBody = string

export interface GetInitialStageYamlSnippetQueryParams {
  approvalType: 'HarnessApproval' | 'JiraApproval' | 'ServiceNowApproval'
}

export type GetInitialStageYamlSnippetProps = Omit<
  GetProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  'path'
>

/**
 * Gets the initial yaml snippet for Approval stage
 */
export const GetInitialStageYamlSnippet = (props: GetInitialStageYamlSnippetProps) => (
  <Get<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>
    path={`/approvals/stage-yaml-snippet`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInitialStageYamlSnippetProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  'path'
>

/**
 * Gets the initial yaml snippet for Approval stage
 */
export const useGetInitialStageYamlSnippet = (props: UseGetInitialStageYamlSnippetProps) =>
  useGet<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>(
    `/approvals/stage-yaml-snippet`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets the initial yaml snippet for Approval stage
 */
export const getInitialStageYamlSnippetPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>(
    getConfig('pipeline/api'),
    `/approvals/stage-yaml-snippet`,
    props,
    signal
  )

export interface GetApprovalInstancePathParams {
  approvalInstanceId: string
}

export type GetApprovalInstanceProps = Omit<
  GetProps<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>,
  'path'
> &
  GetApprovalInstancePathParams

/**
 * Gets an Approval Instance by identifier
 */
export const GetApprovalInstance = ({ approvalInstanceId, ...props }: GetApprovalInstanceProps) => (
  <Get<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>
    path={`/approvals/${approvalInstanceId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetApprovalInstanceProps = Omit<
  UseGetProps<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>,
  'path'
> &
  GetApprovalInstancePathParams

/**
 * Gets an Approval Instance by identifier
 */
export const useGetApprovalInstance = ({ approvalInstanceId, ...props }: UseGetApprovalInstanceProps) =>
  useGet<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>(
    (paramsInPath: GetApprovalInstancePathParams) => `/approvals/${paramsInPath.approvalInstanceId}`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Gets an Approval Instance by identifier
 */
export const getApprovalInstancePromise = (
  {
    approvalInstanceId,
    ...props
  }: GetUsingFetchProps<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams> & {
    approvalInstanceId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseApprovalInstanceResponse, Failure | Error, void, GetApprovalInstancePathParams>(
    getConfig('pipeline/api'),
    `/approvals/${approvalInstanceId}`,
    props,
    signal
  )

export interface AddHarnessApprovalActivityPathParams {
  approvalInstanceId: string
}

export type AddHarnessApprovalActivityProps = Omit<
  MutateProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >,
  'path' | 'verb'
> &
  AddHarnessApprovalActivityPathParams

/**
 * Add a new Harness Approval activity
 */
export const AddHarnessApprovalActivity = ({ approvalInstanceId, ...props }: AddHarnessApprovalActivityProps) => (
  <Mutate<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >
    verb="POST"
    path={`/approvals/${approvalInstanceId}/harness/activity`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseAddHarnessApprovalActivityProps = Omit<
  UseMutateProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >,
  'path' | 'verb'
> &
  AddHarnessApprovalActivityPathParams

/**
 * Add a new Harness Approval activity
 */
export const useAddHarnessApprovalActivity = ({ approvalInstanceId, ...props }: UseAddHarnessApprovalActivityProps) =>
  useMutate<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >(
    'POST',
    (paramsInPath: AddHarnessApprovalActivityPathParams) =>
      `/approvals/${paramsInPath.approvalInstanceId}/harness/activity`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Add a new Harness Approval activity
 */
export const addHarnessApprovalActivityPromise = (
  {
    approvalInstanceId,
    ...props
  }: MutateUsingFetchProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  > & { approvalInstanceId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    void,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >('POST', getConfig('pipeline/api'), `/approvals/${approvalInstanceId}/harness/activity`, props, signal)

export interface GetHarnessApprovalInstanceAuthorizationPathParams {
  approvalInstanceId: string
}

export type GetHarnessApprovalInstanceAuthorizationProps = Omit<
  GetProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >,
  'path'
> &
  GetHarnessApprovalInstanceAuthorizationPathParams

/**
 * Gets a Harness Approval Instance authorization for the current user
 */
export const GetHarnessApprovalInstanceAuthorization = ({
  approvalInstanceId,
  ...props
}: GetHarnessApprovalInstanceAuthorizationProps) => (
  <Get<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >
    path={`/approvals/${approvalInstanceId}/harness/authorization`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetHarnessApprovalInstanceAuthorizationProps = Omit<
  UseGetProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >,
  'path'
> &
  GetHarnessApprovalInstanceAuthorizationPathParams

/**
 * Gets a Harness Approval Instance authorization for the current user
 */
export const useGetHarnessApprovalInstanceAuthorization = ({
  approvalInstanceId,
  ...props
}: UseGetHarnessApprovalInstanceAuthorizationProps) =>
  useGet<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >(
    (paramsInPath: GetHarnessApprovalInstanceAuthorizationPathParams) =>
      `/approvals/${paramsInPath.approvalInstanceId}/harness/authorization`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Gets a Harness Approval Instance authorization for the current user
 */
export const getHarnessApprovalInstanceAuthorizationPromise = (
  {
    approvalInstanceId,
    ...props
  }: GetUsingFetchProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  > & { approvalInstanceId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >(getConfig('pipeline/api'), `/approvals/${approvalInstanceId}/harness/authorization`, props, signal)

export interface GetBarriersExecutionInfoQueryParams {
  stageSetupId: string
  planExecutionId: string
}

export type GetBarriersExecutionInfoProps = Omit<
  GetProps<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers execution info list
 */
export const GetBarriersExecutionInfo = (props: GetBarriersExecutionInfoProps) => (
  <Get<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>
    path={`/barriers/executionInfo`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarriersExecutionInfoProps = Omit<
  UseGetProps<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers execution info list
 */
export const useGetBarriersExecutionInfo = (props: UseGetBarriersExecutionInfoProps) =>
  useGet<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>(
    `/barriers/executionInfo`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets barriers execution info list
 */
export const getBarriersExecutionInfoPromise = (
  props: GetUsingFetchProps<
    ResponseListBarrierExecutionInfo,
    Failure | Error,
    GetBarriersExecutionInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>(
    getConfig('pipeline/api'),
    `/barriers/executionInfo`,
    props,
    signal
  )

export interface GetBarrierInfoQueryParams {
  barrierSetupId: string
  planExecutionId: string
}

export type GetBarrierInfoProps = Omit<
  GetProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers info
 */
export const GetBarrierInfo = (props: GetBarrierInfoProps) => (
  <Get<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>
    path={`/barriers/info`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarrierInfoProps = Omit<
  UseGetProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers info
 */
export const useGetBarrierInfo = (props: UseGetBarrierInfoProps) =>
  useGet<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>(`/barriers/info`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets barriers info
 */
export const getBarrierInfoPromise = (
  props: GetUsingFetchProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>(
    getConfig('pipeline/api'),
    `/barriers/info`,
    props,
    signal
  )

export type GetBarriersSetupInfoListProps = Omit<
  MutateProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Gets barriers setup info list
 */
export const GetBarriersSetupInfoList = (props: GetBarriersSetupInfoListProps) => (
  <Mutate<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>
    verb="PUT"
    path={`/barriers/setupInfo`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarriersSetupInfoListProps = Omit<
  UseMutateProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Gets barriers setup info list
 */
export const useGetBarriersSetupInfoList = (props: UseGetBarriersSetupInfoListProps) =>
  useMutate<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>('PUT', `/barriers/setupInfo`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets barriers setup info list
 */
export const getBarriersSetupInfoListPromise = (
  props: MutateUsingFetchProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>(
    'PUT',
    getConfig('pipeline/api'),
    `/barriers/setupInfo`,
    props,
    signal
  )

export interface GetPipelineDashboardExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo: string
  startTime: number
  endTime: number
}

export type GetPipelineDashboardExecutionProps = Omit<
  GetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline dashboard Execution
 */
export const GetPipelineDashboardExecution = (props: GetPipelineDashboardExecutionProps) => (
  <Get<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>
    path={`/dashboard/pipelineExecution`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineDashboardExecutionProps = Omit<
  UseGetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline dashboard Execution
 */
export const useGetPipelineDashboardExecution = (props: UseGetPipelineDashboardExecutionProps) =>
  useGet<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>(
    `/dashboard/pipelineExecution`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline dashboard Execution
 */
export const getPipelineDashboardExecutionPromise = (
  props: GetUsingFetchProps<
    ResponseDashboardPipelineExecutionInfo,
    Failure | Error,
    GetPipelineDashboardExecutionQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDashboardPipelineExecutionInfo,
    Failure | Error,
    GetPipelineDashboardExecutionQueryParams,
    void
  >(getConfig('pipeline/api'), `/dashboard/pipelineExecution`, props, signal)

export interface FetchPipelineHealthQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo: string
  startTime: number
  endTime: number
}

export type FetchPipelineHealthProps = Omit<
  GetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const FetchPipelineHealth = (props: FetchPipelineHealthProps) => (
  <Get<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>
    path={`/dashboard/pipelineHealth`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseFetchPipelineHealthProps = Omit<
  UseGetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const useFetchPipelineHealth = (props: UseFetchPipelineHealthProps) =>
  useGet<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>(
    `/dashboard/pipelineHealth`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline health
 */
export const fetchPipelineHealthPromise = (
  props: GetUsingFetchProps<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>(
    getConfig('pipeline/api'),
    `/dashboard/pipelineHealth`,
    props,
    signal
  )

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path={`/filters/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('pipeline/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export type GetPMSHealthStatusProps = Omit<GetProps<RestResponseString, unknown, void, void>, 'path'>

/**
 * get health for PMS service
 */
export const GetPMSHealthStatus = (props: GetPMSHealthStatusProps) => (
  <Get<RestResponseString, unknown, void, void> path={`/health`} base={getConfig('pipeline/api')} {...props} />
)

export type UseGetPMSHealthStatusProps = Omit<UseGetProps<RestResponseString, unknown, void, void>, 'path'>

/**
 * get health for PMS service
 */
export const useGetPMSHealthStatus = (props: UseGetPMSHealthStatusProps) =>
  useGet<RestResponseString, unknown, void, void>(`/health`, { base: getConfig('pipeline/api'), ...props })

/**
 * get health for PMS service
 */
export const getPMSHealthStatusPromise = (
  props: GetUsingFetchProps<RestResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<RestResponseString, unknown, void, void>(getConfig('pipeline/api'), `/health`, props, signal)

export interface GetInputSetsListForPipelineQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  inputSetType?: 'ALL' | 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  searchTerm?: string
  sortOrders?: string[]
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetInputSetsListForPipelineProps = Omit<
  GetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const GetInputSetsListForPipeline = (props: GetInputSetsListForPipelineProps) => (
  <Get<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>
    path={`/inputSets`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetsListForPipelineProps = Omit<
  UseGetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const useGetInputSetsListForPipeline = (props: UseGetInputSetsListForPipelineProps) =>
  useGet<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    `/inputSets`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets InputSets list for a pipeline
 */
export const getInputSetsListForPipelinePromise = (
  props: GetUsingFetchProps<
    ResponsePageInputSetSummaryResponse,
    Failure | Error,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    getConfig('pipeline/api'),
    `/inputSets`,
    props,
    signal
  )

export interface CreateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
}

export type CreateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const CreateInputSetForPipeline = (props: CreateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const useCreateInputSetForPipeline = (props: UseCreateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', `/inputSets`, { base: getConfig('pipeline/api'), ...props })

/**
 * Create an InputSet For Pipeline
 */
export const createInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets`, props, signal)

export interface GetMergeInputSetFromPipelineTemplateWithListInputQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given Input Sets list on pipeline and return Input Set template format of applied pipeline
 */
export const GetMergeInputSetFromPipelineTemplateWithListInput = (
  props: GetMergeInputSetFromPipelineTemplateWithListInputProps
) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets/merge`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given Input Sets list on pipeline and return Input Set template format of applied pipeline
 */
export const useGetMergeInputSetFromPipelineTemplateWithListInput = (
  props: UseGetMergeInputSetFromPipelineTemplateWithListInputProps
) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', `/inputSets/merge`, { base: getConfig('pipeline/api'), ...props })

/**
 * Merges given Input Sets list on pipeline and return Input Set template format of applied pipeline
 */
export const getMergeInputSetFromPipelineTemplateWithListInputPromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/merge`, props, signal)

export interface GetMergeInputSetFromPipelineTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetMergeInputSetFromPipelineTemplateProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given runtime input YAML on pipeline and return Input Set template format of applied pipeline
 */
export const GetMergeInputSetFromPipelineTemplate = (props: GetMergeInputSetFromPipelineTemplateProps) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >
    verb="POST"
    path={`/inputSets/mergeWithTemplateYaml`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetMergeInputSetFromPipelineTemplateProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given runtime input YAML on pipeline and return Input Set template format of applied pipeline
 */
export const useGetMergeInputSetFromPipelineTemplate = (props: UseGetMergeInputSetFromPipelineTemplateProps) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >('POST', `/inputSets/mergeWithTemplateYaml`, { base: getConfig('pipeline/api'), ...props })

/**
 * Merges given runtime input YAML on pipeline and return Input Set template format of applied pipeline
 */
export const getMergeInputSetFromPipelineTemplatePromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/mergeWithTemplateYaml`, props, signal)

export interface CreateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
}

export type CreateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const CreateOverlayInputSetForPipeline = (props: CreateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets/overlay`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const useCreateOverlayInputSetForPipeline = (props: UseCreateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', `/inputSets/overlay`, { base: getConfig('pipeline/api'), ...props })

/**
 * Create an Overlay InputSet For Pipeline
 */
export const createOverlayInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/overlay`, props, signal)

export interface GetOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface GetOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetOverlayInputSetForPipelineProps = Omit<
  GetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const GetOverlayInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetOverlayInputSetForPipelineProps) => (
  <Get<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >
    path={`/inputSets/overlay/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetOverlayInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const useGetOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseGetOverlayInputSetForPipelineProps) =>
  useGet<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(
    (paramsInPath: GetOverlayInputSetForPipelinePathParams) => `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Gets an Overlay InputSet by identifier
 */
export const getOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(getConfig('pipeline/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface UpdateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
}

export interface UpdateOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const UpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UpdateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >
    verb="PUT"
    path={`/inputSets/overlay/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const useUpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseUpdateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >(
    'PUT',
    (paramsInPath: UpdateOverlayInputSetForPipelinePathParams) =>
      `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Update an Overlay InputSet by identifier
 */
export const updateOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface GetTemplateFromPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetTemplateFromPipelineProps = Omit<
  MutateProps<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get template from a pipeline YAML
 */
export const GetTemplateFromPipeline = (props: GetTemplateFromPipelineProps) => (
  <Mutate<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >
    verb="POST"
    path={`/inputSets/template`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTemplateFromPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get template from a pipeline YAML
 */
export const useGetTemplateFromPipeline = (props: UseGetTemplateFromPipelineProps) =>
  useMutate<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >('POST', `/inputSets/template`, { base: getConfig('pipeline/api'), ...props })

/**
 * Get template from a pipeline YAML
 */
export const getTemplateFromPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/template`, props, signal)

export interface DeleteInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
}

export type DeleteInputSetForPipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an InputSet by identifier
 */
export const DeleteInputSetForPipeline = (props: DeleteInputSetForPipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>
    verb="DELETE"
    path={`/inputSets`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteInputSetForPipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an InputSet by identifier
 */
export const useDeleteInputSetForPipeline = (props: UseDeleteInputSetForPipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    `/inputSets`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Delete an InputSet by identifier
 */
export const deleteInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/inputSets`,
    props,
    signal
  )

export interface GetInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface GetInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetInputSetForPipelineProps = Omit<
  GetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const GetInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetInputSetForPipelineProps) => (
  <Get<ResponseInputSetResponse, Failure | Error, GetInputSetForPipelineQueryParams, GetInputSetForPipelinePathParams>
    path={`/inputSets/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const useGetInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseGetInputSetForPipelineProps) =>
  useGet<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >((paramsInPath: GetInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Gets an InputSet by identifier
 */
export const getInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >(getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface UpdateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
}

export interface UpdateInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const UpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UpdateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >
    verb="PUT"
    path={`/inputSets/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const useUpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseUpdateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', (paramsInPath: UpdateInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Update an InputSet by identifier
 */
export const updateInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface SanitiseInputSetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
}

export interface SanitiseInputSetPathParams {
  inputSetIdentifier: string
}

export type SanitiseInputSetProps = Omit<
  MutateProps<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    SanitiseInputSetPathParams
  >,
  'path' | 'verb'
> &
  SanitiseInputSetPathParams

/**
 * Sanitise an InputSet
 */
export const SanitiseInputSet = ({ inputSetIdentifier, ...props }: SanitiseInputSetProps) => (
  <Mutate<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    SanitiseInputSetPathParams
  >
    verb="POST"
    path={`/inputSets/${inputSetIdentifier}/sanitise`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseSanitiseInputSetProps = Omit<
  UseMutateProps<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    SanitiseInputSetPathParams
  >,
  'path' | 'verb'
> &
  SanitiseInputSetPathParams

/**
 * Sanitise an InputSet
 */
export const useSanitiseInputSet = ({ inputSetIdentifier, ...props }: UseSanitiseInputSetProps) =>
  useMutate<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    SanitiseInputSetPathParams
  >('POST', (paramsInPath: SanitiseInputSetPathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}/sanitise`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Sanitise an InputSet
 */
export const sanitiseInputSetPromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    SanitiseInputSetPathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    SanitiseInputSetPathParams
  >('POST', getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}/sanitise`, props, signal)

export interface GetPipelinesCountQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetPipelinesCountProps = Omit<
  MutateProps<ResponsePipelinesCount, Failure | Error, GetPipelinesCountQueryParams, LandingDashboardRequestPMS, void>,
  'path' | 'verb'
>

/**
 * Get pipelines count
 */
export const GetPipelinesCount = (props: GetPipelinesCountProps) => (
  <Mutate<ResponsePipelinesCount, Failure | Error, GetPipelinesCountQueryParams, LandingDashboardRequestPMS, void>
    verb="POST"
    path={`/landingDashboards/pipelinesCount`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelinesCountProps = Omit<
  UseMutateProps<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMS,
    void
  >,
  'path' | 'verb'
>

/**
 * Get pipelines count
 */
export const useGetPipelinesCount = (props: UseGetPipelinesCountProps) =>
  useMutate<ResponsePipelinesCount, Failure | Error, GetPipelinesCountQueryParams, LandingDashboardRequestPMS, void>(
    'POST',
    `/landingDashboards/pipelinesCount`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipelines count
 */
export const getPipelinesCountPromise = (
  props: MutateUsingFetchProps<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMS,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMS,
    void
  >('POST', getConfig('pipeline/api'), `/landingDashboards/pipelinesCount`, props, signal)

export interface GetPipelineOpaContextQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  opaAction: string
}

export type GetPipelineOpaContextProps = Omit<
  MutateProps<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * get pipeline opa context
 */
export const GetPipelineOpaContext = (props: GetPipelineOpaContextProps) => (
  <Mutate<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>
    verb="POST"
    path={`/opa/getPipelineOpaContext`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineOpaContextProps = Omit<
  UseMutateProps<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * get pipeline opa context
 */
export const useGetPipelineOpaContext = (props: UseGetPipelineOpaContextProps) =>
  useMutate<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>(
    'POST',
    `/opa/getPipelineOpaContext`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * get pipeline opa context
 */
export const getPipelineOpaContextPromise = (
  props: MutateUsingFetchProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/opa/getPipelineOpaContext`,
    props,
    signal
  )

export interface GetPipelineOpaContextFromEvaluationQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  opaAction: string
}

export interface GetPipelineOpaContextFromEvaluationPathParams {
  planExecutionId: string
}

export type GetPipelineOpaContextFromEvaluationProps = Omit<
  GetProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >,
  'path'
> &
  GetPipelineOpaContextFromEvaluationPathParams

/**
 * get pipeline opa context from evaluation
 */
export const GetPipelineOpaContextFromEvaluation = ({
  planExecutionId,
  ...props
}: GetPipelineOpaContextFromEvaluationProps) => (
  <Get<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >
    path={`/opa/getPipelineOpaContextFromEvaluation/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineOpaContextFromEvaluationProps = Omit<
  UseGetProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >,
  'path'
> &
  GetPipelineOpaContextFromEvaluationPathParams

/**
 * get pipeline opa context from evaluation
 */
export const useGetPipelineOpaContextFromEvaluation = ({
  planExecutionId,
  ...props
}: UseGetPipelineOpaContextFromEvaluationProps) =>
  useGet<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >(
    (paramsInPath: GetPipelineOpaContextFromEvaluationPathParams) =>
      `/opa/getPipelineOpaContextFromEvaluation/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * get pipeline opa context from evaluation
 */
export const getPipelineOpaContextFromEvaluationPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >(getConfig('pipeline/api'), `/opa/getPipelineOpaContextFromEvaluation/${planExecutionId}`, props, signal)

export interface GetPreflightCheckResponseQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  preflightCheckId: string
}

export type GetPreflightCheckResponseProps = Omit<
  GetProps<ResponsePreFlightDTO, Failure | Error, GetPreflightCheckResponseQueryParams, void>,
  'path'
>

/**
 * get preflight check response
 */
export const GetPreflightCheckResponse = (props: GetPreflightCheckResponseProps) => (
  <Get<ResponsePreFlightDTO, Failure | Error, GetPreflightCheckResponseQueryParams, void>
    path={`/pipeline/execute/getPreflightCheckResponse`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPreflightCheckResponseProps = Omit<
  UseGetProps<ResponsePreFlightDTO, Failure | Error, GetPreflightCheckResponseQueryParams, void>,
  'path'
>

/**
 * get preflight check response
 */
export const useGetPreflightCheckResponse = (props: UseGetPreflightCheckResponseProps) =>
  useGet<ResponsePreFlightDTO, Failure | Error, GetPreflightCheckResponseQueryParams, void>(
    `/pipeline/execute/getPreflightCheckResponse`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * get preflight check response
 */
export const getPreflightCheckResponsePromise = (
  props: GetUsingFetchProps<ResponsePreFlightDTO, Failure | Error, GetPreflightCheckResponseQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePreFlightDTO, Failure | Error, GetPreflightCheckResponseQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipeline/execute/getPreflightCheckResponse`,
    props,
    signal
  )

export interface HandleInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType:
    | 'AbortAll'
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'ExpireAll'
    | 'Retry'
}

export interface HandleInterruptPathParams {
  planExecutionId: string
}

export type HandleInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const HandleInterrupt = ({ planExecutionId, ...props }: HandleInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >
    verb="PUT"
    path={`/pipeline/execute/interrupt/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const useHandleInterrupt = ({ planExecutionId, ...props }: UseHandleInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', (paramsInPath: HandleInterruptPathParams) => `/pipeline/execute/interrupt/${paramsInPath.planExecutionId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * pause, resume or stop the pipeline executions
 */
export const handleInterruptPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', getConfig('pipeline/api'), `/pipeline/execute/interrupt/${planExecutionId}`, props, signal)

export interface HandleStageInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType:
    | 'AbortAll'
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'ExpireAll'
    | 'Retry'
}

export interface HandleStageInterruptPathParams {
  planExecutionId: string
  nodeExecutionId: string
}

export type HandleStageInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleStageInterruptPathParams

/**
 * pause, resume or stop the stage executions
 */
export const HandleStageInterrupt = ({ planExecutionId, nodeExecutionId, ...props }: HandleStageInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >
    verb="PUT"
    path={`/pipeline/execute/interrupt/${planExecutionId}/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleStageInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleStageInterruptPathParams

/**
 * pause, resume or stop the stage executions
 */
export const useHandleStageInterrupt = ({ planExecutionId, nodeExecutionId, ...props }: UseHandleStageInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >(
    'PUT',
    (paramsInPath: HandleStageInterruptPathParams) =>
      `/pipeline/execute/interrupt/${paramsInPath.planExecutionId}/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId, nodeExecutionId }, ...props }
  )

/**
 * pause, resume or stop the stage executions
 */
export const handleStageInterruptPromise = (
  {
    planExecutionId,
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  > & { planExecutionId: string; nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >(
    'PUT',
    getConfig('pipeline/api'),
    `/pipeline/execute/interrupt/${planExecutionId}/${nodeExecutionId}`,
    props,
    signal
  )

export interface LatestExecutionIdQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface LatestExecutionIdPathParams {
  planExecutionId: string
}

export type LatestExecutionIdProps = Omit<
  GetProps<
    ResponseRetryLatestExecutionResponseDto,
    Failure | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >,
  'path'
> &
  LatestExecutionIdPathParams

/**
 * Latest ExecutionId from Retry Executions
 */
export const LatestExecutionId = ({ planExecutionId, ...props }: LatestExecutionIdProps) => (
  <Get<
    ResponseRetryLatestExecutionResponseDto,
    Failure | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >
    path={`/pipeline/execute/latestExecutionId/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseLatestExecutionIdProps = Omit<
  UseGetProps<
    ResponseRetryLatestExecutionResponseDto,
    Failure | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >,
  'path'
> &
  LatestExecutionIdPathParams

/**
 * Latest ExecutionId from Retry Executions
 */
export const useLatestExecutionId = ({ planExecutionId, ...props }: UseLatestExecutionIdProps) =>
  useGet<
    ResponseRetryLatestExecutionResponseDto,
    Failure | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >(
    (paramsInPath: LatestExecutionIdPathParams) =>
      `/pipeline/execute/latestExecutionId/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Latest ExecutionId from Retry Executions
 */
export const latestExecutionIdPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseRetryLatestExecutionResponseDto,
    Failure | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseRetryLatestExecutionResponseDto,
    Failure | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >(getConfig('pipeline/api'), `/pipeline/execute/latestExecutionId/${planExecutionId}`, props, signal)

export interface HandleManualInterventionInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType:
    | 'AbortAll'
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'ExpireAll'
    | 'Retry'
}

export interface HandleManualInterventionInterruptPathParams {
  planExecutionId: string
  nodeExecutionId: string
}

export type HandleManualInterventionInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleManualInterventionInterruptPathParams

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const HandleManualInterventionInterrupt = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: HandleManualInterventionInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >
    verb="PUT"
    path={`/pipeline/execute/manualIntervention/interrupt/${planExecutionId}/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleManualInterventionInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleManualInterventionInterruptPathParams

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const useHandleManualInterventionInterrupt = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: UseHandleManualInterventionInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >(
    'PUT',
    (paramsInPath: HandleManualInterventionInterruptPathParams) =>
      `/pipeline/execute/manualIntervention/interrupt/${paramsInPath.planExecutionId}/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId, nodeExecutionId }, ...props }
  )

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const handleManualInterventionInterruptPromise = (
  {
    planExecutionId,
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  > & { planExecutionId: string; nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >(
    'PUT',
    getConfig('pipeline/api'),
    `/pipeline/execute/manualIntervention/interrupt/${planExecutionId}/${nodeExecutionId}`,
    props,
    signal
  )

export interface StartPreflightCheckQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type StartPreflightCheckProps = Omit<
  MutateProps<ResponseString, Failure | Error, StartPreflightCheckQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * initiate pre flight check
 */
export const StartPreflightCheck = (props: StartPreflightCheckProps) => (
  <Mutate<ResponseString, Failure | Error, StartPreflightCheckQueryParams, void, void>
    verb="POST"
    path={`/pipeline/execute/preflightCheck`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseStartPreflightCheckProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, StartPreflightCheckQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * initiate pre flight check
 */
export const useStartPreflightCheck = (props: UseStartPreflightCheckProps) =>
  useMutate<ResponseString, Failure | Error, StartPreflightCheckQueryParams, void, void>(
    'POST',
    `/pipeline/execute/preflightCheck`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * initiate pre flight check
 */
export const startPreflightCheckPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, StartPreflightCheckQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, StartPreflightCheckQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipeline/execute/preflightCheck`,
    props,
    signal
  )

export interface RePostPipelineExecuteWithInputSetYamlV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface RePostPipelineExecuteWithInputSetYamlV2PathParams {
  originalExecutionId: string
  identifier: string
}

export type RePostPipelineExecuteWithInputSetYamlV2Props = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlV2PathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const RePostPipelineExecuteWithInputSetYamlV2 = ({
  originalExecutionId,
  identifier,
  ...props
}: RePostPipelineExecuteWithInputSetYamlV2Props) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/v2/${originalExecutionId}/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRePostPipelineExecuteWithInputSetYamlV2Props = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlV2PathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const useRePostPipelineExecuteWithInputSetYamlV2 = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRePostPipelineExecuteWithInputSetYamlV2Props) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >(
    'POST',
    (paramsInPath: RePostPipelineExecuteWithInputSetYamlV2PathParams) =>
      `/pipeline/execute/rerun/v2/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const rePostPipelineExecuteWithInputSetYamlV2Promise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/rerun/v2/${originalExecutionId}/${identifier}`, props, signal)

export interface RePostPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface RePostPipelineExecuteWithInputSetYamlPathParams {
  originalExecutionId: string
  identifier: string
}

export type RePostPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlPathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml
 */
export const RePostPipelineExecuteWithInputSetYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: RePostPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/${originalExecutionId}/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRePostPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlPathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml
 */
export const useRePostPipelineExecuteWithInputSetYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRePostPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: RePostPipelineExecuteWithInputSetYamlPathParams) =>
      `/pipeline/execute/rerun/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Re Execute a pipeline with inputSet pipeline yaml
 */
export const rePostPipelineExecuteWithInputSetYamlPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/rerun/${originalExecutionId}/${identifier}`, props, signal)

export interface RePostPipelineExecuteWithInputSetListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface RePostPipelineExecuteWithInputSetListPathParams {
  originalExecutionId: string
  identifier: string
}

export type RePostPipelineExecuteWithInputSetListProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const RePostPipelineExecuteWithInputSetList = ({
  originalExecutionId,
  identifier,
  ...props
}: RePostPipelineExecuteWithInputSetListProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/${originalExecutionId}/${identifier}/inputSetList`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRePostPipelineExecuteWithInputSetListProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const useRePostPipelineExecuteWithInputSetList = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRePostPipelineExecuteWithInputSetListProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    (paramsInPath: RePostPipelineExecuteWithInputSetListPathParams) =>
      `/pipeline/execute/rerun/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}/inputSetList`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Execute a pipeline with input set references list
 */
export const rePostPipelineExecuteWithInputSetListPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    getConfig('pipeline/api'),
    `/pipeline/execute/rerun/${originalExecutionId}/${identifier}/inputSetList`,
    props,
    signal
  )

export interface RerunStagesWithRuntimeInputYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface RerunStagesWithRuntimeInputYamlPathParams {
  originalExecutionId: string
  identifier: string
}

export type RerunStagesWithRuntimeInputYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RerunStagesWithRuntimeInputYamlPathParams

/**
 * Rerun a pipeline with inputSet pipeline yaml
 */
export const RerunStagesWithRuntimeInputYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: RerunStagesWithRuntimeInputYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/${originalExecutionId}/${identifier}/stages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRerunStagesWithRuntimeInputYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RerunStagesWithRuntimeInputYamlPathParams

/**
 * Rerun a pipeline with inputSet pipeline yaml
 */
export const useRerunStagesWithRuntimeInputYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRerunStagesWithRuntimeInputYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    (paramsInPath: RerunStagesWithRuntimeInputYamlPathParams) =>
      `/pipeline/execute/rerun/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}/stages`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Rerun a pipeline with inputSet pipeline yaml
 */
export const rerunStagesWithRuntimeInputYamlPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    getConfig('pipeline/api'),
    `/pipeline/execute/rerun/${originalExecutionId}/${identifier}/stages`,
    props,
    signal
  )

export interface RetryPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  planExecutionId: string
  retryStages: string[]
  runAllStages?: boolean
}

export interface RetryPipelinePathParams {
  identifier: string
}

export type RetryPipelineProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >,
  'path' | 'verb'
> &
  RetryPipelinePathParams

/**
 * Retry a executed pipeline with inputSet pipeline yaml
 */
export const RetryPipeline = ({ identifier, ...props }: RetryPipelineProps) => (
  <Mutate<ResponsePlanExecutionResponseDto, Failure | Error, RetryPipelineQueryParams, void, RetryPipelinePathParams>
    verb="POST"
    path={`/pipeline/execute/retry/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRetryPipelineProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >,
  'path' | 'verb'
> &
  RetryPipelinePathParams

/**
 * Retry a executed pipeline with inputSet pipeline yaml
 */
export const useRetryPipeline = ({ identifier, ...props }: UseRetryPipelineProps) =>
  useMutate<ResponsePlanExecutionResponseDto, Failure | Error, RetryPipelineQueryParams, void, RetryPipelinePathParams>(
    'POST',
    (paramsInPath: RetryPipelinePathParams) => `/pipeline/execute/retry/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Retry a executed pipeline with inputSet pipeline yaml
 */
export const retryPipelinePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/retry/${identifier}`, props, signal)

export interface RetryHistoryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface RetryHistoryPathParams {
  planExecutionId: string
}

export type RetryHistoryProps = Omit<
  GetProps<ResponseRetryHistoryResponseDto, Failure | Error, RetryHistoryQueryParams, RetryHistoryPathParams>,
  'path'
> &
  RetryHistoryPathParams

/**
 * Retry History for a given execution
 */
export const RetryHistory = ({ planExecutionId, ...props }: RetryHistoryProps) => (
  <Get<ResponseRetryHistoryResponseDto, Failure | Error, RetryHistoryQueryParams, RetryHistoryPathParams>
    path={`/pipeline/execute/retryHistory/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRetryHistoryProps = Omit<
  UseGetProps<ResponseRetryHistoryResponseDto, Failure | Error, RetryHistoryQueryParams, RetryHistoryPathParams>,
  'path'
> &
  RetryHistoryPathParams

/**
 * Retry History for a given execution
 */
export const useRetryHistory = ({ planExecutionId, ...props }: UseRetryHistoryProps) =>
  useGet<ResponseRetryHistoryResponseDto, Failure | Error, RetryHistoryQueryParams, RetryHistoryPathParams>(
    (paramsInPath: RetryHistoryPathParams) => `/pipeline/execute/retryHistory/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Retry History for a given execution
 */
export const retryHistoryPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseRetryHistoryResponseDto,
    Failure | Error,
    RetryHistoryQueryParams,
    RetryHistoryPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseRetryHistoryResponseDto, Failure | Error, RetryHistoryQueryParams, RetryHistoryPathParams>(
    getConfig('pipeline/api'),
    `/pipeline/execute/retryHistory/${planExecutionId}`,
    props,
    signal
  )

export interface GetStagesExecutionListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetStagesExecutionListProps = Omit<
  GetProps<ResponseListStageExecutionResponse, Failure | Error, GetStagesExecutionListQueryParams, void>,
  'path'
>

/**
 * get list of stages for stage execution
 */
export const GetStagesExecutionList = (props: GetStagesExecutionListProps) => (
  <Get<ResponseListStageExecutionResponse, Failure | Error, GetStagesExecutionListQueryParams, void>
    path={`/pipeline/execute/stagesExecutionList`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetStagesExecutionListProps = Omit<
  UseGetProps<ResponseListStageExecutionResponse, Failure | Error, GetStagesExecutionListQueryParams, void>,
  'path'
>

/**
 * get list of stages for stage execution
 */
export const useGetStagesExecutionList = (props: UseGetStagesExecutionListProps) =>
  useGet<ResponseListStageExecutionResponse, Failure | Error, GetStagesExecutionListQueryParams, void>(
    `/pipeline/execute/stagesExecutionList`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * get list of stages for stage execution
 */
export const getStagesExecutionListPromise = (
  props: GetUsingFetchProps<
    ResponseListStageExecutionResponse,
    Failure | Error,
    GetStagesExecutionListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListStageExecutionResponse, Failure | Error, GetStagesExecutionListQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipeline/execute/stagesExecutionList`,
    props,
    signal
  )

export interface PostPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetYamlPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline YAML
 */
export const PostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline YAML
 */
export const usePostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetYamlPathParams) => `/pipeline/execute/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline YAML
 */
export const postPipelineExecuteWithInputSetYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}`, props, signal)

export interface PostPipelineExecuteWithInputSetListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetListPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetListProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const PostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetListProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}/inputSetList`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetListProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const usePostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetListProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetListPathParams) =>
      `/pipeline/execute/${paramsInPath.identifier}/inputSetList`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with input set references list
 */
export const postPipelineExecuteWithInputSetListPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}/inputSetList`, props, signal)

export interface RunStagesWithRuntimeInputYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface RunStagesWithRuntimeInputYamlPathParams {
  identifier: string
}

export type RunStagesWithRuntimeInputYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RunStagesWithRuntimeInputYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const RunStagesWithRuntimeInputYaml = ({ identifier, ...props }: RunStagesWithRuntimeInputYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}/stages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRunStagesWithRuntimeInputYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RunStagesWithRuntimeInputYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const useRunStagesWithRuntimeInputYaml = ({ identifier, ...props }: UseRunStagesWithRuntimeInputYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    (paramsInPath: RunStagesWithRuntimeInputYamlPathParams) => `/pipeline/execute/${paramsInPath.identifier}/stages`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const runStagesWithRuntimeInputYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}/stages`, props, signal)

export interface PostPipelineExecuteWithInputSetYamlv2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetYamlv2PathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetYamlv2Props = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlv2PathParams

/**
 * Execute a pipeline with inputSet pipeline YAML V2
 */
export const PostPipelineExecuteWithInputSetYamlv2 = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetYamlv2Props) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}/v2`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetYamlv2Props = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlv2PathParams

/**
 * Execute a pipeline with inputSet pipeline YAML V2
 */
export const usePostPipelineExecuteWithInputSetYamlv2 = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetYamlv2Props) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetYamlv2PathParams) =>
      `/pipeline/execute/${paramsInPath.identifier}/v2`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline YAML V2
 */
export const postPipelineExecuteWithInputSetYamlv2Promise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}/v2`, props, signal)

export interface GetRetryStagesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface GetRetryStagesPathParams {
  planExecutionId: string
}

export type GetRetryStagesProps = Omit<
  GetProps<ResponseRetryInfo, Failure | Error, GetRetryStagesQueryParams, GetRetryStagesPathParams>,
  'path'
> &
  GetRetryStagesPathParams

/**
 * Get retry stages for failed pipeline
 */
export const GetRetryStages = ({ planExecutionId, ...props }: GetRetryStagesProps) => (
  <Get<ResponseRetryInfo, Failure | Error, GetRetryStagesQueryParams, GetRetryStagesPathParams>
    path={`/pipeline/execute/${planExecutionId}/retryStages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetRetryStagesProps = Omit<
  UseGetProps<ResponseRetryInfo, Failure | Error, GetRetryStagesQueryParams, GetRetryStagesPathParams>,
  'path'
> &
  GetRetryStagesPathParams

/**
 * Get retry stages for failed pipeline
 */
export const useGetRetryStages = ({ planExecutionId, ...props }: UseGetRetryStagesProps) =>
  useGet<ResponseRetryInfo, Failure | Error, GetRetryStagesQueryParams, GetRetryStagesPathParams>(
    (paramsInPath: GetRetryStagesPathParams) => `/pipeline/execute/${paramsInPath.planExecutionId}/retryStages`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Get retry stages for failed pipeline
 */
export const getRetryStagesPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<ResponseRetryInfo, Failure | Error, GetRetryStagesQueryParams, GetRetryStagesPathParams> & {
    planExecutionId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseRetryInfo, Failure | Error, GetRetryStagesQueryParams, GetRetryStagesPathParams>(
    getConfig('pipeline/api'),
    `/pipeline/execute/${planExecutionId}/retryStages`,
    props,
    signal
  )

export interface CreatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
}

export type CreatePipelineProps = Omit<
  MutateProps<
    ResponseString,
    Failure | Error,
    CreatePipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const CreatePipeline = (props: CreatePipelineProps) => (
  <Mutate<ResponseString, Failure | Error, CreatePipelineQueryParams, UpdateInputSetForPipelineBodyRequestBody, void>
    verb="POST"
    path={`/pipelines`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreatePipelineProps = Omit<
  UseMutateProps<
    ResponseString,
    Failure | Error,
    CreatePipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const useCreatePipeline = (props: UseCreatePipelineProps) =>
  useMutate<ResponseString, Failure | Error, CreatePipelineQueryParams, UpdateInputSetForPipelineBodyRequestBody, void>(
    'POST',
    `/pipelines`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create a Pipeline
 */
export const createPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    CreatePipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    CreatePipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines`, props, signal)

export type DummyPmsStepsApiProps = Omit<GetProps<ResponsePmsAbstractStepNode, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose pmsSteps
 */
export const DummyPmsStepsApi = (props: DummyPmsStepsApiProps) => (
  <Get<ResponsePmsAbstractStepNode, Failure | Error, void, void>
    path={`/pipelines/dummy-pmsSteps-api`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDummyPmsStepsApiProps = Omit<
  UseGetProps<ResponsePmsAbstractStepNode, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose pmsSteps
 */
export const useDummyPmsStepsApi = (props: UseDummyPmsStepsApiProps) =>
  useGet<ResponsePmsAbstractStepNode, Failure | Error, void, void>(`/pipelines/dummy-pmsSteps-api`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * This is dummy api to expose pmsSteps
 */
export const dummyPmsStepsApiPromise = (
  props: GetUsingFetchProps<ResponsePmsAbstractStepNode, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePmsAbstractStepNode, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/dummy-pmsSteps-api`,
    props,
    signal
  )

export type DummyTemplateStepApiProps = Omit<GetProps<ResponseTemplateStepNode, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose templateStepNode
 */
export const DummyTemplateStepApi = (props: DummyTemplateStepApiProps) => (
  <Get<ResponseTemplateStepNode, Failure | Error, void, void>
    path={`/pipelines/dummy-templateStep-api`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDummyTemplateStepApiProps = Omit<
  UseGetProps<ResponseTemplateStepNode, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose templateStepNode
 */
export const useDummyTemplateStepApi = (props: UseDummyTemplateStepApiProps) =>
  useGet<ResponseTemplateStepNode, Failure | Error, void, void>(`/pipelines/dummy-templateStep-api`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * This is dummy api to expose templateStepNode
 */
export const dummyTemplateStepApiPromise = (
  props: GetUsingFetchProps<ResponseTemplateStepNode, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTemplateStepNode, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/dummy-templateStep-api`,
    props,
    signal
  )

export interface GetListOfExecutionsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  searchTerm?: string
  pipelineIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
  filterIdentifier?: string
  module?: string
  status?: (
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  )[]
  myDeployments?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetListOfExecutionsProps = Omit<
  MutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list
 */
export const GetListOfExecutions = (props: GetListOfExecutionsProps) => (
  <Mutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/pipelines/execution/summary`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetListOfExecutionsProps = Omit<
  UseMutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list
 */
export const useGetListOfExecutions = (props: UseGetListOfExecutionsProps) =>
  useMutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', `/pipelines/execution/summary`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Executions list
 */
export const getListOfExecutionsPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/execution/summary`, props, signal)

export interface GetExecutionDetailV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageNodeId?: string
  renderFullBottomGraph?: boolean
}

export interface GetExecutionDetailV2PathParams {
  planExecutionId: string
}

export type GetExecutionDetailV2Props = Omit<
  GetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >,
  'path'
> &
  GetExecutionDetailV2PathParams

/**
 * Gets Execution Detail V2
 */
export const GetExecutionDetailV2 = ({ planExecutionId, ...props }: GetExecutionDetailV2Props) => (
  <Get<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >
    path={`/pipelines/execution/v2/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionDetailV2Props = Omit<
  UseGetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >,
  'path'
> &
  GetExecutionDetailV2PathParams

/**
 * Gets Execution Detail V2
 */
export const useGetExecutionDetailV2 = ({ planExecutionId, ...props }: UseGetExecutionDetailV2Props) =>
  useGet<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >((paramsInPath: GetExecutionDetailV2PathParams) => `/pipelines/execution/v2/${paramsInPath.planExecutionId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Gets Execution Detail V2
 */
export const getExecutionDetailV2Promise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/v2/${planExecutionId}`, props, signal)

export interface GetExecutionDetailQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageNodeId?: string
}

export interface GetExecutionDetailPathParams {
  planExecutionId: string
}

export type GetExecutionDetailProps = Omit<
  GetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >,
  'path'
> &
  GetExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const GetExecutionDetail = ({ planExecutionId, ...props }: GetExecutionDetailProps) => (
  <Get<ResponsePipelineExecutionDetail, Failure | Error, GetExecutionDetailQueryParams, GetExecutionDetailPathParams>
    path={`/pipelines/execution/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionDetailProps = Omit<
  UseGetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >,
  'path'
> &
  GetExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const useGetExecutionDetail = ({ planExecutionId, ...props }: UseGetExecutionDetailProps) =>
  useGet<ResponsePipelineExecutionDetail, Failure | Error, GetExecutionDetailQueryParams, GetExecutionDetailPathParams>(
    (paramsInPath: GetExecutionDetailPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets Execution Detail
 */
export const getExecutionDetailPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}`, props, signal)

export interface GetInputsetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  resolveExpressions?: boolean
}

export interface GetInputsetYamlPathParams {
  planExecutionId: string
}

export type GetInputsetYamlProps = Omit<
  GetProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>,
  'path'
> &
  GetInputsetYamlPathParams

/**
 * Gets  inputsetYaml
 */
export const GetInputsetYaml = ({ planExecutionId, ...props }: GetInputsetYamlProps) => (
  <Get<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>
    path={`/pipelines/execution/${planExecutionId}/inputset`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputsetYamlProps = Omit<
  UseGetProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>,
  'path'
> &
  GetInputsetYamlPathParams

/**
 * Gets  inputsetYaml
 */
export const useGetInputsetYaml = ({ planExecutionId, ...props }: UseGetInputsetYamlProps) =>
  useGet<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>(
    (paramsInPath: GetInputsetYamlPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/inputset`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets  inputsetYaml
 */
export const getInputsetYamlPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams> & {
    planExecutionId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>(
    getConfig('pipeline/api'),
    `/pipelines/execution/${planExecutionId}/inputset`,
    props,
    signal
  )

export interface GetInputsetYamlV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  resolveExpressions?: boolean
}

export interface GetInputsetYamlV2PathParams {
  planExecutionId: string
}

export type GetInputsetYamlV2Props = Omit<
  GetProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  >,
  'path'
> &
  GetInputsetYamlV2PathParams

/**
 * Gets  inputsetYaml
 */
export const GetInputsetYamlV2 = ({ planExecutionId, ...props }: GetInputsetYamlV2Props) => (
  <Get<ResponseInputSetTemplateResponse, Failure | Error, GetInputsetYamlV2QueryParams, GetInputsetYamlV2PathParams>
    path={`/pipelines/execution/${planExecutionId}/inputsetV2`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputsetYamlV2Props = Omit<
  UseGetProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  >,
  'path'
> &
  GetInputsetYamlV2PathParams

/**
 * Gets  inputsetYaml
 */
export const useGetInputsetYamlV2 = ({ planExecutionId, ...props }: UseGetInputsetYamlV2Props) =>
  useGet<ResponseInputSetTemplateResponse, Failure | Error, GetInputsetYamlV2QueryParams, GetInputsetYamlV2PathParams>(
    (paramsInPath: GetInputsetYamlV2PathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/inputsetV2`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets  inputsetYaml
 */
export const getInputsetYamlV2Promise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}/inputsetV2`, props, signal)

export interface GetExpandedPipelineJSONQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface GetExpandedPipelineJSONPathParams {
  pipelineIdentifier: string
}

export type GetExpandedPipelineJSONProps = Omit<
  GetProps<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >,
  'path'
> &
  GetExpandedPipelineJSONPathParams

/**
 * Gets Pipeline JSON with extra info for some fields
 */
export const GetExpandedPipelineJSON = ({ pipelineIdentifier, ...props }: GetExpandedPipelineJSONProps) => (
  <Get<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >
    path={`/pipelines/expandedJSON/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExpandedPipelineJSONProps = Omit<
  UseGetProps<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >,
  'path'
> &
  GetExpandedPipelineJSONPathParams

/**
 * Gets Pipeline JSON with extra info for some fields
 */
export const useGetExpandedPipelineJSON = ({ pipelineIdentifier, ...props }: UseGetExpandedPipelineJSONProps) =>
  useGet<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >((paramsInPath: GetExpandedPipelineJSONPathParams) => `/pipelines/expandedJSON/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Gets Pipeline JSON with extra info for some fields
 */
export const getExpandedPipelineJSONPromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >(getConfig('pipeline/api'), `/pipelines/expandedJSON/${pipelineIdentifier}`, props, signal)

export interface RefreshFFCacheQueryParams {
  accountIdentifier: string
}

export type RefreshFFCacheProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, RefreshFFCacheQueryParams, void>,
  'path'
>

/**
 * Refresh the feature flag cache
 */
export const RefreshFFCache = (props: RefreshFFCacheProps) => (
  <Get<ResponseBoolean, Failure | Error, RefreshFFCacheQueryParams, void>
    path={`/pipelines/ffCache/refresh`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRefreshFFCacheProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, RefreshFFCacheQueryParams, void>,
  'path'
>

/**
 * Refresh the feature flag cache
 */
export const useRefreshFFCache = (props: UseRefreshFFCacheProps) =>
  useGet<ResponseBoolean, Failure | Error, RefreshFFCacheQueryParams, void>(`/pipelines/ffCache/refresh`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Refresh the feature flag cache
 */
export const refreshFFCachePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, RefreshFFCacheQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, RefreshFFCacheQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/ffCache/refresh`,
    props,
    signal
  )

export interface GetExecutionNodeQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  nodeExecutionId: string
}

export type GetExecutionNodeProps = Omit<
  GetProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  'path'
>

/**
 * get execution node
 */
export const GetExecutionNode = (props: GetExecutionNodeProps) => (
  <Get<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>
    path={`/pipelines/getExecutionNode`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionNodeProps = Omit<
  UseGetProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  'path'
>

/**
 * get execution node
 */
export const useGetExecutionNode = (props: UseGetExecutionNodeProps) =>
  useGet<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>(`/pipelines/getExecutionNode`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * get execution node
 */
export const getExecutionNodePromise = (
  props: GetUsingFetchProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/getExecutionNode`,
    props,
    signal
  )

export interface GetPipelineListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
  module?: string
  filterIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  getDistinctFromBranches?: boolean
}

export type GetPipelineListProps = Omit<
  MutateProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Pipeline list
 */
export const GetPipelineList = (props: GetPipelineListProps) => (
  <Mutate<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/pipelines/list`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineListProps = Omit<
  UseMutateProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Pipeline list
 */
export const useGetPipelineList = (props: UseGetPipelineListProps) =>
  useMutate<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', `/pipelines/list`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Pipeline list
 */
export const getPipelineListPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/list`, props, signal)

export type GetNotificationSchemaProps = Omit<GetProps<ResponseNotificationRules, Failure | Error, void, void>, 'path'>

/**
 * Get Notification Schema
 */
export const GetNotificationSchema = (props: GetNotificationSchemaProps) => (
  <Get<ResponseNotificationRules, Failure | Error, void, void>
    path={`/pipelines/notification`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetNotificationSchemaProps = Omit<
  UseGetProps<ResponseNotificationRules, Failure | Error, void, void>,
  'path'
>

/**
 * Get Notification Schema
 */
export const useGetNotificationSchema = (props: UseGetNotificationSchemaProps) =>
  useGet<ResponseNotificationRules, Failure | Error, void, void>(`/pipelines/notification`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Notification Schema
 */
export const getNotificationSchemaPromise = (
  props: GetUsingFetchProps<ResponseNotificationRules, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNotificationRules, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/notification`,
    props,
    signal
  )

export interface GetPipelineExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo: string
  startTime: number
  endTime: number
}

export type GetPipelineExecutionProps = Omit<
  GetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline execution
 */
export const GetPipelineExecution = (props: GetPipelineExecutionProps) => (
  <Get<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>
    path={`/pipelines/pipelineExecution`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineExecutionProps = Omit<
  UseGetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline execution
 */
export const useGetPipelineExecution = (props: UseGetPipelineExecutionProps) =>
  useGet<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>(
    `/pipelines/pipelineExecution`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline execution
 */
export const getPipelineExecutionPromise = (
  props: GetUsingFetchProps<
    ResponseDashboardPipelineExecutionInfo,
    Failure | Error,
    GetPipelineExecutionQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/pipelineExecution`,
    props,
    signal
  )

export interface GetPipelinedHealthQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo: string
  startTime: number
  endTime: number
}

export type GetPipelinedHealthProps = Omit<
  GetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const GetPipelinedHealth = (props: GetPipelinedHealthProps) => (
  <Get<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>
    path={`/pipelines/pipelineHealth`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelinedHealthProps = Omit<
  UseGetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const useGetPipelinedHealth = (props: UseGetPipelinedHealthProps) =>
  useGet<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>(
    `/pipelines/pipelineHealth`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline health
 */
export const getPipelinedHealthPromise = (
  props: GetUsingFetchProps<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/pipelineHealth`,
    props,
    signal
  )

export interface GetPipelineSummaryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface GetPipelineSummaryPathParams {
  pipelineIdentifier: string
}

export type GetPipelineSummaryProps = Omit<
  GetProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets Pipeline Summary of a pipeline
 */
export const GetPipelineSummary = ({ pipelineIdentifier, ...props }: GetPipelineSummaryProps) => (
  <Get<ResponsePMSPipelineSummaryResponse, Failure | Error, GetPipelineSummaryQueryParams, GetPipelineSummaryPathParams>
    path={`/pipelines/summary/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineSummaryProps = Omit<
  UseGetProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets Pipeline Summary of a pipeline
 */
export const useGetPipelineSummary = ({ pipelineIdentifier, ...props }: UseGetPipelineSummaryProps) =>
  useGet<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >((paramsInPath: GetPipelineSummaryPathParams) => `/pipelines/summary/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Gets Pipeline Summary of a pipeline
 */
export const getPipelineSummaryPromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >(getConfig('pipeline/api'), `/pipelines/summary/${pipelineIdentifier}`, props, signal)

export interface CreatePipelineV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
}

export type CreatePipelineV2Props = Omit<
  MutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const CreatePipelineV2 = (props: CreatePipelineV2Props) => (
  <Mutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >
    verb="POST"
    path={`/pipelines/v2`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreatePipelineV2Props = Omit<
  UseMutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const useCreatePipelineV2 = (props: UseCreatePipelineV2Props) =>
  useMutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', `/pipelines/v2`, { base: getConfig('pipeline/api'), ...props })

/**
 * Create a Pipeline
 */
export const createPipelineV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/v2`, props, signal)

export interface GetStepsV2QueryParams {
  accountId: string
}

export type GetStepsV2Props = Omit<
  MutateProps<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>,
  'path' | 'verb'
>

/**
 * Get Steps for given modules Version 2
 */
export const GetStepsV2 = (props: GetStepsV2Props) => (
  <Mutate<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>
    verb="POST"
    path={`/pipelines/v2/steps`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetStepsV2Props = Omit<
  UseMutateProps<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>,
  'path' | 'verb'
>

/**
 * Get Steps for given modules Version 2
 */
export const useGetStepsV2 = (props: UseGetStepsV2Props) =>
  useMutate<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>(
    'POST',
    `/pipelines/v2/steps`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get Steps for given modules Version 2
 */
export const getStepsV2Promise = (
  props: MutateUsingFetchProps<
    ResponseStepCategory,
    Failure | Error,
    GetStepsV2QueryParams,
    StepPalleteFilterWrapper,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/v2/steps`,
    props,
    signal
  )

export interface PutPipelineV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
}

export interface PutPipelineV2PathParams {
  pipelineIdentifier: string
}

export type PutPipelineV2Props = Omit<
  MutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelineV2PathParams
  >,
  'path' | 'verb'
> &
  PutPipelineV2PathParams

/**
 * Update a Pipeline
 */
export const PutPipelineV2 = ({ pipelineIdentifier, ...props }: PutPipelineV2Props) => (
  <Mutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelineV2PathParams
  >
    verb="PUT"
    path={`/pipelines/v2/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePutPipelineV2Props = Omit<
  UseMutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelineV2PathParams
  >,
  'path' | 'verb'
> &
  PutPipelineV2PathParams

/**
 * Update a Pipeline
 */
export const usePutPipelineV2 = ({ pipelineIdentifier, ...props }: UsePutPipelineV2Props) =>
  useMutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelineV2PathParams
  >('PUT', (paramsInPath: PutPipelineV2PathParams) => `/pipelines/v2/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Update a Pipeline
 */
export const putPipelineV2Promise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelineV2PathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelineV2PathParams
  >('PUT', getConfig('pipeline/api'), `/pipelines/v2/${pipelineIdentifier}`, props, signal)

export interface ValidatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
}

export type ValidatePipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Validate a Pipeline
 */
export const ValidatePipeline = (props: ValidatePipelineProps) => (
  <Mutate<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>
    verb="POST"
    path={`/pipelines/validate-pipeline-with-schema`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseValidatePipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Validate a Pipeline
 */
export const useValidatePipeline = (props: UseValidatePipelineProps) =>
  useMutate<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>(
    'POST',
    `/pipelines/validate-pipeline-with-schema`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Validate a Pipeline
 */
export const validatePipelinePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/validate-pipeline-with-schema`,
    props,
    signal
  )

export interface ValidatePipelineByYAMLQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidatePipelineByYAMLProps = Omit<
  MutateProps<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a Pipeline YAML
 */
export const ValidatePipelineByYAML = (props: ValidatePipelineByYAMLProps) => (
  <Mutate<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >
    verb="POST"
    path={`/pipelines/validate-yaml-with-schema`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseValidatePipelineByYAMLProps = Omit<
  UseMutateProps<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a Pipeline YAML
 */
export const useValidatePipelineByYAML = (props: UseValidatePipelineByYAMLProps) =>
  useMutate<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', `/pipelines/validate-yaml-with-schema`, { base: getConfig('pipeline/api'), ...props })

/**
 * Validate a Pipeline YAML
 */
export const validatePipelineByYAMLPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/validate-yaml-with-schema`, props, signal)

export interface CreateVariablesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type CreateVariablesProps = Omit<
  MutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const CreateVariables = (props: CreateVariablesProps) => (
  <Mutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>
    verb="POST"
    path={`/pipelines/variables`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateVariablesProps = Omit<
  UseMutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const useCreateVariables = (props: UseCreateVariablesProps) =>
  useMutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    `/pipelines/variables`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create variables for Pipeline
 */
export const createVariablesPromise = (
  props: MutateUsingFetchProps<
    ResponseVariableMergeServiceResponse,
    Failure | Error,
    CreateVariablesQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/variables`,
    props,
    signal
  )

export interface SoftDeletePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
}

export type SoftDeletePipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const SoftDeletePipeline = (props: SoftDeletePipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>
    verb="DELETE"
    path={`/pipelines`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseSoftDeletePipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const useSoftDeletePipeline = (props: UseSoftDeletePipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>('DELETE', `/pipelines`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a pipeline
 */
export const softDeletePipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/pipelines`,
    props,
    signal
  )

export interface GetPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  getTemplatesResolvedPipeline?: boolean
}

export interface GetPipelinePathParams {
  pipelineIdentifier: string
}

export type GetPipelineProps = Omit<
  GetProps<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipeline = ({ pipelineIdentifier, ...props }: GetPipelineProps) => (
  <Get<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>
    path={`/pipelines/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineProps = Omit<
  UseGetProps<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipeline = ({ pipelineIdentifier, ...props }: UseGetPipelineProps) =>
  useGet<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    (paramsInPath: GetPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Gets a pipeline by identifier
 */
export const getPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePMSPipelineResponseDTO,
    Failure | Error,
    GetPipelineQueryParams,
    GetPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    getConfig('pipeline/api'),
    `/pipelines/${pipelineIdentifier}`,
    props,
    signal
  )

export interface PutPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
}

export interface PutPipelinePathParams {
  pipelineIdentifier: string
}

export type PutPipelineProps = Omit<
  MutateProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelinePathParams
  >,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const PutPipeline = ({ pipelineIdentifier, ...props }: PutPipelineProps) => (
  <Mutate<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelinePathParams
  >
    verb="PUT"
    path={`/pipelines/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePutPipelineProps = Omit<
  UseMutateProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelinePathParams
  >,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const usePutPipeline = ({ pipelineIdentifier, ...props }: UsePutPipelineProps) =>
  useMutate<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelinePathParams
  >('PUT', (paramsInPath: PutPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Update a Pipeline
 */
export const putPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateInputSetForPipelineBodyRequestBody,
    PutPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/pipelines/${pipelineIdentifier}`, props, signal)

export interface GetResourceConstraintsExecutionInfoQueryParams {
  accountId: string
  resourceUnit: string
}

export type GetResourceConstraintsExecutionInfoProps = Omit<
  GetProps<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  'path'
>

/**
 * Gets resource constraints execution info
 */
export const GetResourceConstraintsExecutionInfo = (props: GetResourceConstraintsExecutionInfoProps) => (
  <Get<ResponseResourceConstraintExecutionInfo, Failure | Error, GetResourceConstraintsExecutionInfoQueryParams, void>
    path={`/resource-constraints/executionInfo`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetResourceConstraintsExecutionInfoProps = Omit<
  UseGetProps<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  'path'
>

/**
 * Gets resource constraints execution info
 */
export const useGetResourceConstraintsExecutionInfo = (props: UseGetResourceConstraintsExecutionInfoProps) =>
  useGet<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >(`/resource-constraints/executionInfo`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets resource constraints execution info
 */
export const getResourceConstraintsExecutionInfoPromise = (
  props: GetUsingFetchProps<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >(getConfig('pipeline/api'), `/resource-constraints/executionInfo`, props, signal)

export interface GetTriggerListForTargetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetTriggerListForTargetProps = Omit<
  GetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets paginated Triggers list for target
 */
export const GetTriggerListForTarget = (props: GetTriggerListForTargetProps) => (
  <Get<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>
    path={`/triggers`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerListForTargetProps = Omit<
  UseGetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets paginated Triggers list for target
 */
export const useGetTriggerListForTarget = (props: UseGetTriggerListForTargetProps) =>
  useGet<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(`/triggers`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets paginated Triggers list for target
 */
export const getTriggerListForTargetPromise = (
  props: GetUsingFetchProps<
    ResponsePageNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerListForTargetQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(
    getConfig('pipeline/api'),
    `/triggers`,
    props,
    signal
  )

export interface CreateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export type CreateTriggerProps = Omit<
  MutateProps<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigV2RequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const CreateTrigger = (props: CreateTriggerProps) => (
  <Mutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigV2RequestBody, void>
    verb="POST"
    path={`/triggers`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const useCreateTrigger = (props: UseCreateTriggerProps) =>
  useMutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigV2RequestBody, void>(
    'POST',
    `/triggers`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create Trigger
 */
export const createTriggerPromise = (
  props: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/triggers`, props, signal)

export type GenerateWebhookTokenProps = Omit<GetProps<RestResponseString, Failure | Error, void, void>, 'path'>

/**
 * Regenerate webhook token
 */
export const GenerateWebhookToken = (props: GenerateWebhookTokenProps) => (
  <Get<RestResponseString, Failure | Error, void, void>
    path={`/triggers/regenerateToken`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGenerateWebhookTokenProps = Omit<UseGetProps<RestResponseString, Failure | Error, void, void>, 'path'>

/**
 * Regenerate webhook token
 */
export const useGenerateWebhookToken = (props: UseGenerateWebhookTokenProps) =>
  useGet<RestResponseString, Failure | Error, void, void>(`/triggers/regenerateToken`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Regenerate webhook token
 */
export const generateWebhookTokenPromise = (
  props: GetUsingFetchProps<RestResponseString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseString, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/triggers/regenerateToken`,
    props,
    signal
  )

export interface DeleteTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export type DeleteTriggerProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const DeleteTrigger = (props: DeleteTriggerProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>
    verb="DELETE"
    path={`/triggers`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteTriggerProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const useDeleteTrigger = (props: UseDeleteTriggerProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>('DELETE', `/triggers`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a trigger by identifier
 */
export const deleteTriggerPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/triggers`,
    props,
    signal
  )

export interface GetTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerPathParams {
  triggerIdentifier: string
}

export type GetTriggerProps = Omit<
  GetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const GetTrigger = ({ triggerIdentifier, ...props }: GetTriggerProps) => (
  <Get<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>
    path={`/triggers/${triggerIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerProps = Omit<
  UseGetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const useGetTrigger = ({ triggerIdentifier, ...props }: UseGetTriggerProps) =>
  useGet<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    (paramsInPath: GetTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Gets a trigger by identifier
 */
export const getTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams> & {
    triggerIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    getConfig('pipeline/api'),
    `/triggers/${triggerIdentifier}`,
    props,
    signal
  )

export interface UpdateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface UpdateTriggerPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerProps = Omit<
  MutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const UpdateTrigger = ({ triggerIdentifier, ...props }: UpdateTriggerProps) => (
  <Mutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    UpdateTriggerPathParams
  >
    verb="PUT"
    path={`/triggers/${triggerIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const useUpdateTrigger = ({ triggerIdentifier, ...props }: UseUpdateTriggerProps) =>
  useMutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    UpdateTriggerPathParams
  >('PUT', (paramsInPath: UpdateTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { triggerIdentifier },
    ...props
  })

/**
 * Update a trigger by identifier
 */
export const updateTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    UpdateTriggerPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigV2RequestBody,
    UpdateTriggerPathParams
  >('PUT', getConfig('pipeline/api'), `/triggers/${triggerIdentifier}`, props, signal)

export interface GetTriggerDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerDetailsPathParams {
  triggerIdentifier: string
}

export type GetTriggerDetailsProps = Omit<
  GetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Fetches Trigger details for a specific pipeline and trigger identifier,
 */
export const GetTriggerDetails = ({ triggerIdentifier, ...props }: GetTriggerDetailsProps) => (
  <Get<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>
    path={`/triggers/${triggerIdentifier}/details`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerDetailsProps = Omit<
  UseGetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Fetches Trigger details for a specific pipeline and trigger identifier,
 */
export const useGetTriggerDetails = ({ triggerIdentifier, ...props }: UseGetTriggerDetailsProps) =>
  useGet<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>(
    (paramsInPath: GetTriggerDetailsPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/details`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Fetches Trigger details for a specific pipeline and trigger identifier,
 */
export const getTriggerDetailsPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >(getConfig('pipeline/api'), `/triggers/${triggerIdentifier}/details`, props, signal)

export interface UpdateTriggerStatusQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  status: boolean
}

export interface UpdateTriggerStatusPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerStatusProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const UpdateTriggerStatus = ({ triggerIdentifier, ...props }: UpdateTriggerStatusProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>
    verb="PUT"
    path={`/triggers/${triggerIdentifier}/status`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateTriggerStatusProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const useUpdateTriggerStatus = ({ triggerIdentifier, ...props }: UseUpdateTriggerStatusProps) =>
  useMutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>(
    'PUT',
    (paramsInPath: UpdateTriggerStatusPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/status`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Update a trigger's status by identifier
 */
export const updateTriggerStatusPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  >('PUT', getConfig('pipeline/api'), `/triggers/${triggerIdentifier}/status`, props, signal)

export interface GetActionsListQueryParams {
  sourceRepo: 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AWS_CODECOMMIT' | 'CUSTOM'
  event: string
}

export type GetActionsListProps = Omit<
  GetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const GetActionsList = (props: GetActionsListProps) => (
  <Get<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>
    path={`/webhook/actions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetActionsListProps = Omit<
  UseGetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const useGetActionsList = (props: UseGetActionsListProps) =>
  useGet<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(`/webhook/actions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Actions for event type and source
 */
export const getActionsListPromise = (
  props: GetUsingFetchProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(
    getConfig('pipeline/api'),
    `/webhook/actions`,
    props,
    signal
  )

export type GetBitbucketPRActionsProps = Omit<
  GetProps<ResponseListBitbucketPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetBitbucketPRActions = (props: GetBitbucketPRActionsProps) => (
  <Get<ResponseListBitbucketPRAction, Failure | Error, void, void>
    path={`/webhook/bitbucketPRActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBitbucketPRActionsProps = Omit<
  UseGetProps<ResponseListBitbucketPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetBitbucketPRActions = (props: UseGetBitbucketPRActionsProps) =>
  useGet<ResponseListBitbucketPRAction, Failure | Error, void, void>(`/webhook/bitbucketPRActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getBitbucketPRActionsPromise = (
  props: GetUsingFetchProps<ResponseListBitbucketPRAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBitbucketPRAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/bitbucketPRActions`,
    props,
    signal
  )

export type GetBitbucketTriggerEventsProps = Omit<
  GetProps<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetBitbucketTriggerEvents = (props: GetBitbucketTriggerEventsProps) => (
  <Get<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>
    path={`/webhook/bitbucketTriggerEvents`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBitbucketTriggerEventsProps = Omit<
  UseGetProps<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetBitbucketTriggerEvents = (props: UseGetBitbucketTriggerEventsProps) =>
  useGet<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>(`/webhook/bitbucketTriggerEvents`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getBitbucketTriggerEventsPromise = (
  props: GetUsingFetchProps<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/bitbucketTriggerEvents`,
    props,
    signal
  )

export interface CustomWebhookEndpointQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  triggerIdentifier?: string
}

export type CustomWebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, CustomWebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept custom webhook event
 */
export const CustomWebhookEndpoint = (props: CustomWebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, CustomWebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>
    verb="POST"
    path={`/webhook/custom`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCustomWebhookEndpointProps = Omit<
  UseMutateProps<
    ResponseString,
    Failure | Error,
    CustomWebhookEndpointQueryParams,
    WebhookEndpointBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * accept custom webhook event
 */
export const useCustomWebhookEndpoint = (props: UseCustomWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, CustomWebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>(
    'POST',
    `/webhook/custom`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * accept custom webhook event
 */
export const customWebhookEndpointPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    CustomWebhookEndpointQueryParams,
    WebhookEndpointBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    CustomWebhookEndpointQueryParams,
    WebhookEndpointBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/webhook/custom`, props, signal)

export type GetGitTriggerEventDetailsProps = Omit<
  GetProps<ResponseMapStringMapStringListString, Failure | Error, void, void>,
  'path'
>

/**
 * Get trigger git actions with Events
 */
export const GetGitTriggerEventDetails = (props: GetGitTriggerEventDetailsProps) => (
  <Get<ResponseMapStringMapStringListString, Failure | Error, void, void>
    path={`/webhook/gitTriggerEventDetails`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGitTriggerEventDetailsProps = Omit<
  UseGetProps<ResponseMapStringMapStringListString, Failure | Error, void, void>,
  'path'
>

/**
 * Get trigger git actions with Events
 */
export const useGetGitTriggerEventDetails = (props: UseGetGitTriggerEventDetailsProps) =>
  useGet<ResponseMapStringMapStringListString, Failure | Error, void, void>(`/webhook/gitTriggerEventDetails`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get trigger git actions with Events
 */
export const getGitTriggerEventDetailsPromise = (
  props: GetUsingFetchProps<ResponseMapStringMapStringListString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringMapStringListString, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/gitTriggerEventDetails`,
    props,
    signal
  )

export type GetGithubIssueCommentActionsProps = Omit<
  GetProps<ResponseListGithubIssueCommentAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetGithubIssueCommentActions = (props: GetGithubIssueCommentActionsProps) => (
  <Get<ResponseListGithubIssueCommentAction, Failure | Error, void, void>
    path={`/webhook/githubIssueCommentActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGithubIssueCommentActionsProps = Omit<
  UseGetProps<ResponseListGithubIssueCommentAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGithubIssueCommentActions = (props: UseGetGithubIssueCommentActionsProps) =>
  useGet<ResponseListGithubIssueCommentAction, Failure | Error, void, void>(`/webhook/githubIssueCommentActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGithubIssueCommentActionsPromise = (
  props: GetUsingFetchProps<ResponseListGithubIssueCommentAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGithubIssueCommentAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/githubIssueCommentActions`,
    props,
    signal
  )

export type GetGithubPRActionsProps = Omit<GetProps<ResponseListGithubPRAction, Failure | Error, void, void>, 'path'>

/**
 * Get Source Repo types with Events
 */
export const GetGithubPRActions = (props: GetGithubPRActionsProps) => (
  <Get<ResponseListGithubPRAction, Failure | Error, void, void>
    path={`/webhook/githubPRActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGithubPRActionsProps = Omit<
  UseGetProps<ResponseListGithubPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGithubPRActions = (props: UseGetGithubPRActionsProps) =>
  useGet<ResponseListGithubPRAction, Failure | Error, void, void>(`/webhook/githubPRActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGithubPRActionsPromise = (
  props: GetUsingFetchProps<ResponseListGithubPRAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGithubPRAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/githubPRActions`,
    props,
    signal
  )

export type GetGithubTriggerEventsProps = Omit<
  GetProps<ResponseListGithubTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetGithubTriggerEvents = (props: GetGithubTriggerEventsProps) => (
  <Get<ResponseListGithubTriggerEvent, Failure | Error, void, void>
    path={`/webhook/githubTriggerEvents`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGithubTriggerEventsProps = Omit<
  UseGetProps<ResponseListGithubTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGithubTriggerEvents = (props: UseGetGithubTriggerEventsProps) =>
  useGet<ResponseListGithubTriggerEvent, Failure | Error, void, void>(`/webhook/githubTriggerEvents`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGithubTriggerEventsPromise = (
  props: GetUsingFetchProps<ResponseListGithubTriggerEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGithubTriggerEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/githubTriggerEvents`,
    props,
    signal
  )

export type GetGitlabPRActionsProps = Omit<GetProps<ResponseListGitlabPRAction, Failure | Error, void, void>, 'path'>

/**
 * Get Source Repo types with Events
 */
export const GetGitlabPRActions = (props: GetGitlabPRActionsProps) => (
  <Get<ResponseListGitlabPRAction, Failure | Error, void, void>
    path={`/webhook/gitlabPRActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGitlabPRActionsProps = Omit<
  UseGetProps<ResponseListGitlabPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGitlabPRActions = (props: UseGetGitlabPRActionsProps) =>
  useGet<ResponseListGitlabPRAction, Failure | Error, void, void>(`/webhook/gitlabPRActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGitlabPRActionsPromise = (
  props: GetUsingFetchProps<ResponseListGitlabPRAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGitlabPRAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/gitlabPRActions`,
    props,
    signal
  )

export type GetGitlabTriggerEventsProps = Omit<
  GetProps<ResponseListGitlabTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetGitlabTriggerEvents = (props: GetGitlabTriggerEventsProps) => (
  <Get<ResponseListGitlabTriggerEvent, Failure | Error, void, void>
    path={`/webhook/gitlabTriggerEvents`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGitlabTriggerEventsProps = Omit<
  UseGetProps<ResponseListGitlabTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGitlabTriggerEvents = (props: UseGetGitlabTriggerEventsProps) =>
  useGet<ResponseListGitlabTriggerEvent, Failure | Error, void, void>(`/webhook/gitlabTriggerEvents`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGitlabTriggerEventsPromise = (
  props: GetUsingFetchProps<ResponseListGitlabTriggerEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGitlabTriggerEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/gitlabTriggerEvents`,
    props,
    signal
  )

export type GetSourceRepoToEventProps = Omit<
  GetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetSourceRepoToEvent = (props: GetSourceRepoToEventProps) => (
  <Get<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>
    path={`/webhook/sourceRepos`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetSourceRepoToEventProps = Omit<
  UseGetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetSourceRepoToEvent = (props: UseGetSourceRepoToEventProps) =>
  useGet<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(`/webhook/sourceRepos`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getSourceRepoToEventPromise = (
  props: GetUsingFetchProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/sourceRepos`,
    props,
    signal
  )

export interface WebhookEndpointQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type WebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const WebhookEndpoint = (props: WebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>
    verb="POST"
    path={`/webhook/trigger`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const useWebhookEndpoint = (props: UseWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>(
    'POST',
    `/webhook/trigger`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * accept webhook event
 */
export const webhookEndpointPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    WebhookEndpointQueryParams,
    WebhookEndpointBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, WebhookEndpointQueryParams, WebhookEndpointBodyRequestBody, void>(
    'POST',
    getConfig('pipeline/api'),
    `/webhook/trigger`,
    props,
    signal
  )

export interface TriggerProcessingDetailsQueryParams {
  accountIdentifier: string
  eventId: string
}

export type TriggerProcessingDetailsProps = Omit<
  GetProps<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>,
  'path'
>

/**
 * fetch webhook event details
 */
export const TriggerProcessingDetails = (props: TriggerProcessingDetailsProps) => (
  <Get<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>
    path={`/webhook/triggerProcessingDetails`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerProcessingDetailsProps = Omit<
  UseGetProps<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>,
  'path'
>

/**
 * fetch webhook event details
 */
export const useTriggerProcessingDetails = (props: UseTriggerProcessingDetailsProps) =>
  useGet<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>(
    `/webhook/triggerProcessingDetails`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * fetch webhook event details
 */
export const triggerProcessingDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseWebhookEventProcessingDetails,
    Failure | Error,
    TriggerProcessingDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>(
    getConfig('pipeline/api'),
    `/webhook/triggerProcessingDetails`,
    props,
    signal
  )

export type GetWebhookTriggerTypesProps = Omit<
  GetProps<ResponseListWebhookTriggerType, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetWebhookTriggerTypes = (props: GetWebhookTriggerTypesProps) => (
  <Get<ResponseListWebhookTriggerType, Failure | Error, void, void>
    path={`/webhook/webhookTriggerTypes`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetWebhookTriggerTypesProps = Omit<
  UseGetProps<ResponseListWebhookTriggerType, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetWebhookTriggerTypes = (props: UseGetWebhookTriggerTypesProps) =>
  useGet<ResponseListWebhookTriggerType, Failure | Error, void, void>(`/webhook/webhookTriggerTypes`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getWebhookTriggerTypesPromise = (
  props: GetUsingFetchProps<ResponseListWebhookTriggerType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListWebhookTriggerType, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/webhookTriggerTypes`,
    props,
    signal
  )

export interface GetSchemaYamlQueryParams {
  entityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'Barrier'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  accountIdentifier: string
}

export type GetSchemaYamlProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetSchemaYaml = (props: GetSchemaYamlProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>
    path={`/yaml-schema`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetSchemaYamlProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetSchemaYaml = (props: UseGetSchemaYamlProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>(`/yaml-schema`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getSchemaYamlPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>(
    getConfig('pipeline/api'),
    `/yaml-schema`,
    props,
    signal
  )

export interface GetStepYamlSchemaQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  yamlGroup?: string
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'Barrier'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetStepYamlSchemaProps = Omit<
  GetProps<ResponseYamlSchemaResponse, Failure | Error, GetStepYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get step YAML schema
 */
export const GetStepYamlSchema = (props: GetStepYamlSchemaProps) => (
  <Get<ResponseYamlSchemaResponse, Failure | Error, GetStepYamlSchemaQueryParams, void>
    path={`/yaml-schema/get`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetStepYamlSchemaProps = Omit<
  UseGetProps<ResponseYamlSchemaResponse, Failure | Error, GetStepYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get step YAML schema
 */
export const useGetStepYamlSchema = (props: UseGetStepYamlSchemaProps) =>
  useGet<ResponseYamlSchemaResponse, Failure | Error, GetStepYamlSchemaQueryParams, void>(`/yaml-schema/get`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get step YAML schema
 */
export const getStepYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseYamlSchemaResponse, Failure | Error, GetStepYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSchemaResponse, Failure | Error, GetStepYamlSchemaQueryParams, void>(
    getConfig('pipeline/api'),
    `/yaml-schema/get`,
    props,
    signal
  )

export type InvalidateYamlSchemaCacheProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Invalidate yaml schema cache
 */
export const InvalidateYamlSchemaCache = (props: InvalidateYamlSchemaCacheProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, void, void>
    verb="POST"
    path={`/yaml-schema/invalidate-cache`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseInvalidateYamlSchemaCacheProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Invalidate yaml schema cache
 */
export const useInvalidateYamlSchemaCache = (props: UseInvalidateYamlSchemaCacheProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, void, void>('POST', `/yaml-schema/invalidate-cache`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Invalidate yaml schema cache
 */
export const invalidateYamlSchemaCachePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, void, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/yaml-schema/invalidate-cache`,
    props,
    signal
  )
