/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export interface Account {
  uuid: string
  appId: string
  createdBy?: EmbeddedUser
  createdAt?: number
  lastUpdatedBy?: EmbeddedUser
  lastUpdatedAt: number
  companyName: string
  accountName: string
  whitelistedDomains?: string[]
  licenseId?: string
  dataRetentionDurationMs?: number
  licenseInfo?: LicenseInfo
  ceLicenseInfo?: CeLicenseInfo
  accountEvents?: AccountEvent[]
  subdomainUrl?: string
  twoFactorAdminEnforced?: boolean
  forImport?: boolean
  migratedToClusterUrl?: string
  defaultExperience?: 'NG' | 'CG'
  createdFromNG?: boolean
  localEncryptionEnabled?: boolean
  delegateConfiguration?: DelegateConfiguration
  techStacks?: TechStack[]
  oauthEnabled?: boolean
  accountPreferences?: AccountPreferences
  cloudCostEnabled?: boolean
  ceAutoCollectK8sEvents?: boolean
  trialSignupOptions?: TrialSignupOptions
  serviceGuardLimit?: number
  defaults?: {
    [key: string]: string
  }
  harnessSupportAccessAllowed?: boolean
  povAccount?: boolean
}

export interface Response {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseAccount {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: Account
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Failure {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'DATA'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
  message?: string
  correlationId?: string
  errors?: ValidationError[]
}

export interface ValidationError {
  fieldId?: string
  error?: string
}

export interface Error {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'DATA'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
  message?: string
  correlationId?: string
  detailedMessage?: string
  responseMessages?: ResponseMessage[]
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'DATA'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
  level?: 'INFO' | 'ERROR'
  message?: string
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
}

export interface StackTraceElement {
  methodName?: string
  fileName?: string
  lineNumber?: number
  className?: string
  nativeMethod?: boolean
}

export interface Throwable {
  cause?: Throwable
  stackTrace?: StackTraceElement[]
  message?: string
  localizedMessage?: string
  suppressed?: Throwable[]
}

export interface ResponseStepCategory {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: StepCategory
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StepCategory {
  name?: string
  stepsData?: StepData[]
  stepCategories?: StepCategory[]
}

export interface StepData {
  type?:
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sBGSwapServices'
    | 'K8sDelete'
    | 'K8sCanaryDelete'
    | 'K8sCanaryDeploy'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'ShellScript'
    | 'Placeholder'
    | 'Placeholder'
  name?: string
}

export interface ResponseMapServiceDefinitionTypeListExecutionStrategyType {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: {
    [key: string]: ('Basic' | 'Canary' | 'BlueGreen' | 'Rolling' | 'Default')[]
  }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListServiceDefinitionType {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ('Ssh' | 'Kubernetes' | 'Ecs' | 'NativeHelm' | 'Pcf')[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPipelineValidationInfo {
  pipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: VisitorErrorResponseWrapper
  }
  errorResponse?: boolean
}

export interface ResponseNGPipelineValidationInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineValidationInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface VisitorErrorResponse {
  fieldName?: string
  message?: string
}

export interface VisitorErrorResponseWrapper {
  errors?: VisitorErrorResponse[]
}

export interface ByteString {
  empty?: boolean
  validUtf8?: boolean
}

export interface Commit {
  unknownFields?: UnknownFieldSet
  message?: string
  linkBytes?: ByteString
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserCommit
  defaultInstanceForType?: Commit
  messageBytes?: ByteString
  sha?: string
  shaBytes?: ByteString
  author?: Signature
  authorOrBuilder?: SignatureOrBuilder
  committer?: Signature
  committerOrBuilder?: SignatureOrBuilder
  link?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface CommitOrBuilder {
  message?: string
  linkBytes?: ByteString
  messageBytes?: ByteString
  sha?: string
  shaBytes?: ByteString
  author?: Signature
  authorOrBuilder?: SignatureOrBuilder
  committer?: Signature
  committerOrBuilder?: SignatureOrBuilder
  link?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Descriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  nestedTypes?: Descriptor[]
  enumTypes?: EnumDescriptor[]
  fields?: FieldDescriptor[]
  extensions?: FieldDescriptor[]
  oneofs?: OneofDescriptor[]
  name?: string
  options?: MessageOptions
  extendable?: boolean
}

export interface EnumDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  values?: EnumValueDescriptor[]
  name?: string
  options?: EnumOptions
}

export interface EnumOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserEnumOptions
  defaultInstanceForType?: EnumOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  allowAlias?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface EnumValueDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  type?: EnumDescriptor
  name?: string
  number?: number
  options?: EnumValueOptions
}

export interface EnumValueOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserEnumValueOptions
  defaultInstanceForType?: EnumValueOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionMetadata {
  unknownFields?: UnknownFieldSet
  yaml?: string
  runSequence?: number
  triggerInfo?: ExecutionTriggerInfo
  triggerInfoOrBuilder?: ExecutionTriggerInfoOrBuilder
  triggerPayload?: TriggerPayload
  triggerPayloadOrBuilder?: TriggerPayloadOrBuilder
  pipelineIdentifier?: string
  pipelineIdentifierBytes?: ByteString
  inputSetYaml?: string
  inputSetYamlBytes?: ByteString
  executionUuid?: string
  executionUuidBytes?: ByteString
  yamlBytes?: ByteString
  principalInfoOrBuilder?: ExecutionPrincipalInfoOrBuilder
  processedYaml?: string
  processedYamlBytes?: ByteString
  principalInfo?: ExecutionPrincipalInfo
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionMetadata
  defaultInstanceForType?: ExecutionMetadata
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionPrincipalInfo {
  unknownFields?: UnknownFieldSet
  principal?: string
  principalBytes?: ByteString
  principalTypeValue?: number
  principalType?: 'UNKNOWN' | 'USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE' | 'UNRECOGNIZED'
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionPrincipalInfo
  defaultInstanceForType?: ExecutionPrincipalInfo
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionPrincipalInfoOrBuilder {
  principal?: string
  principalBytes?: ByteString
  principalTypeValue?: number
  principalType?: 'UNKNOWN' | 'USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE' | 'UNRECOGNIZED'
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ExecutionTriggerInfo {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionTriggerInfo
  defaultInstanceForType?: ExecutionTriggerInfo
  triggerTypeValue?: number
  triggerType?: 'NOOP' | 'MANUAL' | 'WEBHOOK' | 'WEBHOOK_CUSTOM' | 'SCHEDULER_CRON' | 'UNRECOGNIZED'
  triggeredBy?: TriggeredBy
  triggeredByOrBuilder?: TriggeredByOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionTriggerInfoOrBuilder {
  triggerTypeValue?: number
  triggerType?: 'NOOP' | 'MANUAL' | 'WEBHOOK' | 'WEBHOOK_CUSTOM' | 'SCHEDULER_CRON' | 'UNRECOGNIZED'
  triggeredBy?: TriggeredBy
  triggeredByOrBuilder?: TriggeredByOrBuilder
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface FieldDescriptor {
  index?: number
  fullName?: string
  jsonName?: string
  file?: FileDescriptor
  extensionScope?: Descriptor
  type?:
    | 'DOUBLE'
    | 'FLOAT'
    | 'INT64'
    | 'UINT64'
    | 'INT32'
    | 'FIXED64'
    | 'FIXED32'
    | 'BOOL'
    | 'STRING'
    | 'GROUP'
    | 'MESSAGE'
    | 'BYTES'
    | 'UINT32'
    | 'ENUM'
    | 'SFIXED32'
    | 'SFIXED64'
    | 'SINT32'
    | 'SINT64'
  containingType?: Descriptor
  messageType?: Descriptor
  containingOneof?: OneofDescriptor
  enumType?: EnumDescriptor
  defaultValue?: { [key: string]: any }
  name?: string
  number?: number
  required?: boolean
  optional?: boolean
  options?: FieldOptions
  repeated?: boolean
  javaType?: 'INT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'BOOLEAN' | 'STRING' | 'BYTE_STRING' | 'ENUM' | 'MESSAGE'
  mapField?: boolean
  extension?: boolean
  liteJavaType?: 'INT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'BOOLEAN' | 'STRING' | 'BYTE_STRING' | 'ENUM' | 'MESSAGE'
  liteType?:
    | 'DOUBLE'
    | 'FLOAT'
    | 'INT64'
    | 'UINT64'
    | 'INT32'
    | 'FIXED64'
    | 'FIXED32'
    | 'BOOL'
    | 'STRING'
    | 'GROUP'
    | 'MESSAGE'
    | 'BYTES'
    | 'UINT32'
    | 'ENUM'
    | 'SFIXED32'
    | 'SFIXED64'
    | 'SINT32'
    | 'SINT64'
  packed?: boolean
  packable?: boolean
}

export interface FieldOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserFieldOptions
  defaultInstanceForType?: FieldOptions
  packed?: boolean
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  ctype?: 'STRING' | 'CORD' | 'STRING_PIECE'
  jstype?: 'JS_NORMAL' | 'JS_STRING' | 'JS_NUMBER'
  lazy?: boolean
  weak?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface FileDescriptor {
  messageTypes?: Descriptor[]
  enumTypes?: EnumDescriptor[]
  services?: ServiceDescriptor[]
  extensions?: FieldDescriptor[]
  dependencies?: FileDescriptor[]
  publicDependencies?: FileDescriptor[]
  name?: string
  package?: string
  file?: FileDescriptor
  fullName?: string
  options?: FileOptions
  syntax?: 'UNKNOWN' | 'PROTO2' | 'PROTO3'
}

export interface FileOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserFileOptions
  defaultInstanceForType?: FileOptions
  javaStringCheckUtf8?: boolean
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  javaPackage?: string
  javaPackageBytes?: ByteString
  javaOuterClassname?: string
  javaOuterClassnameBytes?: ByteString
  javaMultipleFiles?: boolean
  javaGenerateEqualsAndHash?: boolean
  optimizeFor?: 'SPEED' | 'CODE_SIZE' | 'LITE_RUNTIME'
  goPackage?: string
  goPackageBytes?: ByteString
  ccGenericServices?: boolean
  javaGenericServices?: boolean
  pyGenericServices?: boolean
  phpGenericServices?: boolean
  ccEnableArenas?: boolean
  objcClassPrefix?: string
  objcClassPrefixBytes?: ByteString
  csharpNamespace?: string
  csharpNamespaceBytes?: ByteString
  swiftPrefix?: string
  swiftPrefixBytes?: ByteString
  phpClassPrefix?: string
  phpClassPrefixBytes?: ByteString
  phpNamespace?: string
  phpNamespaceBytes?: ByteString
  phpMetadataNamespace?: string
  phpMetadataNamespaceBytes?: ByteString
  rubyPackage?: string
  rubyPackageBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface Label {
  unknownFields?: UnknownFieldSet
  name?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserLabel
  defaultInstanceForType?: Label
  nameBytes?: ByteString
  color?: string
  colorBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface LabelOrBuilder {
  name?: string
  nameBytes?: ByteString
  color?: string
  colorBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Message {
  parserForType?: ParserMessage
  serializedSize?: number
  initialized?: boolean
  defaultInstanceForType?: MessageLite
  unknownFields?: UnknownFieldSet
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface MessageLite {
  serializedSize?: number
  parserForType?: ParserMessageLite
  initialized?: boolean
  defaultInstanceForType?: MessageLite
}

export interface MessageOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserMessageOptions
  defaultInstanceForType?: MessageOptions
  mapEntry?: boolean
  messageSetWireFormat?: boolean
  noStandardDescriptorAccessor?: boolean
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface MethodDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  service?: ServiceDescriptor
  inputType?: Descriptor
  outputType?: Descriptor
  name?: string
  options?: MethodOptions
  clientStreaming?: boolean
  serverStreaming?: boolean
}

export interface MethodOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserMethodOptions
  defaultInstanceForType?: MethodOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  idempotencyLevel?: 'IDEMPOTENCY_UNKNOWN' | 'NO_SIDE_EFFECTS' | 'IDEMPOTENT'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface NGPipelineError {
  fieldName?: string
  message?: string
  identifierOfErrorSource?: string
}

export interface NGPipelineErrorResponse {
  errors?: NGPipelineError[]
}

export interface NGPipelineErrorWrapper {
  errorPipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: NGPipelineErrorResponse
  }
}

export interface NGPipelineExecutionResponse {
  planExecution?: PlanExecution
  pipelineErrorResponse?: NGPipelineErrorWrapper
  errorResponse?: boolean
}

export interface NamePart {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserNamePart
  defaultInstanceForType?: NamePart
  namePart?: string
  namePartBytes?: ByteString
  isExtension?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface NamePartOrBuilder {
  namePart?: string
  namePartBytes?: ByteString
  isExtension?: boolean
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface OneofDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  fieldCount?: number
  fields?: FieldDescriptor[]
  name?: string
  options?: OneofOptions
}

export interface OneofOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserOneofOptions
  defaultInstanceForType?: OneofOptions
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ParsedPayload {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserParsedPayload
  defaultInstanceForType?: ParsedPayload
  pr?: PullRequestHook
  prOrBuilder?: PullRequestHookOrBuilder
  push?: PushHook
  pushOrBuilder?: PushHookOrBuilder
  payloadCase?: 'PR' | 'PUSH' | 'PAYLOAD_NOT_SET'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ParsedPayloadOrBuilder {
  pr?: PullRequestHook
  prOrBuilder?: PullRequestHookOrBuilder
  push?: PushHook
  pushOrBuilder?: PushHookOrBuilder
  payloadCase?: 'PR' | 'PUSH' | 'PAYLOAD_NOT_SET'
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Parser {
  [key: string]: any
}

export interface ParserCommit {
  [key: string]: any
}

export interface ParserEnumOptions {
  [key: string]: any
}

export interface ParserEnumValueOptions {
  [key: string]: any
}

export interface ParserExecutionMetadata {
  [key: string]: any
}

export interface ParserExecutionPrincipalInfo {
  [key: string]: any
}

export interface ParserExecutionTriggerInfo {
  [key: string]: any
}

export interface ParserFieldOptions {
  [key: string]: any
}

export interface ParserFileOptions {
  [key: string]: any
}

export interface ParserLabel {
  [key: string]: any
}

export interface ParserMessage {
  [key: string]: any
}

export interface ParserMessageLite {
  [key: string]: any
}

export interface ParserMessageOptions {
  [key: string]: any
}

export interface ParserMethodOptions {
  [key: string]: any
}

export interface ParserNamePart {
  [key: string]: any
}

export interface ParserOneofOptions {
  [key: string]: any
}

export interface ParserParsedPayload {
  [key: string]: any
}

export interface ParserPerm {
  [key: string]: any
}

export interface ParserPullRequest {
  [key: string]: any
}

export interface ParserPullRequestHook {
  [key: string]: any
}

export interface ParserPushHook {
  [key: string]: any
}

export interface ParserReference {
  [key: string]: any
}

export interface ParserRepository {
  [key: string]: any
}

export interface ParserServiceOptions {
  [key: string]: any
}

export interface ParserSignature {
  [key: string]: any
}

export interface ParserTimestamp {
  [key: string]: any
}

export interface ParserTriggerPayload {
  [key: string]: any
}

export interface ParserTriggeredBy {
  [key: string]: any
}

export interface ParserUninterpretedOption {
  [key: string]: any
}

export interface ParserUser {
  [key: string]: any
}

export interface Perm {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPerm
  defaultInstanceForType?: Perm
  admin?: boolean
  pull?: boolean
  push?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PermOrBuilder {
  admin?: boolean
  pull?: boolean
  push?: boolean
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface PlanExecution {
  uuid?: string
  createdAt?: number
  setupAbstractions?: {
    [key: string]: string
  }
  validUntil?: string
  status?:
    | 'NO_OP'
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'IGNORE_FAILED'
    | 'APPROVAL_WAITING'
    | 'RESOURCE_WAITING'
    | 'APPROVAL_REJECTED'
    | 'UNRECOGNIZED'
  startTs?: number
  endTs?: number
  metadata?: ExecutionMetadata
  lastUpdatedAt?: number
  version?: number
  nextIteration?: number
}

export interface PullRequest {
  unknownFields?: UnknownFieldSet
  target?: string
  ref?: string
  number?: number
  body?: string
  base?: Reference
  title?: string
  linkBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPullRequest
  defaultInstanceForType?: PullRequest
  created?: Timestamp
  head?: Reference
  source?: string
  refBytes?: ByteString
  fork?: string
  titleBytes?: ByteString
  bodyBytes?: ByteString
  sha?: string
  shaBytes?: ByteString
  sourceBytes?: ByteString
  targetBytes?: ByteString
  forkBytes?: ByteString
  closed?: boolean
  merged?: boolean
  baseOrBuilder?: ReferenceOrBuilder
  headOrBuilder?: ReferenceOrBuilder
  author?: User
  authorOrBuilder?: UserOrBuilder
  labelsList?: Label[]
  labelsCount?: number
  labelsOrBuilderList?: LabelOrBuilder[]
  link?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PullRequestHook {
  unknownFields?: UnknownFieldSet
  repo?: Repository
  actionValue?: number
  repoOrBuilder?: RepositoryOrBuilder
  sender?: User
  senderOrBuilder?: UserOrBuilder
  action?:
    | 'UNKNOWN'
    | 'CREATE'
    | 'UPDATE'
    | 'DELETE'
    | 'OPEN'
    | 'REOPEN'
    | 'CLOSE'
    | 'LABEL'
    | 'UNLABEL'
    | 'SYNC'
    | 'MERGE'
    | 'UNRECOGNIZED'
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPullRequestHook
  defaultInstanceForType?: PullRequestHook
  pr?: PullRequest
  prOrBuilder?: PullRequestOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PullRequestHookOrBuilder {
  repo?: Repository
  actionValue?: number
  repoOrBuilder?: RepositoryOrBuilder
  sender?: User
  senderOrBuilder?: UserOrBuilder
  action?:
    | 'UNKNOWN'
    | 'CREATE'
    | 'UPDATE'
    | 'DELETE'
    | 'OPEN'
    | 'REOPEN'
    | 'CLOSE'
    | 'LABEL'
    | 'UNLABEL'
    | 'SYNC'
    | 'MERGE'
    | 'UNRECOGNIZED'
  pr?: PullRequest
  prOrBuilder?: PullRequestOrBuilder
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface PullRequestOrBuilder {
  target?: string
  ref?: string
  number?: number
  body?: string
  base?: Reference
  title?: string
  linkBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  created?: Timestamp
  head?: Reference
  source?: string
  refBytes?: ByteString
  fork?: string
  titleBytes?: ByteString
  bodyBytes?: ByteString
  sha?: string
  shaBytes?: ByteString
  sourceBytes?: ByteString
  targetBytes?: ByteString
  forkBytes?: ByteString
  closed?: boolean
  merged?: boolean
  baseOrBuilder?: ReferenceOrBuilder
  headOrBuilder?: ReferenceOrBuilder
  author?: User
  authorOrBuilder?: UserOrBuilder
  labelsList?: Label[]
  labelsCount?: number
  labelsOrBuilderList?: LabelOrBuilder[]
  link?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface PushHook {
  unknownFields?: UnknownFieldSet
  ref?: string
  repo?: Repository
  repoOrBuilder?: RepositoryOrBuilder
  sender?: User
  senderOrBuilder?: UserOrBuilder
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserPushHook
  defaultInstanceForType?: PushHook
  refBytes?: ByteString
  baseRef?: string
  after?: string
  baseRefBytes?: ByteString
  before?: string
  beforeBytes?: ByteString
  afterBytes?: ByteString
  commit?: Commit
  commitOrBuilder?: CommitOrBuilder
  commitsList?: Commit[]
  commitsCount?: number
  commitsOrBuilderList?: CommitOrBuilder[]
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface PushHookOrBuilder {
  ref?: string
  repo?: Repository
  repoOrBuilder?: RepositoryOrBuilder
  sender?: User
  senderOrBuilder?: UserOrBuilder
  refBytes?: ByteString
  baseRef?: string
  after?: string
  baseRefBytes?: ByteString
  before?: string
  beforeBytes?: ByteString
  afterBytes?: ByteString
  commit?: Commit
  commitOrBuilder?: CommitOrBuilder
  commitsList?: Commit[]
  commitsCount?: number
  commitsOrBuilderList?: CommitOrBuilder[]
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Reference {
  unknownFields?: UnknownFieldSet
  name?: string
  path?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserReference
  defaultInstanceForType?: Reference
  nameBytes?: ByteString
  sha?: string
  shaBytes?: ByteString
  pathBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ReferenceOrBuilder {
  name?: string
  path?: string
  nameBytes?: ByteString
  sha?: string
  shaBytes?: ByteString
  pathBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Repository {
  unknownFields?: UnknownFieldSet
  name?: string
  id?: string
  clone?: string
  perm?: Perm
  idBytes?: ByteString
  namespaceBytes?: ByteString
  permOrBuilder?: PermOrBuilder
  branchBytes?: ByteString
  private?: boolean
  cloneBytes?: ByteString
  cloneSsh?: string
  cloneSshBytes?: ByteString
  linkBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserRepository
  defaultInstanceForType?: Repository
  created?: Timestamp
  nameBytes?: ByteString
  namespace?: string
  branch?: string
  link?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface RepositoryOrBuilder {
  name?: string
  id?: string
  clone?: string
  perm?: Perm
  idBytes?: ByteString
  namespaceBytes?: ByteString
  permOrBuilder?: PermOrBuilder
  branchBytes?: ByteString
  private?: boolean
  cloneBytes?: ByteString
  cloneSsh?: string
  cloneSshBytes?: ByteString
  linkBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  created?: Timestamp
  nameBytes?: ByteString
  namespace?: string
  branch?: string
  link?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ResponseNGPipelineExecutionResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineExecutionResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  methods?: MethodDescriptor[]
  name?: string
  options?: ServiceOptions
}

export interface ServiceOptions {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserServiceOptions
  defaultInstanceForType?: ServiceOptions
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface Signature {
  unknownFields?: UnknownFieldSet
  name?: string
  email?: string
  emailBytes?: ByteString
  avatar?: string
  avatarBytes?: ByteString
  loginBytes?: ByteString
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSignature
  defaultInstanceForType?: Signature
  nameBytes?: ByteString
  login?: string
  date?: Timestamp
  dateOrBuilder?: TimestampOrBuilder
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface SignatureOrBuilder {
  name?: string
  email?: string
  emailBytes?: ByteString
  avatar?: string
  avatarBytes?: ByteString
  loginBytes?: ByteString
  nameBytes?: ByteString
  login?: string
  date?: Timestamp
  dateOrBuilder?: TimestampOrBuilder
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Timestamp {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTimestamp
  defaultInstanceForType?: Timestamp
  seconds?: number
  nanos?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TimestampOrBuilder {
  seconds?: number
  nanos?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TriggerPayload {
  unknownFields?: UnknownFieldSet
  type?: 'CUSTOM' | 'GIT' | 'SCHEDULED' | 'UNRECOGNIZED'
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTriggerPayload
  defaultInstanceForType?: TriggerPayload
  headers?: {
    [key: string]: string
  }
  jsonPayload?: string
  jsonPayloadBytes?: ByteString
  parsedPayload?: ParsedPayload
  parsedPayloadOrBuilder?: ParsedPayloadOrBuilder
  typeValue?: number
  headersCount?: number
  headersMap?: {
    [key: string]: string
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TriggerPayloadOrBuilder {
  type?: 'CUSTOM' | 'GIT' | 'SCHEDULED' | 'UNRECOGNIZED'
  headers?: {
    [key: string]: string
  }
  jsonPayload?: string
  jsonPayloadBytes?: ByteString
  parsedPayload?: ParsedPayload
  parsedPayloadOrBuilder?: ParsedPayloadOrBuilder
  typeValue?: number
  headersCount?: number
  headersMap?: {
    [key: string]: string
  }
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TriggeredBy {
  unknownFields?: UnknownFieldSet
  identifier?: string
  uuidBytes?: ByteString
  identifierBytes?: ByteString
  uuid?: string
  extraInfoCount?: number
  extraInfo?: {
    [key: string]: string
  }
  extraInfoMap?: {
    [key: string]: string
  }
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTriggeredBy
  defaultInstanceForType?: TriggeredBy
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TriggeredByOrBuilder {
  identifier?: string
  uuidBytes?: ByteString
  identifierBytes?: ByteString
  uuid?: string
  extraInfoCount?: number
  extraInfo?: {
    [key: string]: string
  }
  extraInfoMap?: {
    [key: string]: string
  }
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface UninterpretedOption {
  unknownFields?: UnknownFieldSet
  nameCount?: number
  doubleValue?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserUninterpretedOption
  defaultInstanceForType?: UninterpretedOption
  stringValue?: ByteString
  nameList?: NamePart[]
  nameOrBuilderList?: NamePartOrBuilder[]
  identifierValue?: string
  identifierValueBytes?: ByteString
  positiveIntValue?: number
  negativeIntValue?: number
  aggregateValue?: string
  aggregateValueBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface UninterpretedOptionOrBuilder {
  nameCount?: number
  doubleValue?: number
  stringValue?: ByteString
  nameList?: NamePart[]
  nameOrBuilderList?: NamePartOrBuilder[]
  identifierValue?: string
  identifierValueBytes?: ByteString
  positiveIntValue?: number
  negativeIntValue?: number
  aggregateValue?: string
  aggregateValueBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface UnknownFieldSet {
  initialized?: boolean
  serializedSize?: number
  parserForType?: Parser
  defaultInstanceForType?: UnknownFieldSet
  serializedSizeAsMessageSet?: number
}

export interface User {
  uuid: string
  appId: string
  createdBy?: EmbeddedUser
  createdAt?: number
  lastUpdatedBy?: EmbeddedUser
  lastUpdatedAt: number
  name?: string
  givenName?: string
  familyName?: string
  email?: string
  companyName?: string
  accountName?: string
  userGroups?: UserGroup[]
  accounts?: Account[]
  pendingAccounts?: Account[]
  supportAccounts?: Account[]
  lastLogin?: number
  firstLogin?: boolean
  password?: string[]
  token?: string
  twoFactorJwtToken?: string
  emailVerified?: boolean
  passwordExpired?: boolean
  userLocked?: boolean
  statsFetchedOn?: number
  lastAccountId?: string
  defaultAccountId?: string
  lastAppId?: string
  disabled?: boolean
  imported?: boolean
  userLockoutInfo?: UserLockoutInfo
  twoFactorAuthenticationEnabled?: boolean
  twoFactorAuthenticationMechanism?: 'TOTP'
  oauthProvider?: string
  reportedSegmentTracks?: string[]
  utmInfo?: UtmInfo
  accountIds?: string[]
}

export interface UserOrBuilder {
  name?: string
  email?: string
  emailBytes?: ByteString
  avatar?: string
  avatarBytes?: ByteString
  createdOrBuilder?: TimestampOrBuilder
  updated?: Timestamp
  updatedOrBuilder?: TimestampOrBuilder
  loginBytes?: ByteString
  created?: Timestamp
  nameBytes?: ByteString
  login?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Abort'
}

export type AddSegmentToVariationTargetMapYaml = PatchInstruction & {
  type:
    | 'SetFeatureFlagState'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentsToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
  spec: AddSegmentToVariationTargetMapYamlSpec
}

export interface AddSegmentToVariationTargetMapYamlSpec {
  variation?: string
  segments?: string[]
}

export type AddTargetsToVariationTargetMapYaml = PatchInstruction & {
  type:
    | 'SetFeatureFlagState'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentsToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
  spec: AddTargetsToVariationTargetMapYamlSpec
}

export interface AddTargetsToVariationTargetMapYamlSpec {
  variation?: string
  targets?: string[]
}

export interface ApproverInputInfo {
  name?: string
  defaultValue?: string
}

export interface Approvers {
  userGroups: string[]
  minimumCount: number
  disallowPipelineExecutor: boolean
}

export interface ArtifactConfig {
  [key: string]: any
}

export interface ArtifactListConfig {
  primary?: ArtifactSpecWrapper
  sidecars?: SidecarArtifactWrapper[]
  metadata?: string
}

export interface ArtifactOverrideSetWrapper {
  overrideSet?: ArtifactOverrideSets
}

export interface ArtifactOverrideSets {
  identifier?: string
  artifacts?: ArtifactListConfig
}

export interface ArtifactSpecWrapper {
  type: 'Dockerhub' | 'Gcr' | 'Ecr'
  spec?: ArtifactConfig
}

export type BarrierStepInfo = StepSpecType & {
  barrierRef: string
}

export type BitbucketStore = StoreConfig & {
  connectorRef?: string
  gitFetchType?: 'Branch' | 'Commit'
  branch?: string
  commitId?: string
  paths?: string[]
  folderPath?: string
  repoName?: string
  metadata?: string
}

export type BranchBuildSpec = BuildSpec & {
  branch: string
}

export interface Build {
  type: 'branch' | 'tag'
  spec: BuildSpec
}

export interface BuildSpec {
  [key: string]: any
}

export interface CodeBase {
  connectorRef: string
  repoName?: string
  build: Build
}

export interface Condition {
  key: string
  value: string
  operator: 'equals' | 'not equals' | 'in' | 'not in'
}

export type CountInstanceSelection = InstanceSelectionBase & {
  count?: string
}

export interface CriteriaSpec {
  [key: string]: any
}

export interface CriteriaSpecWrapper {
  type: 'Jexl' | 'KeyValues'
  spec: CriteriaSpec
}

export type DeleteManifestPathSpec = DeleteResourcesBaseSpec & {
  manifestPaths?: string[]
}

export type DeleteReleaseNameSpec = DeleteResourcesBaseSpec & {}

export type DeleteResourceNameSpec = DeleteResourcesBaseSpec & {}

export interface DeleteResourcesBaseSpec {
  type?: 'ResourceName' | 'ReleaseName' | 'ManifestPath'
  resourceNames?: string[]
  manifestPaths?: string
  deleteNamespace?: boolean
  allManifestPaths?: boolean
}

export interface DeleteResourcesWrapper {
  type?: 'ResourceName' | 'ReleaseName' | 'ManifestPath'
  spec?: DeleteResourcesBaseSpec
}

export type DeploymentStage = StageType & {
  variables?: NGVariable[]
  serviceConfig?: ServiceConfig
  infrastructure?: PipelineInfrastructure
  execution?: ExecutionElement
  skipCondition?: string
  metadata?: string
}

export type DockerHubArtifactConfig = ArtifactConfig & {
  connectorRef?: string
  imagePath?: string
  tag?: string
  tagRegex?: string
  metadata?: string
}

export type EcrArtifactConfig = ArtifactConfig & {
  connectorRef?: string
  region?: string
  imagePath?: string
  tag?: string
  tagRegex?: string
}

export interface EnvironmentYaml {
  name: string
  identifier: string
  description?: string
  type: 'PreProduction' | 'Production'
  tags?: {
    [key: string]: string
  }
}

export interface ExecutionElement {
  steps?: ExecutionWrapper[]
  rollbackSteps?: ExecutionWrapper[]
  metadata?: string
}

export interface ExecutionElementConfig {
  steps?: ExecutionWrapperConfig[]
  rollbackSteps?: ExecutionWrapperConfig[]
}

export interface ExecutionTarget {
  host?: string
  connectorRef?: string
  workingDirectory?: string
}

export interface ExecutionWrapper {
  [key: string]: any
}

export interface ExecutionWrapperConfig {
  step?: StepElementConfig
  parallel?: ParallelStepElementConfig
  stepGroup?: StepGroupElementConfig
}

export interface FailureStrategyActionConfig {
  type: 'Ignore' | 'Retry' | 'MarkAsSuccess' | 'Abort' | 'StageRollback' | 'StepGroupRollback' | 'ManualIntervention'
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig
}

export type FeatureUpdateStepInfo = StepSpecType & {
  featureUpdateRef: string
  feature: string
  environment: string
  instructions: PatchInstruction[]
  state: string
}

export type GcrArtifactConfig = ArtifactConfig & {
  connectorRef?: string
  registryHostname?: string
  imagePath?: string
  tag?: string
  tagRegex?: string
  metadata?: string
}

export type GcsStoreConfig = StoreConfig & {
  connectorRef?: string
  bucketName?: string
  folderPath?: string
  metadata?: string
}

export type GitLabStore = StoreConfig & {
  connectorRef?: string
  gitFetchType?: 'Branch' | 'Commit'
  branch?: string
  commitId?: string
  paths?: string[]
  folderPath?: string
  repoName?: string
  metadata?: string
}

export type GitStore = StoreConfig & {
  connectorRef?: string
  gitFetchType?: 'Branch' | 'Commit'
  branch?: string
  commitId?: string
  paths?: string[]
  folderPath?: string
  repoName?: string
  metadata?: string
}

export type GithubStore = StoreConfig & {
  connectorRef?: string
  gitFetchType?: 'Branch' | 'Commit'
  branch?: string
  commitId?: string
  paths?: string[]
  folderPath?: string
  repoName?: string
  metadata?: string
}

export type HarnessApprovalStepInfo = StepSpecType & {
  approvalMessage: string
  includePipelineExecutionHistory: boolean
  approvers: Approvers
  approverInputs?: ApproverInputInfo[]
}

export type HelmChartManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  chartName?: string
  chartVersion?: string
  helmVersion?: 'V2' | 'V3'
  skipResourceVersioning?: boolean
  commandFlags?: HelmManifestCommandFlag[]
  metadata?: string
}

export interface HelmManifestCommandFlag {
  commandType: 'Fetch' | 'Version' | 'Template' | 'Pull'
  flag?: string
}

export interface HoldingScope {
  scope: string
  nodeSetupId: string
}

export interface HttpHeaderConfig {
  key?: string
  value?: string
}

export type HttpStepInfo = StepSpecType & {
  url: string
  method: string
  requestBody?: string
  assertion?: string
  outputVariables?: NGVariable[]
  headers?: HttpHeaderConfig[]
  delegateSelectors?: ParameterFieldListTaskSelectorYaml
}

export type HttpStoreConfig = StoreConfig & {
  connectorRef?: string
  metadata?: string
}

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Ignore'
}

export interface InfraOverrides {
  environment?: EnvironmentYaml
  infrastructureDefinition?: InfrastructureDef
}

export interface InfraUseFromStage {
  stage: string
  overrides?: InfraOverrides
}

export interface Infrastructure {
  [key: string]: any
}

export interface InfrastructureDef {
  type?: string
  spec?: Infrastructure
  provisioner?: ExecutionElementConfig
}

export type InlineTerraformBackendConfigSpec = TerraformBackendConfigSpec & {
  content?: string
}

export type InlineTerraformVarFileSpec = TerraformVarFileSpec & {
  content?: string
}

export interface InputSetValidator {
  validatorType?: 'ALLOWED_VALUES' | 'REGEX'
  parameters?: string
}

export interface InstanceSelectionBase {
  type?: 'Count' | 'Percentage'
  instances?: number
}

export interface InstanceSelectionWrapper {
  type?: 'Count' | 'Percentage'
  spec?: InstanceSelectionBase
}

export type JexlCriteriaSpec = CriteriaSpec & {
  expression: string
}

export type JiraApprovalStepInfo = StepSpecType & {
  connectorRef: string
  issueKey: string
  approvalCriteria: CriteriaSpecWrapper
  rejectionCriteria: CriteriaSpecWrapper
}

export type JiraCreateStepInfo = StepSpecType & {
  connectorRef?: string
  projectKey?: string
  issueType?: string
  fields?: JiraField[]
}

export interface JiraField {
  name?: string
  value: string
}

export type JiraUpdateStepInfo = StepSpecType & {
  connectorRef: string
  issueKey: string
  transitionTo?: TransitionTo
  fields?: JiraField[]
}

export type K8SDirectInfrastructure = Infrastructure & {
  connectorRef?: string
  namespace?: string
  releaseName?: string
}

export type K8sApplyStepInfo = StepSpecType & {
  skipDryRun: ParameterFieldBoolean
  skipSteadyStateCheck?: ParameterFieldBoolean
  filePaths?: string[]
}

export type K8sBGSwapServicesStepInfo = StepSpecType & {
  skipDryRun?: boolean
}

export type K8sBlueGreenStepInfo = StepSpecType & {
  skipDryRun?: ParameterFieldBoolean
}

export type K8sCanaryDeleteStepInfo = StepSpecType & {
  skipDryRun?: boolean
}

export type K8sCanaryStepInfo = StepSpecType & {
  instanceSelection: InstanceSelectionWrapper
  skipDryRun?: ParameterFieldBoolean
}

export type K8sDeleteStepInfo = StepSpecType & {
  deleteResources: DeleteResourcesWrapper
  skipDryRun?: ParameterFieldBoolean
}

export type K8sGcpInfrastructure = Infrastructure & {
  connectorRef?: string
  namespace?: string
  releaseName?: string
  cluster?: string
  metadata?: string
}

export type K8sManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  skipResourceVersioning?: boolean
  metadata?: string
}

export type K8sRollingRollbackStepInfo = StepSpecType & {
  skipDryRun?: ParameterFieldBoolean
}

export type K8sRollingStepInfo = StepSpecType & {
  skipDryRun: boolean
}

export type K8sScaleStepInfo = StepSpecType & {
  instanceSelection: InstanceSelectionWrapper
  workload?: string
  skipDryRun?: ParameterFieldBoolean
  skipSteadyStateCheck?: ParameterFieldBoolean
}

export type KeyValuesCriteriaSpec = CriteriaSpec & {
  matchAnyCondition?: boolean
  conditions: Condition[]
}

export type KubernetesServiceSpec = ServiceSpec & {
  metadata?: string
}

export type KustomizeManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  skipResourceVersioning?: boolean
  pluginPath?: string
  metadata?: string
}

export interface ManifestAttributes {
  [key: string]: any
}

export interface ManifestConfig {
  identifier?: string
  type?: string
  spec?: ManifestAttributes
}

export interface ManifestConfigWrapper {
  manifest?: ManifestConfig
}

export interface ManifestOverrideSetWrapper {
  overrideSet?: ManifestOverrideSets
}

export interface ManifestOverrideSets {
  identifier?: string
  manifests?: ManifestConfigWrapper[]
}

export interface ManualFailureSpecConfig {
  timeout: string
  onTimeout: OnTimeoutConfig
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig
  type: 'ManualIntervention'
}

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsSuccess'
}

export interface NGVariable {
  name?: string
  type?: 'String' | 'Number' | 'Secret'
  required?: boolean
  description?: string
  metadata?: string
}

export interface NGVariableOverrideSetWrapper {
  overrideSet?: NGVariableOverrideSets
}

export interface NGVariableOverrideSets {
  identifier?: string
  variables?: NGVariable[]
}

export type NativeHelmServiceSpec = ServiceSpec & {
  metadata?: string
}

export interface NgPipeline {
  name: string
  identifier: string
  description?: string
  tags?: {
    [key: string]: string
  }
  variables?: NGVariable[]
  ciCodebase?: CodeBase
  stages?: StageElementWrapper[]
  metadata?: string
}

export type NumberNGVariable = NGVariable & {
  type?: 'Number'
  value: number
  default?: number
}

export interface OnFailureConfig {
  errors: string[]
  action: FailureStrategyActionConfig
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig
}

export type OpenshiftManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  skipResourceVersioning?: boolean
  metadata?: string
}

export type OpenshiftParamManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  metadata?: string
}

export type ParallelStageElement = StageElementWrapper & {
  sections: StageElementWrapper[]
  metadata?: string
}

export type ParallelStepElement = ExecutionWrapper & {
  sections: ExecutionWrapper[]
  metadata?: string
}

export type ParallelStepElementConfig = ExecutionWrapperConfig[]

export interface ParameterField {
  expressionValue?: string
  expression?: boolean
  value?: { [key: string]: any }
  typeString?: boolean
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
}

export interface ParameterFieldBoolean {
  expressionValue?: string
  expression?: boolean
  value?: boolean
  typeString?: boolean
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
}

export interface ParameterFieldInteger {
  expressionValue?: string
  expression?: boolean
  value?: number
  typeString?: boolean
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
}

export interface ParameterFieldListTaskSelectorYaml {
  expressionValue?: string
  expression?: boolean
  value?: TaskSelectorYaml[]
  typeString?: boolean
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
}

export interface PatchInstruction {
  type?:
    | 'SetFeatureFlagState'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentsToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
}

export type PercentageInstanceSelection = InstanceSelectionBase & {
  percentage?: ParameterFieldInteger
}

export interface PipelineInfrastructure {
  infrastructureDefinition?: InfrastructureDef
  useFromStage?: InfraUseFromStage
  environment?: EnvironmentYaml
  allowSimultaneousDeployments?: boolean
  infrastructureKey?: string
  environmentRef?: string
}

export type RemoteTerraformVarFileSpec = TerraformVarFileSpec & {
  store?: StoreConfigWrapper
}

export type RemoveSegmentToVariationTargetMapYaml = PatchInstruction & {
  type:
    | 'SetFeatureFlagState'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentsToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
  spec: RemoveSegmentToVariationTargetMapYamlSpec
}

export interface RemoveSegmentToVariationTargetMapYamlSpec {
  variation?: string
  segments?: string[]
}

export type RemoveTargetsToVariationTargetMapYaml = PatchInstruction & {
  type:
    | 'SetFeatureFlagState'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentsToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
  spec: RemoveTargetsToVariationTargetMapYamlSpec
}

export interface RemoveTargetsToVariationTargetMapYamlSpec {
  variation?: string
  targets?: string[]
}

export type ResourceConstraintStepInfo = StepSpecType & {
  name: string
  resourceUnit: string
  acquireMode: 'ENSURE' | 'ACCUMULATE'
  permits: number
  holdingScope: HoldingScope
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig
  type: 'Retry'
}

export interface RetryFailureSpecConfig {
  retryCount: number
  retryIntervals: string[]
  onRetryFailure: OnRetryFailureConfig
}

export type S3StoreConfig = StoreConfig & {
  connectorRef?: string
  bucketName?: string
  region?: string
  folderPath?: string
  metadata?: string
}

export type SecretNGVariable = NGVariable & {
  type?: 'Secret'
  value: string
  default?: string
}

export interface ServiceConfig {
  useFromStage?: ServiceUseFromStage
  service?: ServiceYaml
  serviceRef?: string
  serviceDefinition?: ServiceDefinition
  stageOverrides?: StageOverridesConfig
}

export interface ServiceDefinition {
  type?: string
  spec?: ServiceSpec
}

export interface ServiceOverrides {
  name?: string
  description?: string
}

export interface ServiceSpec {
  variables?: NGVariable[]
  manifests?: ManifestConfigWrapper[]
  artifacts?: ArtifactListConfig
  manifestOverrideSets?: ManifestOverrideSetWrapper[]
  variableOverrideSets?: NGVariableOverrideSetWrapper[]
  artifactOverrideSets?: ArtifactOverrideSetWrapper[]
}

export interface ServiceUseFromStage {
  stage: string
  overrides?: ServiceOverrides
  metadata?: string
}

export interface ServiceYaml {
  identifier: string
  name: string
  description?: string
  tags?: {
    [key: string]: string
  }
}

export type SetFeatureFlagStateYaml = PatchInstruction & {
  type:
    | 'SetFeatureFlagState'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentsToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
  spec: SetFeatureFlagStateYamlSpec
}

export interface SetFeatureFlagStateYamlSpec {
  state?: string
}

export interface ShellScriptBaseSource {
  type?: string
}

export type ShellScriptInlineSource = ShellScriptBaseSource & {
  script?: string
}

export interface ShellScriptSourceWrapper {
  type?: string
  spec?: ShellScriptBaseSource
}

export type ShellScriptStepInfo = StepSpecType & {
  shell: 'Bash' | 'PowerShell'
  source: ShellScriptSourceWrapper
  executionTarget?: ExecutionTarget
  onDelegate: ParameterFieldBoolean
  outputVariables?: NGVariable[]
  environmentVariables?: NGVariable[]
  delegateSelectors?: ParameterFieldListTaskSelectorYaml
  metadata?: string
}

export interface SidecarArtifact {
  identifier?: string
  type: 'Dockerhub' | 'Gcr' | 'Ecr'
  spec?: ArtifactConfig
}

export interface SidecarArtifactWrapper {
  sidecar?: SidecarArtifact
}

export type StageElement = StageElementWrapper & {
  identifier: string
  name?: string
  description?: string
  failureStrategies: FailureStrategyConfig[]
  type?: string
  skipCondition?: string
  metadata?: string
  spec?: StageType
}

export interface StageElementWrapper {
  [key: string]: any
}

export interface StageOverridesConfig {
  variables?: NGVariable[]
  useVariableOverrideSets?: string[]
  useArtifactOverrideSets?: string[]
  artifacts?: ArtifactListConfig
  useManifestOverrideSets?: string[]
  manifests?: ManifestConfigWrapper[]
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StageRollback'
}

export interface StageType {
  identifier: string
}

export type StepElement = ExecutionWrapper & {
  identifier: string
  name?: string
  failureStrategies?: FailureStrategyConfig[]
  type?: string
  skipCondition?: string
  metadata?: string
  spec?: StepSpecType
}

export interface StepElementConfig {
  identifier?: string
  name?: string
  description?: string
  timeout?: string
  failureStrategies?: FailureStrategyConfig[]
  when?: StepWhenCondition
  type?: string
  spec?: StepSpecType
}

export type StepGroupElement = ExecutionWrapper & {
  identifier: string
  name?: string
  failureStrategies?: FailureStrategyConfig[]
  steps: ExecutionWrapper[]
  rollbackSteps?: ExecutionWrapper[]
  metadata?: string
}

export interface StepGroupElementConfig {
  identifier: string
  name?: string
  when?: StepWhenCondition
  failureStrategies?: FailureStrategyConfig[]
  steps: ExecutionWrapperConfig[]
  rollbackSteps?: ExecutionWrapperConfig[]
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StepGroupRollback'
}

export interface StepSpecType {
  [key: string]: any
}

export interface StepWhenCondition {
  stageStatus: 'Success' | 'Failure' | 'All'
  condition?: string
}

export interface StoreConfig {
  [key: string]: any
}

export interface StoreConfigWrapper {
  type?: string
  metadata?: string
  spec?: StoreConfig
}

export type StringNGVariable = NGVariable & {
  type?: 'String'
  value: string
  default?: string
}

export type TagBuildSpec = BuildSpec & {
  tag: string
}

export interface TaskSelectorYaml {
  delegateSelectors?: string
}

export type TerraformApplyStepInfo = StepSpecType & {
  provisionerIdentifier?: string
  metadata?: string
  configuration?: TerrformStepConfiguration
}

export interface TerraformBackendConfig {
  type?: string
  spec?: TerraformBackendConfigSpec
}

export interface TerraformBackendConfigSpec {
  [key: string]: any
}

export interface TerraformConfigFilesWrapper {
  store?: StoreConfigWrapper
}

export type TerraformDestroyStepInfo = StepSpecType & {
  provisionerIdentifier?: string
  metadata?: string
  configuration?: TerrformStepConfiguration
}

export interface TerraformExecutionData {
  workspace?: string
  targets?: string[]
  environmentVariables?: NGVariable[]
  configFiles?: TerraformConfigFilesWrapper
  varFiles?: TerraformVarFileWrapper[]
  backendConfig?: TerraformBackendConfig
}

export interface TerraformPlanExecutionData {
  workspace?: string
  targets?: string[]
  environmentVariables?: NGVariable[]
  command?: 'Apply' | 'Destroy'
  secretManagerRef?: string
  configFiles?: TerraformConfigFilesWrapper
  varFiles?: TerraformVarFileWrapper[]
  backendConfig?: TerraformBackendConfig
}

export type TerraformPlanStepInfo = StepSpecType & {
  provisionerIdentifier?: string
  configuration?: TerraformPlanExecutionData
}

export type TerraformRollbackStepInfo = StepSpecType & {
  provisionerIdentifier: string
}

export interface TerraformVarFile {
  type?: string
  identifier?: string
  spec?: TerraformVarFileSpec
}

export interface TerraformVarFileSpec {
  type?: string
}

export interface TerraformVarFileWrapper {
  varFile?: TerraformVarFile
}

export interface TerrformStepConfiguration {
  type?: 'Inline' | 'InheritFromPlan' | 'InheritFromApply'
  spec?: TerraformExecutionData
}

export interface TransitionTo {
  status: string
  transitionName?: string
}

export type ValuesManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  metadata?: string
}

export interface MergeInputSetRequest {
  inputSetReferences?: string[]
}

export interface ConnectorValidationResult {
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL'
  errors?: ErrorDetail[]
  errorSummary?: string
  testedAt?: number
  delegateId?: string
}

export interface ErrorDetail {
  reason?: string
  message?: string
  code?: number
}

export interface ResponseConnectorValidationResult {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorValidationResult
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  username?: string
  accountname: string
  controllerUrl: string
  accountId: string
  delegateSelectors?: string[]
  passwordRef?: string
  clientSecretRef?: string
  clientId?: string
  authType?: 'UsernamePassword' | 'ApiClientToken'
}

export interface ArtifactoryAuthCredentials {
  [key: string]: any
}

export interface ArtifactoryAuthentication {
  type: 'UsernamePassword' | 'Anonymous'
  spec?: ArtifactoryAuthCredentials
}

export type ArtifactoryConnector = ConnectorConfigDTO & {
  artifactoryServerUrl: string
  auth?: ArtifactoryAuthentication
  delegateSelectors?: string[]
}

export type ArtifactoryUsernamePasswordAuth = ArtifactoryAuthCredentials & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export interface AwsCodeCommitAuthenticationDTO {
  type: 'HTTPS'
  spec: AwsCodeCommitCredentialsDTO
}

export type AwsCodeCommitConnectorDTO = ConnectorConfigDTO & {
  url: string
  authentication: AwsCodeCommitAuthenticationDTO
  delegateSelectors?: string[]
  type: 'Repo' | 'Region'
}

export interface AwsCodeCommitCredentialsDTO {
  [key: string]: any
}

export type AwsCodeCommitHttpsCredentialsDTO = AwsCodeCommitCredentialsDTO & {
  type: 'AWSCredentials'
  spec: AwsCodeCommitHttpsCredentialsSpecDTO
}

export interface AwsCodeCommitHttpsCredentialsSpecDTO {
  [key: string]: any
}

export type AwsCodeCommitSecretKeyAccessKeyDTO = AwsCodeCommitHttpsCredentialsSpecDTO & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export type AwsConnector = ConnectorConfigDTO & {
  credential: AwsCredential
  delegateSelectors?: string[]
}

export interface AwsCredential {
  crossAccountAccess?: CrossAccountAccess
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec?: AwsCredentialSpec
}

export interface AwsCredentialSpec {
  [key: string]: any
}

export interface AwsCurAttributes {
  reportName: string
  s3BucketName: string
}

export interface AwsKmsConnectorCredential {
  type: 'AssumeIAMRole' | 'AssumeSTSRole' | 'ManualConfig'
  spec?: AwsKmsCredentialSpec
}

export type AwsKmsConnectorDTO = ConnectorConfigDTO & {
  credential?: AwsKmsConnectorCredential
  kmsArn?: string
  region?: string
  default?: boolean
}

export interface AwsKmsCredentialSpec {
  [key: string]: any
}

export type AwsKmsCredentialSpecAssumeIAM = AwsKmsCredentialSpec & {
  delegateSelectors: string[]
}

export type AwsKmsCredentialSpecAssumeSTS = AwsKmsCredentialSpec & {
  delegateSelectors: string[]
  roleArn: string
  externalName?: string
  assumeStsRoleDuration?: number
}

export type AwsKmsCredentialSpecManualConfig = AwsKmsCredentialSpec & {
  accessKey: string
  secretKey: string
}

export type AwsManualConfigSpec = AwsCredentialSpec & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export interface BillingExportSpec {
  storageAccountName: string
  containerName: string
  directoryName: string
}

export interface BitbucketApiAccess {
  type: 'UsernameToken'
  spec: BitbucketApiAccessSpecDTO
}

export interface BitbucketApiAccessSpecDTO {
  [key: string]: any
}

export interface BitbucketAuthentication {
  type: 'Http' | 'Ssh'
  spec: BitbucketCredentialsDTO
}

export type BitbucketConnector = ConnectorConfigDTO & {
  url: string
  authentication: BitbucketAuthentication
  apiAccess?: BitbucketApiAccess
  delegateSelectors?: string[]
  type: 'Account' | 'Repo'
}

export interface BitbucketCredentialsDTO {
  [key: string]: any
}

export type BitbucketHttpCredentials = BitbucketCredentialsDTO & {
  type: 'UsernamePassword'
  spec: BitbucketHttpCredentialsSpecDTO
}

export interface BitbucketHttpCredentialsSpecDTO {
  [key: string]: any
}

export type BitbucketSshCredentials = BitbucketCredentialsDTO & {
  sshKeyRef: string
}

export type BitbucketUsernamePassword = BitbucketHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type BitbucketUsernameTokenApiAccess = BitbucketApiAccessSpecDTO & {
  username?: string
  usernameRef?: string
  tokenRef: string
}

export type CEAwsConnector = ConnectorConfigDTO & {
  crossAccountAccess: CrossAccountAccess
  curAttributes?: AwsCurAttributes
  featuresEnabled?: ('CUR' | 'EVENTS' | 'OPTIMIZATION')[]
}

export type CEAzureConnector = ConnectorConfigDTO & {
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION')[]
  tenantId: string
  subscriptionId: string
  billingExportSpec?: BillingExportSpec
}

export type CEKubernetesClusterConfig = ConnectorConfigDTO & {
  connectorRef: string
}

export interface ConnectorActivityDetails {
  lastActivityTime?: number
}

export interface ConnectorConfigDTO {
  [key: string]: any
}

export interface ConnectorConnectivityDetails {
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL'
  errorSummary?: string
  errors?: ErrorDetail[]
  testedAt?: number
  lastTestedAt?: number
  lastConnectedAt?: number
}

export interface ConnectorInfoDTO {
  name: string
  identifier: string
  description?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  type:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
  spec: ConnectorConfigDTO
}

export interface ConnectorResponse {
  connector?: ConnectorInfoDTO
  createdAt?: number
  lastModifiedAt?: number
  status?: ConnectorConnectivityDetails
  activityDetails?: ConnectorActivityDetails
  harnessManaged?: boolean
  gitDetails?: EntityGitDetails
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string
  externalId?: string
}

export interface CustomCommitAttributes {
  authorName?: string
  authorEmail?: string
  commitMessage?: string
}

export interface DockerAuthCredentialsDTO {
  [key: string]: any
}

export interface DockerAuthenticationDTO {
  type: 'UsernamePassword' | 'Anonymous'
  spec?: DockerAuthCredentialsDTO
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  dockerRegistryUrl: string
  providerType: 'DockerHub' | 'Harbor' | 'Quay' | 'Other'
  auth?: DockerAuthenticationDTO
  delegateSelectors?: string[]
}

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export interface EntityGitDetails {
  objectId?: string
  branch?: string
  repoIdentifier?: string
}

export interface GcpBillingExportSpec {
  projectId: string
  datasetId: string
}

export type GcpCloudCostConnector = ConnectorConfigDTO & {
  featuresEnabled?: 'BILLING'[]
  billingExportSpec?: GcpBillingExportSpec
}

export type GcpConnector = ConnectorConfigDTO & {
  credential?: GcpConnectorCredential
  delegateSelectors?: string[]
}

export interface GcpConnectorCredential {
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec?: GcpCredentialSpec
}

export interface GcpCredentialSpec {
  [key: string]: any
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  projectId?: string
  region?: string
  keyRing?: string
  keyName?: string
  credentials?: string[]
  default?: boolean
}

export type GcpManualDetails = GcpCredentialSpec & {
  secretKeyRef: string
}

export interface GitAuthenticationDTO {
  [key: string]: any
}

export type GitConfigDTO = ConnectorConfigDTO & {
  url: string
  branchName?: string
  delegateSelectors?: string[]
  type: 'Http' | 'Ssh'
  connectionType: 'Account' | 'Repo'
  spec: GitAuthenticationDTO
  gitSync?: GitSyncConfig
}

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyRef: string
}

export interface GitSyncConfig {
  identifier?: string
  name?: string
  projectIdentifier?: string
  orgIdentifier?: string
  gitConnectorRef?: string
  repo?: string
  branch?: string
  gitConnectorType: 'Github' | 'Gitlab' | 'Bitbucket'
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[]
}

export interface GithubApiAccess {
  type: 'GithubApp' | 'Token'
  spec?: GithubApiAccessSpecDTO
}

export interface GithubApiAccessSpecDTO {
  [key: string]: any
}

export type GithubAppSpec = GithubApiAccessSpecDTO & {
  installationId: string
  applicationId: string
  privateKeyRef: string
}

export interface GithubAuthentication {
  type: 'Http' | 'Ssh'
  spec: GithubCredentialsDTO
}

export type GithubConnector = ConnectorConfigDTO & {
  url: string
  authentication: GithubAuthentication
  apiAccess?: GithubApiAccess
  delegateSelectors?: string[]
  type: 'Account' | 'Repo'
}

export interface GithubCredentialsDTO {
  [key: string]: any
}

export type GithubHttpCredentials = GithubCredentialsDTO & {
  type: 'UsernamePassword' | 'UsernameToken'
  spec: GithubHttpCredentialsSpecDTO
}

export interface GithubHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GithubSshCredentials = GithubCredentialsDTO & {
  sshKeyRef: string
}

export type GithubTokenSpec = GithubApiAccessSpecDTO & {
  tokenRef: string
}

export type GithubUsernamePassword = GithubHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type GithubUsernameToken = GithubHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  tokenRef: string
}

export interface GitlabApiAccess {
  type: 'Token'
  spec?: GitlabApiAccessSpecDTO
}

export interface GitlabApiAccessSpecDTO {
  [key: string]: any
}

export interface GitlabAuthentication {
  type: 'Http' | 'Ssh'
  spec: GitlabCredentialsDTO
}

export type GitlabConnector = ConnectorConfigDTO & {
  url: string
  authentication: GitlabAuthentication
  apiAccess?: GitlabApiAccess
  delegateSelectors?: string[]
  type: 'Account' | 'Repo'
}

export interface GitlabCredentialsDTO {
  [key: string]: any
}

export type GitlabHttpCredentials = GitlabCredentialsDTO & {
  type: 'UsernamePassword' | 'UsernameToken' | 'Kerberos'
  spec: GitlabHttpCredentialsSpecDTO
}

export interface GitlabHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GitlabKerberos = GitlabHttpCredentialsSpecDTO & {
  kerberosKeyRef: string
}

export type GitlabSshCredentials = GitlabCredentialsDTO & {
  sshKeyRef: string
}

export type GitlabTokenSpec = GitlabApiAccessSpecDTO & {
  tokenRef: string
}

export type GitlabUsernamePassword = GitlabHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type GitlabUsernameToken = GitlabHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  tokenRef: string
}

export interface HttpHelmAuthCredentialsDTO {
  [key: string]: any
}

export interface HttpHelmAuthenticationDTO {
  type: 'UsernamePassword' | 'Anonymous'
  spec?: HttpHelmAuthCredentialsDTO
}

export type HttpHelmConnectorDTO = ConnectorConfigDTO & {
  helmRepoUrl: string
  auth?: HttpHelmAuthenticationDTO
  delegateSelectors?: string[]
}

export type HttpHelmUsernamePasswordDTO = HttpHelmAuthCredentialsDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type JiraConnector = ConnectorConfigDTO & {
  jiraUrl: string
  username?: string
  passwordRef: string
  delegateSelectors?: string[]
}

export interface KubernetesAuthCredentialDTO {
  [key: string]: any
}

export interface KubernetesAuthDTO {
  type: 'UsernamePassword' | 'ClientKeyCert' | 'ServiceAccount' | 'OpenIdConnect'
  spec: KubernetesAuthCredentialDTO
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string
  clientCertRef: string
  clientKeyRef: string
  clientKeyPassphraseRef: string
  clientKeyAlgo?: string
}

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential: KubernetesCredentialDTO
  delegateSelectors?: string[]
}

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  masterUrl: string
  auth: KubernetesAuthDTO
}

export interface KubernetesCredentialDTO {
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec?: KubernetesCredentialSpecDTO
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any
}

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcIssuerUrl?: string
  oidcUsername?: string
  oidcUsernameRef?: string
  oidcClientIdRef: string
  oidcPasswordRef: string
  oidcSecretRef?: string
  oidcScopes?: string
}

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  serviceAccountTokenRef: string
}

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean
}

export type NewRelicConnectorDTO = ConnectorConfigDTO & {
  newRelicAccountId: string
  url: string
  apiKeyRef: string
  delegateSelectors?: string[]
}

export interface NexusAuthCredentials {
  [key: string]: any
}

export interface NexusAuthentication {
  type: 'UsernamePassword' | 'Anonymous'
  spec?: NexusAuthCredentials
}

export type NexusConnector = ConnectorConfigDTO & {
  nexusServerUrl: string
  version: string
  auth?: NexusAuthentication
  delegateSelectors?: string[]
}

export type NexusUsernamePasswordAuth = NexusAuthCredentials & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type PrometheusConnectorDTO = ConnectorConfigDTO & {
  url: string
  delegateSelectors?: string[]
}

export interface ResponseConnectorResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  splunkUrl?: string
  username?: string
  accountId: string
  delegateSelectors?: string[]
  passwordRef: string
}

export type VaultConnectorDTO = ConnectorConfigDTO & {
  authToken?: string
  basePath?: string
  vaultUrl?: string
  renewalIntervalMinutes?: number
  secretEngineManuallyConfigured?: boolean
  secretEngineName?: string
  appRoleId?: string
  secretId?: string
  secretEngineVersion?: number
  default?: boolean
  readOnly?: boolean
  accessType?: 'APP_ROLE' | 'TOKEN'
}

export interface Connector {
  connector?: ConnectorInfoDTO
}

export interface ResponseBoolean {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: boolean
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Page {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: { [key: string]: any }[]
  number?: number
  first?: boolean
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  empty?: boolean
}

export interface PageConnectorResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ConnectorResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageConnectorResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageConnectorResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type ConnectorFilterProperties = FilterProperties & {
  connectorNames?: string[]
  connectorIdentifiers?: string[]
  description?: string
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
  )[]
  categories?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL')[]
  inheritingCredentialsFromDelegate?: boolean
}

export interface ConnectorCatalogueItem {
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  connectors?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
  )[]
}

export interface ConnectorCatalogueResponse {
  catalogue?: ConnectorCatalogueItem[]
}

export interface ResponseConnectorCatalogueResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorCatalogueResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ConnectorStatistics {
  typeStats?: ConnectorTypeStatistics[]
  statusStats?: ConnectorStatusStatistics[]
}

export interface ConnectorStatusStatistics {
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL'
  count?: number
}

export interface ConnectorTypeStatistics {
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
  count?: number
}

export interface ResponseConnectorStatistics {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorStatistics
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListConnectorResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorResponse[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type AuditFilterProperties = FilterProperties & {
  scopes?: ResourceScopeDTO[]
  resources?: ResourceDTO[]
  modules?: ('CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE')[]
  actions?: (
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
  )[]
  environments?: Environment[]
  principals?: Principal[]
  startTime?: number
  endTime?: number
}

export interface Environment {
  type: 'PreProduction' | 'Production'
  identifier: string
}

export interface FilterDTO {
  name: string
  identifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
}

export interface FilterProperties {
  tags?: {
    [key: string]: string
  }
  filterType?: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export interface NGTag {
  key: string
  value: string
}

export type PipelineFilterProperties = FilterProperties & {
  pipelineTags?: NGTag[]
  pipelineIdentifiers?: string[]
  name?: string
  description?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
}

export interface Principal {
  identifier: string
  type: 'USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE'
}

export interface ResourceDTO {
  type: string
  identifier: string
  labels?: {
    [key: string]: string
  }
}

export interface ResourceScopeDTO {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  labels?: {
    [key: string]: string
  }
}

export interface ResponseFilterDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: FilterDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageFilterDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: FilterDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageFilterDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitBranchDTO {
  branchName?: string
  branchSyncStatus?: 'SYNCED' | 'SYNCING' | 'UNSYNCED'
}

export interface GitBranchListDTO {
  defaultBranch?: GitBranchDTO
  branches?: PageGitBranchDTO
}

export interface PageGitBranchDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: GitBranchDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponseGitBranchListDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GitBranchListDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitSyncEntityDTO {
  entityName?: string
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  entityIdentifier?: string
  gitConnectorId?: string
  repositoryName?: string
  branch?: string
  folderPath?: string
  entityGitPath?: string
  repoProviderType?: 'github' | 'gitlab' | 'bitbucket' | 'unknown'
  accountId?: string
}

export interface GitSyncEntityListDTO {
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  count?: number
  gitSyncEntities?: GitSyncEntityDTO[]
}

export interface PageGitSyncEntityListDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: GitSyncEntityListDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageGitSyncEntityListDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageGitSyncEntityListDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListGitSyncEntityListDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GitSyncEntityListDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitEntityBranchFilterSummaryProperties {
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  entityTypes?: (
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  )[]
  searchTerm?: string
}

export interface GitSyncRepoFiles {
  gitSyncConfigIdentifier?: string
  gitSyncEntityLists?: GitSyncEntityListDTO[]
}

export interface GitSyncRepoFilesList {
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  gitSyncRepoFilesList?: GitSyncRepoFiles[]
}

export interface ResponseGitSyncRepoFilesList {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GitSyncRepoFilesList
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitEntityFilterProperties {
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  gitSyncConfigIdentifiers?: string[]
  entityTypes?: (
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  )[]
  searchTerm?: string
}

export interface GitFileContent {
  content?: string
  objectId?: string
}

export interface ResponseGitFileContent {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GitFileContent
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitSyncFolderConfigDTO {
  rootFolder?: string
  isDefault?: boolean
  identifier?: string
  enabled?: boolean
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export type CDModuleLicenseDTO = ModuleLicenseDTO & {
  deploymentUnits?: {
    [key: string]: number
  }
}

export type CEModuleLicenseDTO = ModuleLicenseDTO & {}

export type CFModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfUsers?: number
  numberOfClientMAUs?: number
  updateChannels?: ('POLLING' | 'STREAMING')[]
}

export type CIModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfCommitters?: number
}

export type CVModuleLicenseDTO = ModuleLicenseDTO & {}

export interface ModuleLicenseDTO {
  id?: string
  accountIdentifier?: string
  moduleType?: 'CD' | 'CI' | 'CV' | 'CE' | 'CF'
  edition?: 'FREE' | 'TEAM' | 'ENTERPRISE'
  licenseType?: 'TRIAL' | 'PAID'
  startTime?: number
  expiryTime?: number
  status?: 'ACTIVE' | 'DELETED' | 'EXPIRED'
  createdAt?: number
  lastModifiedAt?: number
}

export interface ResponseModuleLicenseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ModuleLicenseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface AccountLicensesDTO {
  accountId?: string
  moduleLicenses?: {
    [key: string]: ModuleLicenseDTO
  }
}

export interface ResponseAccountLicensesDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: AccountLicensesDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StartTrialRequestDTO {
  moduleType: 'CD' | 'CI' | 'CV' | 'CE' | 'CF'
}

export interface RestResponseVersionPackage {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: VersionPackage
  responseMessages?: ResponseMessage[]
}

export interface RuntimeInfo {
  primary?: boolean
  primaryVersion?: string
  deployMode?: string
}

export interface VersionInfo {
  version?: string
  buildNo?: string
  gitCommit?: string
  gitBranch?: string
  timestamp?: string
}

export interface VersionPackage {
  versionInfo?: VersionInfo
  runtimeInfo?: RuntimeInfo
}

export interface PageRoleAssignmentResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: RoleAssignmentResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageRoleAssignmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageRoleAssignmentResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RoleAssignment {
  identifier?: string
  resourceGroupIdentifier: string
  roleIdentifier: string
  principal: Principal
  disabled?: boolean
  managed?: boolean
}

export interface RoleAssignmentResponse {
  roleAssignment: RoleAssignment
  scope: ScopeDTO
  createdAt?: number
  lastModifiedAt?: number
  harnessManaged?: boolean
}

export interface ScopeDTO {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface RoleAssignmentFilter {
  resourceGroupFilter?: string[]
  roleFilter?: string[]
  principalTypeFilter?: ('USER' | 'USER_GROUP' | 'API_KEY' | 'SERVICE')[]
  principalFilter?: Principal[]
  harnessManagedFilter?: boolean[]
  disabledFilter?: boolean[]
}

export interface ResponseRoleAssignmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleAssignmentResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListRoleAssignmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleAssignmentResponse[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface BatchRoleAssignmentCreateRequest {
  roleAssignments?: RoleAssignment[]
}

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: boolean
  responseMessages?: ResponseMessage[]
}

export interface AccountEvent {
  accountEventType?:
    | 'APP_CREATED'
    | 'SERVICE_CREATED'
    | 'ENV_CREATED'
    | 'WORKFLOW_CREATED'
    | 'WORKFLOW_DEPLOYED'
    | 'PIPELINE_DEPLOYED'
    | 'DELEGATE_INSTALLED'
    | 'CLOUD_PROVIDER_CREATED'
    | 'ARTIFACT_REPO_CREATED'
    | 'PIPELINE_CREATED'
    | 'ARTIFACT_STREAM_ADDED'
    | 'INFRA_MAPPING_ADDED'
    | 'INFRA_DEFINITION_ADDED'
    | 'CUSTOM'
  customMsg?: string
  category?: string
  properties?: {
    [key: string]: string
  }
}

export interface AccountPermissions {
  permissions?: (
    | 'ACCOUNT'
    | 'LOGGED_IN'
    | 'DELEGATE'
    | 'NONE'
    | 'APP'
    | 'ALL_APP_ENTITIES'
    | 'ENV'
    | 'SERVICE'
    | 'WORKFLOW'
    | 'PIPELINE'
    | 'DEPLOYMENT'
    | 'APPLICATION_CREATE_DELETE'
    | 'USER_PERMISSION_MANAGEMENT'
    | 'ACCOUNT_MANAGEMENT'
    | 'PROVISIONER'
    | 'TEMPLATE_MANAGEMENT'
    | 'USER_PERMISSION_READ'
    | 'AUDIT_VIEWER'
    | 'TAG_MANAGEMENT'
    | 'CE_ADMIN'
    | 'CE_VIEWER'
    | 'MANAGE_CLOUD_PROVIDERS'
    | 'MANAGE_CONNECTORS'
    | 'MANAGE_APPLICATIONS'
    | 'MANAGE_APPLICATION_STACKS'
    | 'MANAGE_DELEGATES'
    | 'MANAGE_ALERT_NOTIFICATION_RULES'
    | 'MANAGE_DELEGATE_PROFILES'
    | 'MANAGE_CONFIG_AS_CODE'
    | 'MANAGE_SECRETS'
    | 'MANAGE_SECRET_MANAGERS'
    | 'MANAGE_SSH_AND_WINRM'
    | 'MANAGE_AUTHENTICATION_SETTINGS'
    | 'MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'VIEW_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'MANAGE_IP_WHITELIST'
    | 'MANAGE_IP_WHITELISTING'
    | 'MANAGE_DEPLOYMENT_FREEZES'
    | 'MANAGE_PIPELINE_GOVERNANCE_STANDARDS'
    | 'MANAGE_API_KEYS'
    | 'MANAGE_TAGS'
    | 'MANAGE_CUSTOM_DASHBOARDS'
    | 'CREATE_CUSTOM_DASHBOARDS'
  )[]
}

export interface AccountPreferences {
  delegateSecretsCacheTTLInHours?: number
}

export interface AppPermission {
  permissionType?:
    | 'ACCOUNT'
    | 'LOGGED_IN'
    | 'DELEGATE'
    | 'NONE'
    | 'APP'
    | 'ALL_APP_ENTITIES'
    | 'ENV'
    | 'SERVICE'
    | 'WORKFLOW'
    | 'PIPELINE'
    | 'DEPLOYMENT'
    | 'APPLICATION_CREATE_DELETE'
    | 'USER_PERMISSION_MANAGEMENT'
    | 'ACCOUNT_MANAGEMENT'
    | 'PROVISIONER'
    | 'TEMPLATE_MANAGEMENT'
    | 'USER_PERMISSION_READ'
    | 'AUDIT_VIEWER'
    | 'TAG_MANAGEMENT'
    | 'CE_ADMIN'
    | 'CE_VIEWER'
    | 'MANAGE_CLOUD_PROVIDERS'
    | 'MANAGE_CONNECTORS'
    | 'MANAGE_APPLICATIONS'
    | 'MANAGE_APPLICATION_STACKS'
    | 'MANAGE_DELEGATES'
    | 'MANAGE_ALERT_NOTIFICATION_RULES'
    | 'MANAGE_DELEGATE_PROFILES'
    | 'MANAGE_CONFIG_AS_CODE'
    | 'MANAGE_SECRETS'
    | 'MANAGE_SECRET_MANAGERS'
    | 'MANAGE_SSH_AND_WINRM'
    | 'MANAGE_AUTHENTICATION_SETTINGS'
    | 'MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'VIEW_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'MANAGE_IP_WHITELIST'
    | 'MANAGE_IP_WHITELISTING'
    | 'MANAGE_DEPLOYMENT_FREEZES'
    | 'MANAGE_PIPELINE_GOVERNANCE_STANDARDS'
    | 'MANAGE_API_KEYS'
    | 'MANAGE_TAGS'
    | 'MANAGE_CUSTOM_DASHBOARDS'
    | 'CREATE_CUSTOM_DASHBOARDS'
  appFilter?: GenericEntityFilter
  entityFilter?: Filter
  actions?: (
    | 'ALL'
    | 'CREATE'
    | 'READ'
    | 'UPDATE'
    | 'DELETE'
    | 'EXECUTE'
    | 'EXECUTE_WORKFLOW'
    | 'EXECUTE_PIPELINE'
    | 'EXECUTE_WORKFLOW_ROLLBACK'
    | 'DEFAULT'
  )[]
}

export interface CeLicenseInfo {
  licenseType?: 'FULL_TRIAL' | 'LIMITED_TRIAL' | 'PAID'
  expiryTime?: number
}

export interface DelegateConfiguration {
  delegateVersions?: string[]
}

export interface EmbeddedUser {
  uuid?: string
  name?: string
  email?: string
}

export type EnvFilter = Filter & {
  filterTypes?: string[]
}

export interface Filter {
  ids?: string[]
}

export type GenericEntityFilter = Filter & {
  filterType?: string
}

export interface LicenseInfo {
  accountType?: string
  accountStatus?: string
  expiryTime?: number
  licenseUnits?: number
}

export interface LoginSettings {
  uuid: string
  accountId: string
  lastUpdatedBy?: EmbeddedUser
  lastUpdatedAt?: number
  userLockoutPolicy: UserLockoutPolicy
  passwordExpirationPolicy: PasswordExpirationPolicy
  passwordStrengthPolicy: PasswordStrengthPolicy
}

export interface NotificationSettings {
  useIndividualEmails?: boolean
  sendMailToNewMembers?: boolean
  emailAddresses: string[]
  slackConfig: SlackNotificationSetting
  pagerDutyIntegrationKey?: string
  microsoftTeamsWebhookUrl?: string
}

export interface PasswordExpirationPolicy {
  enabled?: boolean
  daysBeforePasswordExpires?: number
  daysBeforeUserNotifiedOfPasswordExpiration?: number
}

export interface PasswordStrengthPolicy {
  enabled?: boolean
  minNumberOfCharacters?: number
  minNumberOfUppercaseCharacters?: number
  minNumberOfLowercaseCharacters?: number
  minNumberOfSpecialCharacters?: number
  minNumberOfDigits?: number
}

export interface RestResponseLoginSettings {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LoginSettings
  responseMessages?: ResponseMessage[]
}

export interface SlackNotificationSetting {
  name?: string
  outgoingWebhookUrl: string
}

export interface TechStack {
  category?: string
  technology?: string
}

export interface TrialSignupOptions {
  productsSelected?: ('CD' | 'CE' | 'CI')[]
  assistedOption?: boolean
}

export interface UserGroup {
  uuid: string
  appId: string
  createdBy?: EmbeddedUser
  createdAt?: number
  lastUpdatedBy?: EmbeddedUser
  lastUpdatedAt: number
  name?: string
  description?: string
  linkedSsoType?: 'SAML' | 'LDAP' | 'OAUTH'
  linkedSsoId?: string
  linkedSsoDisplayName?: string
  ssoGroupId?: string
  ssoGroupName?: string
  importedByScim?: boolean
  accountId?: string
  memberIds?: string[]
  members?: User[]
  appPermissions?: AppPermission[]
  accountPermissions?: AccountPermissions
  notificationSettings?: NotificationSettings
  default?: boolean
  ssoLinked?: boolean
}

export interface UserLockoutInfo {
  numberOfFailedLoginAttempts?: number
  userLockedAt?: number
}

export interface UserLockoutPolicy {
  enableLockoutPolicy?: boolean
  numberOfFailedAttemptsBeforeLockout?: number
  lockOutPeriod?: number
  notifyUser?: boolean
  userGroupsToNotify?: UserGroup[]
}

export interface UtmInfo {
  utmSource?: string
  utmContent?: string
  utmMedium?: string
  utmTerm?: string
  utmCampaign?: string
}

export type WorkflowFilter = Filter & {
  filterTypes?: string[]
}

export interface AuthenticationSettingsResponse {
  ngAuthSettings?: NGAuthSettings[]
  whitelistedDomains?: string[]
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  twoFactorEnabled?: boolean
}

export type LDAPSettings = NGAuthSettings & {
  connectionSettings: LdapConnectionSettings
  userSettingsList?: LdapUserSettings[]
  groupSettingsList?: LdapGroupSettings[]
}

export interface LdapConnectionSettings {
  host: string
  port?: number
  sslEnabled?: boolean
  referralsEnabled?: boolean
  maxReferralHops?: number
  bindDN?: string
  bindPassword?: string
  connectTimeout?: number
  responseTimeout?: number
}

export interface LdapGroupSettings {
  baseDN?: string
  searchFilter?: string
  nameAttr?: string
  descriptionAttr?: string
  userMembershipAttr?: string
  referencedUserAttr?: string
}

export interface LdapUserSettings {
  baseDN?: string
  searchFilter?: string
  emailAttr?: string
  displayNameAttr?: string
  groupMembershipAttr?: string
}

export interface NGAuthSettings {
  settingsType?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export interface OAuthSettings {
  filter?: string
  allowedProviders?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
  settingsType?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export interface RestResponseAuthenticationSettingsResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: AuthenticationSettingsResponse
  responseMessages?: ResponseMessage[]
}

export type SAMLSettings = NGAuthSettings & {
  origin: string
  logoutUrl?: string
  groupMembershipAttr?: string
  displayName?: string
  authorizationEnabled?: boolean
}

export type UsernamePasswordSettings = NGAuthSettings & {
  loginSettings: LoginSettings
}

export interface TwoFactorAdminOverrideSettings {
  adminOverrideTwoFactorEnabled?: boolean
}

export interface RestResponsePasswordStrengthPolicy {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: PasswordStrengthPolicy
  responseMessages?: ResponseMessage[]
}

export type LdapSettings = SSOSettings & {
  connectionSettings: LdapConnectionSettings
  userSettings?: LdapUserSettings
  groupSettings?: LdapGroupSettings
  userSettingsList?: LdapUserSettings[]
  groupSettingsList?: LdapGroupSettings[]
}

export type OauthSettings = SSOSettings & {
  filter?: string
  allowedProviders?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
}

export interface RestResponseSSOConfig {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: SSOConfig
  responseMessages?: ResponseMessage[]
}

export interface SSOConfig {
  accountId?: string
  ssoSettings?: SSOSettings[]
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export interface SSOSettings {
  uuid: string
  appId: string
  createdBy?: EmbeddedUser
  createdAt?: number
  lastUpdatedBy?: EmbeddedUser
  lastUpdatedAt: number
  type: 'SAML' | 'LDAP' | 'OAUTH'
  displayName?: string
  url?: string
  accountId?: string
}

export type SamlSettings = SSOSettings & {
  accountId: string
  origin: string
  logoutUrl?: string
  groupMembershipAttr?: string
  authorizationEnabled?: boolean
}

export interface LoginTypeResponse {
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  showCaptcha?: boolean
  defaultExperience?: 'NG' | 'CG'
  ssorequest?: SSORequest
  oauthEnabled?: boolean
}

export interface RestResponseLoginTypeResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LoginTypeResponse
  responseMessages?: ResponseMessage[]
}

export interface SSORequest {
  oauthProviderType?: 'AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN'
  idpRedirectUrl?: string
  oauthProviderTypes?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
}

export interface DashboardWorkloadDeployment {
  workloadDeploymentInfoList?: WorkloadDeploymentInfo[]
}

export interface ResponseDashboardWorkloadDeployment {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DashboardWorkloadDeployment
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface WorkloadCountInfo {
  count?: number
}

export interface WorkloadDateCountInfo {
  date?: string
  execution?: WorkloadCountInfo
}

export interface WorkloadDeploymentInfo {
  serviceName?: string
  lastExecuted?: string
  lastStatus?: string
  deploymentType?: string
  totalDeployments?: number
  percentSuccess?: number
  rateSuccess?: number
  workload?: WorkloadDateCountInfo[]
}

export interface Deployment {
  count?: number
}

export interface DeploymentDateAndCount {
  time?: string
  deployments?: Deployment
}

export interface DeploymentInfo {
  count?: number
  rate?: number
  countList?: DeploymentDateAndCount[]
}

export interface HealthDeploymentDashboard {
  healthDeploymentInfo?: HealthDeploymentInfo
}

export interface HealthDeploymentInfo {
  total?: TotalDeploymentInfo
  success?: DeploymentInfo
  failure?: DeploymentInfo
}

export interface ResponseHealthDeploymentDashboard {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: HealthDeploymentDashboard
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface TotalDeploymentInfo {
  count?: number
  production?: number
  nonProduction?: number
  countList?: DeploymentDateAndCount[]
}

export interface DeploymentCount {
  total?: number
  success?: number
  failure?: number
}

export interface ExecutionDeployment {
  time?: string
  deployments?: DeploymentCount
}

export interface ExecutionDeploymentInfo {
  executionDeploymentList?: ExecutionDeployment[]
}

export interface ResponseExecutionDeploymentInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ExecutionDeploymentInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DashboardDeploymentActiveFailedRunningInfo {
  failure?: DeploymentStatusInfo[]
  pending?: DeploymentStatusInfo[]
  active?: DeploymentStatusInfo[]
}

export interface DeploymentStatusInfo {
  name?: string
  startTs?: string
  endTs?: string
  status?: string
  serviceInfoList?: ServiceDeploymentInfo[]
}

export interface ResponseDashboardDeploymentActiveFailedRunningInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DashboardDeploymentActiveFailedRunningInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceDeploymentInfo {
  serviceName?: string
  serviceTag?: string
}

export interface Activity {
  accountIdentifier?: string
  referredEntity?: EntityDetail
  type: 'CONNECTIVITY_CHECK' | 'ENTITY_USAGE' | 'ENTITY_CREATION' | 'ENTITY_UPDATE'
  activityStatus: 'SUCCESS' | 'FAILED'
  detail?: ActivityDetail
  activityTime: number
  description?: string
}

export interface ActivityDetail {
  [key: string]: any
}

export interface EntityDetail {
  type?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  entityRef?: EntityReference
  name?: string
}

export interface EntityReference {
  default?: boolean
  repoIdentifier?: string
  branch?: string
  identifier?: string
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
}

export type IdentifierRef = EntityReference & {
  scope?: 'account' | 'org' | 'project' | 'unknown'
  metadata?: {
    [key: string]: string
  }
  isDefault?: boolean
}

export type InputSetReference = EntityReference & {
  pipelineIdentifier?: string
  isDefault?: boolean
}

export interface PageActivity {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: Activity[]
  number?: number
  first?: boolean
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  empty?: boolean
}

export interface Pageable {
  offset?: number
  pageSize?: number
  paged?: boolean
  unpaged?: boolean
  pageNumber?: number
  sort?: Sort
}

export interface ResponsePageActivity {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageActivity
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Sort {
  sorted?: boolean
  unsorted?: boolean
  empty?: boolean
}

export interface ResponseActivity {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: Activity
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ConnectivityCheckSummary {
  successCount?: number
  failureCount?: number
  startTime?: number
  endTime?: number
}

export interface ResponseConnectivityCheckSummary {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectivityCheckSummary
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ActivitySummary {
  get_id?: number
  startTime?: number
  endTime?: number
  heartBeatFailuresCount?: number
  successfulActivitiesCount?: number
  failedActivitiesCount?: number
}

export interface PageActivitySummary {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: ActivitySummary[]
  number?: number
  first?: boolean
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  empty?: boolean
}

export interface ResponsePageActivitySummary {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageActivitySummary
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DockerBuildDetailsDTO {
  tag?: string
  buildUrl?: string
  metadata?: {
    [key: string]: string
  }
  labels?: {
    [key: string]: string
  }
  imagePath?: string
}

export interface DockerResponseDTO {
  buildDetailsList?: DockerBuildDetailsDTO[]
}

export interface ResponseDockerResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DockerResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DockerRequestDTO {
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface ResponseDockerBuildDetailsDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DockerBuildDetailsDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EcrBuildDetailsDTO {
  tag?: string
  buildUrl?: string
  metadata?: {
    [key: string]: string
  }
  labels?: {
    [key: string]: string
  }
  imagePath?: string
}

export interface EcrResponseDTO {
  buildDetailsList?: EcrBuildDetailsDTO[]
}

export interface ResponseEcrResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EcrResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EcrRequestDTO {
  tag?: string
  tagRegex?: string
  tagsList?: string[]
  region?: string
}

export interface ResponseEcrBuildDetailsDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EcrBuildDetailsDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GcrBuildDetailsDTO {
  tag?: string
  buildUrl?: string
  metadata?: {
    [key: string]: string
  }
  labels?: {
    [key: string]: string
  }
  imagePath?: string
}

export interface GcrResponseDTO {
  buildDetailsList?: GcrBuildDetailsDTO[]
}

export interface ResponseGcrResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GcrResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GcrRequestDTO {
  tag?: string
  tagRegex?: string
  tagsList?: string[]
  registryHostname?: string
}

export interface ResponseGcrBuildDetailsDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GcrBuildDetailsDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DelegateProfileDetailsNg {
  uuid?: string
  accountId?: string
  name?: string
  description?: string
  primary?: boolean
  approvalRequired?: boolean
  startupScript?: string
  scopingRules?: ScopingRuleDetailsNg[]
  selectors?: string[]
  createdBy?: EmbeddedUserDetails
  lastUpdatedBy?: EmbeddedUserDetails
  createdAt?: number
  lastUpdatedAt?: number
  identifier?: string
  numberOfDelegates?: number
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface EmbeddedUserDetails {
  uuid?: string
  name?: string
  email?: string
}

export interface RestResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateProfileDetailsNg
  responseMessages?: ResponseMessage[]
}

export interface ScopingRuleDetailsNg {
  description?: string
  environmentTypeId?: string
  environmentIds?: string[]
}

export interface RestResponseVoid {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: Void
  responseMessages?: ResponseMessage[]
}

export interface Void {
  [key: string]: any
}

export interface RestResponsePageResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateProfileDetailsNg[]
  responseMessages?: ResponseMessage[]
}

export interface ContextElement {
  uuid?: string
  name?: string
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'TERRAGRUNT_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
}

export interface DOMConfiguration {
  parameterNames?: DOMStringList
}

export interface DOMImplementation {
  [key: string]: any
}

export interface DOMStringList {
  length?: number
}

export interface DelegateMetaInfo {
  id?: string
  hostName?: string
}

export interface DelegateResponseData {
  [key: string]: any
}

export interface Document {
  doctype?: DocumentType
  documentElement?: Element
  inputEncoding?: string
  xmlEncoding?: string
  xmlStandalone?: boolean
  xmlVersion?: string
  strictErrorChecking?: boolean
  documentURI?: string
  domConfig?: DOMConfiguration
  implementation?: DOMImplementation
  prefix?: string
  attributes?: NamedNodeMap
  nodeType?: number
  namespaceURI?: string
  localName?: string
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface DocumentType {
  name?: string
  publicId?: string
  systemId?: string
  entities?: NamedNodeMap
  notations?: NamedNodeMap
  internalSubset?: string
  prefix?: string
  attributes?: NamedNodeMap
  nodeType?: number
  namespaceURI?: string
  localName?: string
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface Element {
  tagName?: string
  schemaTypeInfo?: TypeInfo
  prefix?: string
  attributes?: NamedNodeMap
  nodeType?: number
  namespaceURI?: string
  localName?: string
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface ExecutionDataValue {
  displayName?: string
  value?: { [key: string]: any }
}

export type HttpStateExecutionData = DelegateResponseData & {
  httpUrl?: string
  httpMethod?: string
  httpResponseCode?: number
  httpResponseBody?: string
  assertionStatement?: string
  assertionStatus?: string
  header?: string
  headers?: KeyValuePair[]
  useProxy?: boolean
  warningMessage?: string
  document?: Document
  stateName?: string
  stateType?: string
  startTs?: number
  endTs?: number
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  errorMsg?: string
  waitInterval?: number
  element?: ContextElement
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  delegateMetaInfo?: DelegateMetaInfo
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  type?: string
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
}

export interface KeyValuePair {
  key?: string
  value?: string
}

export interface NamedNodeMap {
  length?: number
}

export interface Node {
  prefix?: string
  attributes?: NamedNodeMap
  nodeType?: number
  namespaceURI?: string
  localName?: string
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface NodeList {
  length?: number
}

export type ScriptStateExecutionData = DelegateResponseData & {
  name?: string
  activityId?: string
  sweepingOutputEnvVariables?: {
    [key: string]: string
  }
  secretOutputVars?: string[]
  stateName?: string
  stateType?: string
  startTs?: number
  endTs?: number
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  errorMsg?: string
  waitInterval?: number
  element?: ContextElement
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  delegateMetaInfo?: DelegateMetaInfo
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  type?: string
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
}

export interface TypeInfo {
  typeName?: string
  typeNamespace?: string
}

export interface EntitySetupUsageDTO {
  accountIdentifier?: string
  referredEntity?: EntityDetail
  referredByEntity: EntityDetail
  detail?: SetupUsageDetail
  createdAt?: number
}

export interface PageEntitySetupUsageDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: EntitySetupUsageDTO[]
  number?: number
  first?: boolean
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  empty?: boolean
}

export interface ResponsePageEntitySetupUsageDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEntitySetupUsageDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type SecretReferredByConnectorSetupUsageDetail = SetupUsageDetail & {
  fieldName?: string
}

export interface SetupUsageDetail {
  [key: string]: any
}

export interface EnvironmentResponseDTO {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  name?: string
  description?: string
  color?: string
  type?: 'PreProduction' | 'Production'
  deleted?: boolean
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ResponseEnvironmentResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EnvironmentResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EnvironmentRequestDTO {
  orgIdentifier: string
  projectIdentifier: string
  identifier: string
  tags?: {
    [key: string]: string
  }
  name?: string
  description?: string
  color?: string
  type: 'PreProduction' | 'Production'
  version?: number
}

export interface PageEnvironmentResponseDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: EnvironmentResponseDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageEnvironmentResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEnvironmentResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EnvironmentResponse {
  environment?: EnvironmentResponseDTO
  createdAt?: number
  lastModifiedAt?: number
}

export interface ResponseEnvironmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EnvironmentResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageEnvironmentResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: EnvironmentResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageEnvironmentResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEnvironmentResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Invite {
  id: string
  name: string
  email: string
  roleBindings: RoleBinding[]
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE'
  approved?: boolean
}

export interface ResponseOptionalInvite {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: Invite
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RoleBinding {
  roleIdentifier: string
  roleName: string
  resourceGroupIdentifier?: string
  resourceGroupName?: string
  managedRole: boolean
}

export interface ResponseListInviteOperationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: (
    | 'ACCOUNT_INVITE_ACCEPTED_NEED_PASSWORD'
    | 'ACCOUNT_INVITE_ACCEPTED'
    | 'USER_INVITED_SUCCESSFULLY'
    | 'USER_ALREADY_ADDED'
    | 'USER_ALREADY_INVITED'
    | 'FAIL'
  )[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CreateInvite {
  users: string[]
  roleBindings: RoleBinding[]
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE'
}

export interface PageInvite {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: Invite[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageInvite {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageInvite
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ACLAggregateFilter {
  resourceGroupIdentifiers?: string[]
  roleIdentifiers?: string[]
}

export interface GcpResponseDTO {
  clusterNames?: string[]
}

export interface ResponseGcpResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GcpResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Organization {
  identifier: string
  name: string
  description?: string
  tags?: {
    [key: string]: string
  }
}

export interface OrganizationAggregateDTO {
  organizationResponse: OrganizationResponse
  projectsCount?: number
  admins?: UserMetadataDTO[]
  collaborators?: UserMetadataDTO[]
}

export interface OrganizationResponse {
  organization: Organization
  createdAt?: number
  lastModifiedAt?: number
  harnessManaged?: boolean
}

export interface ResponseOrganizationAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OrganizationAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UserMetadataDTO {
  name?: string
  email: string
  uuid: string
}

export interface Project {
  orgIdentifier?: string
  identifier: string
  name: string
  color?: string
  modules?: ('CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE')[]
  description?: string
  tags?: {
    [key: string]: string
  }
}

export interface ProjectAggregateDTO {
  projectResponse: ProjectResponse
  organization?: Organization
  harnessManagedOrg?: boolean
  admins?: UserMetadataDTO[]
  collaborators?: UserMetadataDTO[]
}

export interface ProjectResponse {
  project: Project
  createdAt?: number
  lastModifiedAt?: number
}

export interface ResponseProjectAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ProjectAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type EmailConfigDTO = NotificationSettingConfigDTO & {
  groupEmail: string
}

export type MicrosoftTeamsConfigDTO = NotificationSettingConfigDTO & {
  microsoftTeamsWebhookUrl: string
}

export interface NotificationSettingConfigDTO {
  type?: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS'
}

export interface PageUserGroupAggregateDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: UserGroupAggregateDTO[]
  pageIndex?: number
  empty?: boolean
}

export type PagerDutyConfigDTO = NotificationSettingConfigDTO & {
  pagerDutyKey: string
}

export interface ResponsePageUserGroupAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageUserGroupAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RoleAssignmentMetadataDTO {
  identifier: string
  roleIdentifier: string
  roleName: string
  resourceGroupIdentifier: string
  resourceGroupName: string
  managedRole: boolean
  managedRoleAssignment: boolean
}

export type SlackConfigDTO = NotificationSettingConfigDTO & {
  slackWebhookUrl: string
}

export interface UserGroupAggregateDTO {
  userGroupDTO: UserGroupDTO
  users?: UserMetadataDTO[]
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[]
  lastModifiedAt?: number
}

export interface UserGroupDTO {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier: string
  name: string
  users?: string[]
  notificationConfigs?: NotificationSettingConfigDTO[]
  description?: string
  tags?: {
    [key: string]: string
  }
}

export interface ResponseListUserGroupAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserGroupAggregateDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface AggregateACLRequest {
  searchTerm?: string
  resourceGroupFilter?: string[]
  roleFilter?: string[]
}

export interface ResponseUserGroupAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserGroupAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageOrganizationAggregateDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: OrganizationAggregateDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageOrganizationAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageOrganizationAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageProjectAggregateDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ProjectAggregateDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageProjectAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageProjectAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretFileDTO {
  account?: string
  org?: string
  project?: string
  identifier?: string
  secretManager?: string
  name?: string
  tags?: string[]
  description?: string
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export interface EncryptedDataDTO {
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  valueType?: 'Inline' | 'Reference'
  value?: string
  draft?: boolean
  account?: string
  org?: string
  project?: string
  identifier?: string
  secretManager?: string
  secretManagerName?: string
  name?: string
  encryptionType?:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'CYBERARK'
    | 'VAULT'
    | 'GCP_SECRETS_MANAGER'
    | 'CUSTOM'
    | 'VAULT_SSH'
  tags?: string[]
  lastUpdatedAt?: number
  description?: string
}

export interface ResponseEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EncryptedDataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseSecretManagerMetadataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretManagerMetadataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretManagerMetadataDTO {
  encryptionType?:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'CYBERARK'
    | 'VAULT'
    | 'GCP_SECRETS_MANAGER'
    | 'CUSTOM'
    | 'VAULT_SSH'
  spec?: SecretManagerMetadataSpecDTO
}

export interface SecretManagerMetadataSpecDTO {
  [key: string]: any
}

export type VaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  secretEngines?: VaultSecretEngineDTO[]
}

export interface VaultSecretEngineDTO {
  name?: string
  description?: string
  type?: string
  version?: number
}

export interface SecretManagerMetadataRequestDTO {
  encryptionType:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'CYBERARK'
    | 'VAULT'
    | 'GCP_SECRETS_MANAGER'
    | 'CUSTOM'
    | 'VAULT_SSH'
  orgIdentifier?: string
  projectIdentifier?: string
  identifier: string
  spec: SecretManagerMetadataRequestSpecDTO
}

export interface SecretManagerMetadataRequestSpecDTO {
  [key: string]: any
}

export type VaultAppRoleCredentialDTO = VaultCredentialDTO & {
  appRoleId?: string
  secretId?: string
}

export type VaultAuthTokenCredentialDTO = VaultCredentialDTO & {
  authToken?: string
}

export interface VaultCredentialDTO {
  [key: string]: any
}

export type VaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  url: string
  accessType: 'APP_ROLE' | 'TOKEN'
  spec?: VaultCredentialDTO
}

export interface PageEncryptedDataDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: EncryptedDataDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEncryptedDataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretTextDTO {
  account?: string
  org?: string
  project?: string
  identifier?: string
  secretManager?: string
  name?: string
  tags?: string[]
  description?: string
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
  valueType: 'Inline' | 'Reference'
  value?: string
}

export interface BaseSSHSpecDTO {
  [key: string]: any
}

export type KerberosConfigDTO = BaseSSHSpecDTO & {
  principal: string
  realm: string
  tgtGenerationMethod?: 'KeyTabFilePath' | 'Password'
  spec?: TGTGenerationSpecDTO
}

export interface ResponseSecretResponseWrapper {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretResponseWrapper
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SSHAuthDTO {
  spec: BaseSSHSpecDTO
  type: 'SSH' | 'Kerberos'
}

export type SSHConfigDTO = BaseSSHSpecDTO & {
  credentialType: 'Password' | 'KeyPath' | 'KeyReference'
  spec: SSHCredentialSpecDTO
}

export interface SSHCredentialSpecDTO {
  [key: string]: any
}

export type SSHKeyPathCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  keyPath: string
  encryptedPassphrase?: string
}

export type SSHKeyReferenceCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  key?: string
  encryptedPassphrase?: string
}

export type SSHKeySpecDTO = SecretSpecDTO & {
  port?: number
  auth: SSHAuthDTO
}

export type SSHPasswordCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  password: string
}

export interface SecretDTOV2 {
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
  name: string
  identifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  description?: string
  spec: SecretSpecDTO
}

export type SecretFileSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
}

export interface SecretResponseWrapper {
  secret: SecretDTOV2
  createdAt?: number
  updatedAt?: number
  draft?: boolean
}

export interface SecretSpecDTO {
  errorMessageForInvalidYaml?: string
}

export type SecretTextSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
  valueType: 'Inline' | 'Reference'
  value?: string
}

export interface TGTGenerationSpecDTO {
  [key: string]: any
}

export type TGTKeyTabFilePathSpecDTO = TGTGenerationSpecDTO & {
  keyPath?: string
}

export type TGTPasswordSpecDTO = TGTGenerationSpecDTO & {
  password?: string
}

export interface SecretRequestWrapper {
  secret: SecretDTOV2
}

export interface PageSecretResponseWrapper {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: SecretResponseWrapper[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageSecretResponseWrapper {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageSecretResponseWrapper
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseSecretValidationResultDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretValidationResultDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretValidationResultDTO {
  success?: boolean
  message?: string
}

export type SSHKeyValidationMetadata = SecretValidationMetaData & {
  host: string
}

export interface SecretValidationMetaData {
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export interface ResponseOrganizationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OrganizationResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface OrganizationRequest {
  organization: Organization
}

export interface PageOrganizationResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: OrganizationResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageOrganizationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageOrganizationResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseProjectResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ProjectResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ProjectRequest {
  project: Project
}

export interface PageProjectResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ProjectResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageProjectResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageProjectResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseUserGroupDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserGroupDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageUserGroupDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: UserGroupDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageUserGroupDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageUserGroupDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListUserGroupDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserGroupDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UserGroupFilterDTO {
  databaseIdFilter?: string[]
  identifierFilter?: string[]
  userIdentifierFilter?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PageUserMetadataDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: UserMetadataDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageUserMetadataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageUserMetadataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UserFilter {
  searchTerm?: string
  identifiers?: string[]
}

export interface ResponseServiceResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ServiceResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceResponseDTO {
  accountId?: string
  identifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  name?: string
  description?: string
  deleted?: boolean
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ServiceRequestDTO {
  identifier: string
  orgIdentifier: string
  projectIdentifier: string
  name?: string
  description?: string
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface PageServiceResponseDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ServiceResponseDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageServiceResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageServiceResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageServiceResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ServiceResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageServiceResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageServiceResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceResponse {
  service?: ServiceResponseDTO
  createdAt?: number
  lastModifiedAt?: number
}

export interface ResponseServiceResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ServiceResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageUserAggregate {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: UserAggregate[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageUserAggregate {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageUserAggregate
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UserAggregate {
  user: UserMetadataDTO
  roleAssignmentMetadata: RoleAssignmentMetadataDTO[]
}

export interface ResponseUserAggregate {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserAggregate
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseUserInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UserInfo {
  uuid?: string
  name?: string
  email?: string
  token?: string
  defaultAccountId?: string
  admin?: boolean
  twoFactorAuthenticationEnabled?: boolean
}

export interface ResponseTwoFactorAuthSettingsInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: TwoFactorAuthSettingsInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface TwoFactorAuthSettingsInfo {
  userId?: string
  email?: string
  twoFactorAuthenticationEnabled?: boolean
  mechanism?: 'TOTP'
  totpSecretKey?: string
  totpqrurl?: string
}

export interface PageProject {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: Project[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageProject {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageProject
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ArtifactSummary {
  type?: string
  displayName?: string
}

export interface ArtifactsSummary {
  primary?: ArtifactSummary
  sidecars?: ArtifactSummary[]
}

export type CDStageExecutionSummaryDTO = StageExecutionSummaryDTO & {
  planExecutionId?: string
  stageIdentifier?: string
  serviceInfo?: ServiceExecutionSummary
  stageName?: string
  serviceDefinitionType?: string
  executionStatus?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
  startedAt?: number
  endedAt?: number
  serviceIdentifier?: string
  envIdentifier?: string
  errorInfo?: ExecutionErrorInfo
}

export interface ExecutionErrorInfo {
  unknownFields?: UnknownFieldSet
  message?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionErrorInfo
  defaultInstanceForType?: ExecutionErrorInfo
  messageBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface NGStageType {
  type?: string
}

export interface PagePipelineExecutionSummaryDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: PipelineExecutionSummaryDTO[]
  pageIndex?: number
  empty?: boolean
}

export type ParallelStageExecutionSummaryDTO = StageExecutionSummaryDTO & {
  stageExecutions?: StageExecutionSummaryDTO[]
}

export interface ParserExecutionErrorInfo {
  [key: string]: any
}

export interface PipelineExecutionSummaryDTO {
  pipelineIdentifier?: string
  pipelineName?: string
  deploymentId?: string
  planExecutionId?: string
  executionStatus?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
  inputSetYaml?: string
  startedAt?: number
  endedAt?: number
  tags?: {
    [key: string]: string
  }
  stageExecutionSummaryElements?: StageExecutionSummaryDTO[]
  errorMsg?: string
  stageIdentifiers?: string[]
  serviceIdentifiers?: string[]
  envIdentifiers?: string[]
  serviceDefinitionTypes?: string[]
  stageTypes?: NGStageType[]
  errorInfo?: ExecutionErrorInfo
  triggerInfo?: ExecutionTriggerInfo
  successfulStagesCount?: number
  runningStagesCount?: number
  failedStagesCount?: number
  totalStagesCount?: number
}

export interface ResponsePagePipelineExecutionSummaryDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PagePipelineExecutionSummaryDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceExecutionSummary {
  identifier?: string
  displayName?: string
  deploymentType?: string
  artifacts?: ArtifactsSummary
}

export interface StageExecutionSummaryDTO {
  [key: string]: any
}

export interface CDStageModuleInfo {
  serviceInfo?: ServiceExecutionSummary
  infraExecutionSummary?: InfraExecutionSummary
  nodeExecutionId?: string
}

export interface InfraExecutionSummary {
  identifier?: string
  name?: string
  type?: string
}

export interface ResponseCDStageModuleInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: CDStageModuleInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CDPipelineModuleInfo {
  serviceIdentifiers?: string[]
  envIdentifiers?: string[]
  serviceDefinitionTypes?: string[]
  environmentTypes?: ('PreProduction' | 'Production')[]
  infrastructureTypes?: string[]
}

export interface ResponseCDPipelineModuleInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: CDPipelineModuleInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponsePipelineExecutionInterrupt {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionInterrupt
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PipelineExecutionInterrupt {
  id?: string
  type?: 'Abort' | 'Pause' | 'Resume'
  planExecutionId?: string
}

export interface AdviserIssuer {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserAdviserIssuer
  defaultInstanceForType?: AdviserIssuer
  adviserType?: 'UNKNOWN' | 'NEXT_STEP' | 'RETRY' | 'INTERVENTION_WAIT' | 'END_PLAN' | 'MARK_SUCCESS' | 'UNRECOGNIZED'
  adviserTypeValue?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface AdviserIssuerOrBuilder {
  adviserType?: 'UNKNOWN' | 'NEXT_STEP' | 'RETRY' | 'INTERVENTION_WAIT' | 'END_PLAN' | 'MARK_SUCCESS' | 'UNRECOGNIZED'
  adviserTypeValue?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface AsyncExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserAsyncExecutableResponse
  defaultInstanceForType?: AsyncExecutableResponse
  mode?: 'RUNNING_MODE' | 'APPROVAL_WAITING_MODE' | 'RESOURCE_WAITING_MODE' | 'UNRECOGNIZED'
  callbackIdsList?: string[]
  callbackIdsCount?: number
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  modeValue?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface AsyncExecutableResponseOrBuilder {
  mode?: 'RUNNING_MODE' | 'APPROVAL_WAITING_MODE' | 'RESOURCE_WAITING_MODE' | 'UNRECOGNIZED'
  callbackIdsList?: string[]
  callbackIdsCount?: number
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  modeValue?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface Child {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChild
  defaultInstanceForType?: Child
  childNodeIdBytes?: ByteString
  childNodeId?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildChainExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChildChainExecutableResponse
  defaultInstanceForType?: ChildChainExecutableResponse
  nextChildId?: string
  previousChildId?: string
  previousChildIdBytes?: ByteString
  lastLink?: boolean
  suspend?: boolean
  passThroughData?: ByteString
  nextChildIdBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildChainExecutableResponseOrBuilder {
  nextChildId?: string
  previousChildId?: string
  previousChildIdBytes?: ByteString
  lastLink?: boolean
  suspend?: boolean
  passThroughData?: ByteString
  nextChildIdBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ChildExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChildExecutableResponse
  defaultInstanceForType?: ChildExecutableResponse
  childNodeIdBytes?: ByteString
  childNodeId?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildExecutableResponseOrBuilder {
  childNodeIdBytes?: ByteString
  childNodeId?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ChildOrBuilder {
  childNodeIdBytes?: ByteString
  childNodeId?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ChildrenExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserChildrenExecutableResponse
  defaultInstanceForType?: ChildrenExecutableResponse
  childrenCount?: number
  childrenList?: Child[]
  childrenOrBuilderList?: ChildOrBuilder[]
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ChildrenExecutableResponseOrBuilder {
  childrenCount?: number
  childrenList?: Child[]
  childrenOrBuilderList?: ChildOrBuilder[]
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface DelegateInfo {
  id?: string
  name?: string
  taskId?: string
  taskName?: string
}

export interface ExecutableResponse {
  unknownFields?: UnknownFieldSet
  asyncOrBuilder?: AsyncExecutableResponseOrBuilder
  async?: AsyncExecutableResponse
  responseCase?:
    | 'ASYNC'
    | 'CHILD'
    | 'CHILDREN'
    | 'CHILDCHAIN'
    | 'TASK'
    | 'TASKCHAIN'
    | 'SYNC'
    | 'SKIPTASK'
    | 'RESPONSE_NOT_SET'
  child?: ChildExecutableResponse
  childOrBuilder?: ChildExecutableResponseOrBuilder
  children?: ChildrenExecutableResponse
  childrenOrBuilder?: ChildrenExecutableResponseOrBuilder
  childChain?: ChildChainExecutableResponse
  sync?: SyncExecutableResponse
  taskChain?: TaskChainExecutableResponse
  taskChainOrBuilder?: TaskChainExecutableResponseOrBuilder
  syncOrBuilder?: SyncExecutableResponseOrBuilder
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutableResponse
  defaultInstanceForType?: ExecutableResponse
  childChainOrBuilder?: ChildChainExecutableResponseOrBuilder
  taskOrBuilder?: TaskExecutableResponseOrBuilder
  skipTask?: SkipTaskExecutableResponse
  skipTaskOrBuilder?: SkipTaskExecutableResponseOrBuilder
  task?: TaskExecutableResponse
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionGraph {
  rootNodeId?: string
  nodeMap?: {
    [key: string]: ExecutionNode
  }
  nodeAdjacencyListMap?: {
    [key: string]: ExecutionNodeAdjacencyList
  }
  representationStrategy?: 'camelCase'
}

export interface ExecutionNode {
  uuid?: string
  setupId?: string
  name?: string
  identifier?: string
  baseFqn?: string
  outcomes?: {
    [key: string]: { [key: string]: any }
  }[]
  stepParameters?: {
    [key: string]: { [key: string]: any }
  }
  startTs?: number
  endTs?: number
  stepType?: string
  status?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
  failureInfo?: FailureInfoDTO
  skipInfo?: SkipInfo
  nodeRunInfo?: NodeRunInfo
  executableResponses?: ExecutableResponse[]
  unitProgresses?: UnitProgress[]
  delegateInfoList?: DelegateInfo[]
  interruptHistories?: InterruptEffect[]
}

export interface ExecutionNodeAdjacencyList {
  children?: string[]
  nextIds?: string[]
}

export interface ExpressionBlock {
  unknownFields?: UnknownFieldSet
  expressionBytes?: ByteString
  expressionValueBytes?: ByteString
  expressionValue?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExpressionBlock
  defaultInstanceForType?: ExpressionBlock
  expression?: string
  count?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExpressionBlockOrBuilder {
  expressionBytes?: ByteString
  expressionValueBytes?: ByteString
  expressionValue?: string
  expression?: string
  count?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface FailureInfoDTO {
  message?: string
  failureTypeList?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
  responseMessages?: ResponseMessage[]
}

export interface InterruptConfig {
  unknownFields?: UnknownFieldSet
  configCase?: 'RETRYINTERRUPTCONFIG' | 'CONFIG_NOT_SET'
  issuedBy?: IssuedBy
  issuedByOrBuilder?: IssuedByOrBuilder
  retryInterruptConfig?: RetryInterruptConfig
  retryInterruptConfigOrBuilder?: RetryInterruptConfigOrBuilder
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserInterruptConfig
  defaultInstanceForType?: InterruptConfig
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface InterruptEffect {
  interruptId: string
  tookEffectAt: number
  interruptType:
    | 'UNKNOWN'
    | 'ABORT'
    | 'ABORT_ALL'
    | 'PAUSE'
    | 'PAUSE_ALL'
    | 'RESUME'
    | 'RESUME_ALL'
    | 'RETRY'
    | 'IGNORE'
    | 'WAITING_FOR_MANUAL_INTERVENTION'
    | 'MARK_FAILED'
    | 'MARK_SUCCESS'
    | 'NEXT_STEP'
    | 'END_EXECUTION'
    | 'MARK_EXPIRED'
    | 'CUSTOM_FAILURE'
    | 'UNRECOGNIZED'
  interruptConfig: InterruptConfig
}

export interface IssuedBy {
  unknownFields?: UnknownFieldSet
  manualIssuer?: ManualIssuer
  manualIssuerOrBuilder?: ManualIssuerOrBuilder
  adviserIssuer?: AdviserIssuer
  adviserIssuerOrBuilder?: AdviserIssuerOrBuilder
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserIssuedBy
  defaultInstanceForType?: IssuedBy
  timeoutIssuer?: TimeoutIssuer
  timeoutIssuerOrBuilder?: TimeoutIssuerOrBuilder
  issuerCase?: 'MANUALISSUER' | 'ADVISERISSUER' | 'TIMEOUTISSUER' | 'ISSUER_NOT_SET'
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface IssuedByOrBuilder {
  manualIssuer?: ManualIssuer
  manualIssuerOrBuilder?: ManualIssuerOrBuilder
  adviserIssuer?: AdviserIssuer
  adviserIssuerOrBuilder?: AdviserIssuerOrBuilder
  timeoutIssuer?: TimeoutIssuer
  timeoutIssuerOrBuilder?: TimeoutIssuerOrBuilder
  issuerCase?: 'MANUALISSUER' | 'ADVISERISSUER' | 'TIMEOUTISSUER' | 'ISSUER_NOT_SET'
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface ManualIssuer {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserManualIssuer
  defaultInstanceForType?: ManualIssuer
  userId?: string
  emailIdBytes?: ByteString
  userIdBytes?: ByteString
  emailId?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ManualIssuerOrBuilder {
  userId?: string
  emailIdBytes?: ByteString
  userIdBytes?: ByteString
  emailId?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface NodeRunInfo {
  unknownFields?: UnknownFieldSet
  whenCondition?: string
  whenConditionBytes?: ByteString
  expressionsList?: ExpressionBlock[]
  expressionsOrBuilderList?: ExpressionBlockOrBuilder[]
  expressionsCount?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserNodeRunInfo
  defaultInstanceForType?: NodeRunInfo
  evaluatedCondition?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ParserAdviserIssuer {
  [key: string]: any
}

export interface ParserAsyncExecutableResponse {
  [key: string]: any
}

export interface ParserChild {
  [key: string]: any
}

export interface ParserChildChainExecutableResponse {
  [key: string]: any
}

export interface ParserChildExecutableResponse {
  [key: string]: any
}

export interface ParserChildrenExecutableResponse {
  [key: string]: any
}

export interface ParserExecutableResponse {
  [key: string]: any
}

export interface ParserExpressionBlock {
  [key: string]: any
}

export interface ParserInterruptConfig {
  [key: string]: any
}

export interface ParserIssuedBy {
  [key: string]: any
}

export interface ParserManualIssuer {
  [key: string]: any
}

export interface ParserNodeRunInfo {
  [key: string]: any
}

export interface ParserRetryInterruptConfig {
  [key: string]: any
}

export interface ParserSkipInfo {
  [key: string]: any
}

export interface ParserSkipTaskExecutableResponse {
  [key: string]: any
}

export interface ParserSyncExecutableResponse {
  [key: string]: any
}

export interface ParserTaskChainExecutableResponse {
  [key: string]: any
}

export interface ParserTaskExecutableResponse {
  [key: string]: any
}

export interface ParserTimeoutIssuer {
  [key: string]: any
}

export interface ParserUnitProgress {
  [key: string]: any
}

export interface PipelineExecutionDetail {
  pipelineExecution?: PipelineExecutionSummaryDTO
  stageGraph?: ExecutionGraph
  stageRollbackGraph?: ExecutionGraph
}

export interface ResponsePipelineExecutionDetail {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionDetail
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RetryInterruptConfig {
  unknownFields?: UnknownFieldSet
  retryIdBytes?: ByteString
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserRetryInterruptConfig
  defaultInstanceForType?: RetryInterruptConfig
  retryId?: string
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface RetryInterruptConfigOrBuilder {
  retryIdBytes?: ByteString
  retryId?: string
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface SkipInfo {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSkipInfo
  defaultInstanceForType?: SkipInfo
  skipCondition?: string
  skipConditionBytes?: ByteString
  evaluatedCondition?: boolean
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface SkipTaskExecutableResponse {
  unknownFields?: UnknownFieldSet
  message?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSkipTaskExecutableResponse
  defaultInstanceForType?: SkipTaskExecutableResponse
  messageBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface SkipTaskExecutableResponseOrBuilder {
  message?: string
  messageBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface SyncExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserSyncExecutableResponse
  defaultInstanceForType?: SyncExecutableResponse
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface SyncExecutableResponseOrBuilder {
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TaskChainExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTaskChainExecutableResponse
  defaultInstanceForType?: TaskChainExecutableResponse
  taskId?: string
  taskName?: string
  taskIdBytes?: ByteString
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  chainEnd?: boolean
  passThroughData?: ByteString
  taskNameBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TaskChainExecutableResponseOrBuilder {
  taskId?: string
  taskName?: string
  taskIdBytes?: ByteString
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  chainEnd?: boolean
  passThroughData?: ByteString
  taskNameBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TaskExecutableResponse {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTaskExecutableResponse
  defaultInstanceForType?: TaskExecutableResponse
  taskId?: string
  taskName?: string
  taskIdBytes?: ByteString
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  taskNameBytes?: ByteString
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TaskExecutableResponseOrBuilder {
  taskId?: string
  taskName?: string
  taskIdBytes?: ByteString
  taskCategoryValue?: number
  taskCategory?: 'UNKNOWN_CATEGORY' | 'DELEGATE_TASK_V1' | 'DELEGATE_TASK_V2' | 'UNRECOGNIZED'
  logKeysList?: string[]
  logKeysCount?: number
  unitsList?: string[]
  unitsCount?: number
  taskNameBytes?: ByteString
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface TimeoutIssuer {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserTimeoutIssuer
  defaultInstanceForType?: TimeoutIssuer
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface TimeoutIssuerOrBuilder {
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initialized?: boolean
}

export interface UnitProgress {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserUnitProgress
  defaultInstanceForType?: UnitProgress
  unitName?: string
  unitNameBytes?: ByteString
  statusValue?: number
  status?: 'UNKNOWN' | 'SUCCESS' | 'FAILURE' | 'RUNNING' | 'QUEUED' | 'SKIPPED' | 'EXPIRED' | 'UNRECOGNIZED'
  startTime?: number
  endTime?: number
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFields?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ResponseListExecutionStatus {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: (
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
  )[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraProjectBasicNG {
  id: string
  key: string
  name: string
}

export interface ResponseListJiraProjectBasicNG {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraProjectBasicNG[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraStatusCategoryNG {
  id: number
  key: string
  name: string
}

export interface JiraStatusNG {
  id: string
  name: string
  statusCategory?: JiraStatusCategoryNG
}

export interface ResponseListJiraStatusNG {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraStatusNG[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraFieldAllowedValueNG {
  id?: string
  name?: string
  value?: string
}

export interface JiraFieldNG {
  key: string
  name: string
  required?: boolean
  schema: JiraFieldSchemaNG
  allowedValues: JiraFieldAllowedValueNG[]
  custom?: boolean
}

export interface JiraFieldSchemaNG {
  array?: boolean
  typeStr: string
  type: 'string' | 'number' | 'date' | 'datetime' | 'timetracking' | 'option'
  customType?: string
}

export interface JiraIssueCreateMetadataNG {
  projects?: {
    [key: string]: JiraProjectNG
  }
}

export interface JiraIssueTypeNG {
  id: string
  name: string
  description?: string
  statuses: JiraStatusNG[]
  fields: {
    [key: string]: JiraFieldNG
  }
  subTask?: boolean
}

export interface JiraProjectNG {
  id: string
  key: string
  name: string
  issuetypes: {
    [key: string]: JiraIssueTypeNG
  }
}

export interface ResponseJiraIssueCreateMetadataNG {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraIssueCreateMetadataNG
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraIssueUpdateMetadataNG {
  fields: {
    [key: string]: JiraFieldNG
  }
}

export interface ResponseJiraIssueUpdateMetadataNG {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraIssueUpdateMetadataNG
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type AwsCodeCommitSCMDTO = SourceCodeManagerDTO & {
  authentication: AwsCodeCommitAuthenticationDTO
}

export type AzureDevOpsSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication
}

export type BitbucketSCMDTO = SourceCodeManagerDTO & {
  authentication?: BitbucketAuthentication
}

export type GithubSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication
}

export type GitlabSCMDTO = SourceCodeManagerDTO & {
  authentication: GitlabAuthentication
}

export interface ResponseListSourceCodeManagerDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SourceCodeManagerDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SourceCodeManagerAuthentication {
  [key: string]: any
}

export interface SourceCodeManagerDTO {
  id?: string
  userIdentifier?: string
  name: string
  createdAt?: number
  lastModifiedAt?: number
  type?: 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'AWS_CODE_COMMIT' | 'AZURE_DEV_OPS'
  authentication?: SourceCodeManagerAuthentication
}

export interface ResponseSourceCodeManagerDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SourceCodeManagerDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetError {
  fieldName?: string
  message?: string
  identifierOfErrorSource?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export interface InputSetErrorWrapper {
  errorPipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export interface InputSetResponse {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  inputSetYaml?: string
  name?: string
  description?: string
  tags?: {
    [key: string]: string
  }
  inputSetErrorWrapper?: InputSetErrorWrapper
  version?: number
  errorResponse?: boolean
}

export interface ResponseInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface OverlayInputSetResponse {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  name?: string
  description?: string
  inputSetReferences?: string[]
  overlayInputSetYaml?: string
  tags?: {
    [key: string]: string
  }
  invalidInputSetReferences?: {
    [key: string]: string
  }
  version?: number
  errorResponse?: boolean
}

export interface ResponseOverlayInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OverlayInputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetConfig {
  identifier: string
  name?: string
  description?: string
  pipeline: NgPipeline
  tags?: {
    [key: string]: string
  }
}

export interface OverlayInputSetConfig {
  identifier?: string
  name?: string
  description?: string
  inputSetReferences?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface InputSetSummaryResponse {
  identifier?: string
  name?: string
  pipelineIdentifier?: string
  description?: string
  inputSetType?: 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface PageInputSetSummaryResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: InputSetSummaryResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageInputSetSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageInputSetSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetTemplateResponse {
  inputSetTemplateYaml?: string
}

export interface ResponseInputSetTemplateResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetTemplateResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface MergeInputSetResponse {
  pipelineYaml?: string
  inputSetErrorWrapper?: InputSetErrorWrapper
  errorResponse?: boolean
}

export interface ResponseMergeInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: MergeInputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPipelineResponse {
  ngPipeline?: NgPipeline
  executionsPlaceHolder?: string[]
  yamlPipeline?: string
  version?: number
}

export interface ResponseNGPipelineResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPipelineSummaryResponse {
  name?: string
  identifier?: string
  description?: string
  numOfStages?: number
  numOfErrors?: number
  deployments?: number[]
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ResponseNGPipelineSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageNGPipelineSummaryResponse {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: NGPipelineSummaryResponse[]
  number?: number
  first?: boolean
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  empty?: boolean
}

export interface ResponsePageNGPipelineSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageNGPipelineSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type ApprovalStageConfig = StageInfoConfig & {
  execution: ExecutionElementConfig
}

export interface BarrierInfoConfig {
  identifier: string
  name: string
}

export interface CIProperties {
  codebase?: CodeBase
}

export type DeploymentStageConfig = StageInfoConfig & {
  serviceConfig: ServiceConfig
  infrastructure: PipelineInfrastructure
  execution: ExecutionElementConfig
}

export type FeatureStageConfig = StageInfoConfig & {}

export interface FlowControlConfig {
  barriers?: BarrierInfoConfig[]
}

export interface NGProperties {
  ci?: CIProperties
}

export interface NotificationChannelWrapper {
  type?: string
  spec?: PmsNotificationChannel
}

export interface NotificationRules {
  name?: string
  enabled?: boolean
  pipelineEvents?: PipelineEvent[]
  notificationMethod?: NotificationChannelWrapper
}

export type ParallelStageElementConfig = StageElementWrapperConfig[]

export interface PipelineConfig {
  pipeline?: PipelineInfoConfig
}

export interface PipelineEvent {
  type?:
    | 'AllEvents'
    | 'PipelineStart'
    | 'PipelineSuccess'
    | 'PipelineFailed'
    | 'PipelinePaused'
    | 'StageSuccess'
    | 'StageFailed'
    | 'StageStart'
    | 'StepFailed'
  forStages?: string[]
}

export interface PipelineInfoConfig {
  name: string
  identifier: string
  flowControl?: FlowControlConfig
  description?: string
  tags?: {
    [key: string]: string
  }
  variables?: NGVariable[]
  properties?: NGProperties
  stages?: StageElementWrapperConfig[]
  notificationRules?: NotificationRules[]
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PmsEmailChannel = PmsNotificationChannel & {
  userGroups?: string[]
  recipients?: string[]
}

export type PmsMSTeamChannel = PmsNotificationChannel & {
  msTeamKeys?: string[]
  userGroups?: string[]
}

export interface PmsNotificationChannel {
  [key: string]: any
}

export type PmsPagerDutyChannel = PmsNotificationChannel & {
  userGroups?: string[]
  integrationKey?: string
}

export type PmsSlackChannel = PmsNotificationChannel & {
  userGroups?: string[]
  webhookUrl?: string
}

export interface ResponsePipelineConfig {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineConfig
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StageElementConfig {
  identifier: string
  name: string
  description?: string
  when?: StageWhenCondition
  failureStrategies?: FailureStrategyConfig[]
  variables?: NGVariable[]
  tags?: {
    [key: string]: string
  }
  type: string
  spec?: StageInfoConfig
}

export interface StageElementWrapperConfig {
  stage?: StageElementConfig
  parallel?: ParallelStageElementConfig
}

export interface StageInfoConfig {
  execution?: ExecutionElementConfig
}

export interface StageWhenCondition {
  pipelineStatus: 'Success' | 'Failure' | 'All'
  condition?: string
}

export interface RestResponseUserInfo {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: UserInfo
  responseMessages?: ResponseMessage[]
}

export interface SignupDTO {
  email?: string
  password?: string
  utmInfo?: UtmInfo
}

export interface OAuthSignupDTO {
  email?: string
  name?: string
  utmInfo?: UtmInfo
}

export interface JsonNode {
  array?: boolean
  null?: boolean
  double?: boolean
  textual?: boolean
  boolean?: boolean
  binary?: boolean
  bigDecimal?: boolean
  bigInteger?: boolean
  object?: boolean
  valueNode?: boolean
  containerNode?: boolean
  missingNode?: boolean
  nodeType?: 'ARRAY' | 'BINARY' | 'BOOLEAN' | 'MISSING' | 'NULL' | 'NUMBER' | 'OBJECT' | 'POJO' | 'STRING'
  pojo?: boolean
  number?: boolean
  integralNumber?: boolean
  floatingPointNumber?: boolean
  short?: boolean
  int?: boolean
  long?: boolean
  float?: boolean
}

export interface PartialSchemaDTO {
  schema?: JsonNode
  nodeType?: string
  nodeName?: string
  namespace?: string
}

export interface ResponsePartialSchemaDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PartialSchemaDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseJsonNode {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JsonNode
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseYamlSnippets {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: YamlSnippets
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface YamlSnippetMetaData {
  name?: string
  description?: string
  version?: string
  identifier?: string
  tags?: string[]
  iconTag?: string
}

export interface YamlSnippets {
  yamlSnippets?: YamlSnippetMetaData[]
}

export type SecretFileDTORequestBody = void

export type DockerRequestDTORequestBody = DockerRequestDTO

export type OrganizationRequestRequestBody = OrganizationRequest

export type UploadSamlMetaDataRequestBody = void

export type EnvironmentRequestDTORequestBody = EnvironmentRequestDTO

export type GcrRequestDTORequestBody = GcrRequestDTO

export type ModuleLicenseDTORequestBody = ModuleLicenseDTO

export type MergeInputSetRequestRequestBody = MergeInputSetRequest

export type ProjectRequestRequestBody = ProjectRequest

export type GitSyncConfigRequestBody = GitSyncConfig

export type SecretTextDTORequestBody = void

export type DelegateProfileDetailsNgRequestBody = DelegateProfileDetailsNg

export type UserGroupDTORequestBody = UserGroupDTO

export type FilterDTORequestBody = FilterDTO

export type OverlayInputSetConfigRequestBody = OverlayInputSetConfig

export type NgPipelineRequestBody = NgPipeline

export type ConnectorRequestBody = Connector

export type UpdateWhitelistedDomainsBodyRequestBody = string[]

export type EcrRequestDTORequestBody = EcrRequestDTO

export type SecretTextDTO2RequestBody = SecretTextDTO

export type SecretRequestWrapperRequestBody = SecretRequestWrapper

export type SecretRequestWrapper2RequestBody = void

export type UserFilterRequestBody = UserFilter

export type ServiceRequestDTORequestBody = ServiceRequestDTO

export type ServiceRequestDTOArrayRequestBody = ServiceRequestDTO[]

export type SourceCodeManagerDTORequestBody = SourceCodeManagerDTO

export type InputSetConfigRequestBody = InputSetConfig

export interface GetAccountPathParams {
  accountIdentifier: string
}

export type GetAccountProps = Omit<GetProps<ResponseAccount, Failure | Error, void, GetAccountPathParams>, 'path'> &
  GetAccountPathParams

/**
 * Get Account
 */
export const GetAccount = ({ accountIdentifier, ...props }: GetAccountProps) => (
  <Get<ResponseAccount, Failure | Error, void, GetAccountPathParams>
    path="/accounts/${accountIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountProps = Omit<
  UseGetProps<ResponseAccount, Failure | Error, void, GetAccountPathParams>,
  'path'
> &
  GetAccountPathParams

/**
 * Get Account
 */
export const useGetAccount = ({ accountIdentifier, ...props }: UseGetAccountProps) =>
  useGet<ResponseAccount, Failure | Error, void, GetAccountPathParams>(
    (paramsInPath: GetAccountPathParams) => `/accounts/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Get Account
 */
export const getAccountPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseAccount, Failure | Error, void, GetAccountPathParams> & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccount, Failure | Error, void, GetAccountPathParams>(
    getConfig('ng/api'),
    `/accounts/${accountIdentifier}`,
    props,
    signal
  )

export interface GetStepsQueryParams {
  serviceDefinitionType: 'Ssh' | 'Kubernetes' | 'Ecs' | 'NativeHelm' | 'Pcf'
}

export type GetStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>, 'path'>

/**
 * get steps for given service definition type
 */
export const GetSteps = (props: GetStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>
    path="/pipelines/configuration/steps"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepsProps = Omit<
  UseGetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  'path'
>

/**
 * get steps for given service definition type
 */
export const useGetSteps = (props: UseGetStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(`/pipelines/configuration/steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get steps for given service definition type
 */
export const getStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/steps`,
    props,
    signal
  )

export type GetExecutionStrategyListProps = Omit<
  GetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const GetExecutionStrategyList = (props: GetExecutionStrategyListProps) => (
  <Get<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>
    path="/pipelines/configuration/strategies"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyListProps = Omit<
  UseGetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const useGetExecutionStrategyList = (props: UseGetExecutionStrategyListProps) =>
  useGet<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    `/pipelines/configuration/strategies`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Execution Strategy list
 */
export const getExecutionStrategyListPromise = (
  props: GetUsingFetchProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies`,
    props,
    signal
  )

export interface GetExecutionStrategyYamlQueryParams {
  serviceDefinitionType: 'Ssh' | 'Kubernetes' | 'Ecs' | 'NativeHelm' | 'Pcf'
  strategyType: 'Basic' | 'Canary' | 'BlueGreen' | 'Rolling' | 'Default'
  includeVerify?: boolean
}

export type GetExecutionStrategyYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const GetExecutionStrategyYaml = (props: GetExecutionStrategyYamlProps) => (
  <Get<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>
    path="/pipelines/configuration/strategies/yaml-snippets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const useGetExecutionStrategyYaml = (props: UseGetExecutionStrategyYamlProps) =>
  useGet<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    `/pipelines/configuration/strategies/yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const getExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/yaml-snippets`,
    props,
    signal
  )

export interface GetProvisionerExecutionStrategyYamlQueryParams {
  provisionerType: 'TERRAFORM' | 'CLOUD_FORMATION' | 'AZURE_ARM' | 'SHELL_SCRIPT_PROVISIONER'
}

export type GetProvisionerExecutionStrategyYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const GetProvisionerExecutionStrategyYaml = (props: GetProvisionerExecutionStrategyYamlProps) => (
  <Get<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>
    path="/pipelines/configuration/strategies/provisioner-yaml-snippets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProvisionerExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const useGetProvisionerExecutionStrategyYaml = (props: UseGetProvisionerExecutionStrategyYamlProps) =>
  useGet<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>(
    `/pipelines/configuration/strategies/provisioner-yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const getProvisionerExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/provisioner-yaml-snippets`,
    props,
    signal
  )

export type GetServiceDefinitionTypesProps = Omit<
  GetProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const GetServiceDefinitionTypes = (props: GetServiceDefinitionTypesProps) => (
  <Get<ResponseListServiceDefinitionType, Failure | Error, void, void>
    path="/pipelines/configuration/serviceDefinitionTypes"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDefinitionTypesProps = Omit<
  UseGetProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const useGetServiceDefinitionTypes = (props: UseGetServiceDefinitionTypesProps) =>
  useGet<ResponseListServiceDefinitionType, Failure | Error, void, void>(
    `/pipelines/configuration/serviceDefinitionTypes`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Git list of service definition types
 */
export const getServiceDefinitionTypesPromise = (
  props: GetUsingFetchProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceDefinitionType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/serviceDefinitionTypes`,
    props,
    signal
  )

export type GetProvisionerStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, void, void>, 'path'>

/**
 * get provisioner steps
 */
export const GetProvisionerSteps = (props: GetProvisionerStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, void, void>
    path="/pipelines/configuration/provisioner-steps"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProvisionerStepsProps = Omit<UseGetProps<ResponseStepCategory, Failure | Error, void, void>, 'path'>

/**
 * get provisioner steps
 */
export const useGetProvisionerSteps = (props: UseGetProvisionerStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, void, void>(`/pipelines/configuration/provisioner-steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get provisioner steps
 */
export const getProvisionerStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/provisioner-steps`,
    props,
    signal
  )

export interface ValidatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
}

export type ValidatePipelineProps = Omit<
  GetProps<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>,
  'path'
>

/**
 * Validate a Pipeline
 */
export const ValidatePipeline = (props: ValidatePipelineProps) => (
  <Get<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>
    path="/pipelines/execute/validate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidatePipelineProps = Omit<
  UseGetProps<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>,
  'path'
>

/**
 * Validate a Pipeline
 */
export const useValidatePipeline = (props: UseValidatePipelineProps) =>
  useGet<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>(
    `/pipelines/execute/validate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate a Pipeline
 */
export const validatePipelinePromise = (
  props: GetUsingFetchProps<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/execute/validate`,
    props,
    signal
  )

export interface PostPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetYamlPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const PostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path="/pipelines/execute/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const usePostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetYamlPathParams) => `/pipelines/execute/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const postPipelineExecuteWithInputSetYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('ng/api'), `/pipelines/execute/${identifier}`, props, signal)

export interface PostPipelineExecuteWithInputSetListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetListPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetListProps = Omit<
  MutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const PostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetListProps) => (
  <Mutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >
    verb="POST"
    path="/pipelines/execute/${identifier}/inputSetList"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetListProps = Omit<
  UseMutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const usePostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetListProps) =>
  useMutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetListPathParams) =>
      `/pipelines/execute/${paramsInPath.identifier}/inputSetList`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with input set references list
 */
export const postPipelineExecuteWithInputSetListPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >('POST', getConfig('ng/api'), `/pipelines/execute/${identifier}/inputSetList`, props, signal)

export interface GetTestGitRepoConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoURL?: string
}

export interface GetTestGitRepoConnectionResultPathParams {
  identifier: string
}

export type GetTestGitRepoConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestGitRepoConnectionResult = ({ identifier, ...props }: GetTestGitRepoConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >
    verb="POST"
    path="/connectors/testGitRepoConnection/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestGitRepoConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestGitRepoConnectionResult = ({ identifier, ...props }: UseGetTestGitRepoConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestGitRepoConnectionResultPathParams) =>
      `/connectors/testGitRepoConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestGitRepoConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testGitRepoConnection/${identifier}`, props, signal)

export interface GetConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
}

export interface GetConnectorPathParams {
  identifier: string
}

export type GetConnectorProps = Omit<
  GetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const GetConnector = ({ identifier, ...props }: GetConnectorProps) => (
  <Get<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>
    path="/connectors/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorProps = Omit<
  UseGetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const useGetConnector = ({ identifier, ...props }: UseGetConnectorProps) =>
  useGet<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    (paramsInPath: GetConnectorPathParams) => `/connectors/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Connector
 */
export const getConnectorPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    getConfig('ng/api'),
    `/connectors/${identifier}`,
    props,
    signal
  )

export interface DeleteConnectorQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  createPr?: boolean
}

export type DeleteConnectorProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const DeleteConnector = (props: DeleteConnectorProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>
    verb="DELETE"
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteConnectorProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const useDeleteConnector = (props: UseDeleteConnectorProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>('DELETE', `/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a connector by identifier
 */
export const deleteConnectorPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
}

export type GetConnectorListProps = Omit<
  GetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const GetConnectorList = (props: GetConnectorListProps) => (
  <Get<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListProps = Omit<
  UseGetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const useGetConnectorList = (props: UseGetConnectorListProps) =>
  useGet<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(`/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Connector list
 */
export const getConnectorListPromise = (
  props: GetUsingFetchProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface CreateConnectorQueryParams {
  accountIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  createPr?: boolean
  targetBranchForPr?: string
}

export type CreateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const CreateConnector = (props: CreateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>
    verb="POST"
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const useCreateConnector = (props: UseCreateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates a Connector
 */
export const createConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface UpdateConnectorQueryParams {
  accountIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  createPr?: boolean
  lastObjectId?: string
  targetBranchForPr?: string
}

export type UpdateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const UpdateConnector = (props: UpdateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>
    verb="PUT"
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const useUpdateConnector = (props: UseUpdateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Updates a Connector
 */
export const updateConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorListV2QueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  searchTerm?: string
  orgIdentifier?: string
  projectIdentifier?: string
  filterIdentifier?: string
  includeAllConnectorsAvailableAtScope?: boolean
  branch?: string
  repoIdentifier?: string
}

export type GetConnectorListV2Props = Omit<
  MutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const GetConnectorListV2 = (props: GetConnectorListV2Props) => (
  <Mutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >
    verb="POST"
    path="/connectors/listV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListV2Props = Omit<
  UseMutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const useGetConnectorListV2 = (props: UseGetConnectorListV2Props) =>
  useMutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >('POST', `/connectors/listV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Connector list
 */
export const getConnectorListV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/connectors/listV2`, props, signal)

export interface ValidateTheIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateTheIdentifierIsUniqueProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateTheIdentifierIsUnique = (props: ValidateTheIdentifierIsUniqueProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>
    path="/connectors/validateUniqueIdentifier"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateTheIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateTheIdentifierIsUnique = (props: UseValidateTheIdentifierIsUniqueProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    `/connectors/validateUniqueIdentifier`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateTheIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/validateUniqueIdentifier`,
    props,
    signal
  )

export interface GetConnectorCatalogueQueryParams {
  accountIdentifier?: string
}

export type GetConnectorCatalogueProps = Omit<
  GetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const GetConnectorCatalogue = (props: GetConnectorCatalogueProps) => (
  <Get<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>
    path="/connectors/catalogue"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorCatalogueProps = Omit<
  UseGetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const useGetConnectorCatalogue = (props: UseGetConnectorCatalogueProps) =>
  useGet<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    `/connectors/catalogue`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Connector Catalogue
 */
export const getConnectorCataloguePromise = (
  props: GetUsingFetchProps<
    ResponseConnectorCatalogueResponse,
    Failure | Error,
    GetConnectorCatalogueQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/catalogue`,
    props,
    signal
  )

export interface GetTestConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
}

export interface GetTestConnectionResultPathParams {
  identifier: string
}

export type GetTestConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestConnectionResult = ({ identifier, ...props }: GetTestConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >
    verb="POST"
    path="/connectors/testConnection/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestConnectionResult = ({ identifier, ...props }: UseGetTestConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestConnectionResultPathParams) => `/connectors/testConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testConnection/${identifier}`, props, signal)

export interface GetConnectorStatisticsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetConnectorStatisticsProps = Omit<
  GetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const GetConnectorStatistics = (props: GetConnectorStatisticsProps) => (
  <Get<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>
    path="/connectors/stats"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorStatisticsProps = Omit<
  UseGetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const useGetConnectorStatistics = (props: UseGetConnectorStatisticsProps) =>
  useGet<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(`/connectors/stats`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Connectors statistics
 */
export const getConnectorStatisticsPromise = (
  props: GetUsingFetchProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/stats`,
    props,
    signal
  )

export interface ListConnectorByFQNQueryParams {
  accountIdentifier?: string
}

export type ListConnectorByFQNProps = Omit<
  MutateProps<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const ListConnectorByFQN = (props: ListConnectorByFQNProps) => (
  <Mutate<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>
    verb="POST"
    path="/connectors/listbyfqn"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListConnectorByFQNProps = Omit<
  UseMutateProps<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const useListConnectorByFQN = (props: UseListConnectorByFQNProps) =>
  useMutate<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>(
    'POST',
    `/connectors/listbyfqn`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Connector list
 */
export const listConnectorByFQNPromise = (
  props: MutateUsingFetchProps<
    ResponseListConnectorResponse,
    Failure | Error,
    ListConnectorByFQNQueryParams,
    string[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>(
    'POST',
    getConfig('ng/api'),
    `/connectors/listbyfqn`,
    props,
    signal
  )

export interface GetCEAwsTemplateQueryParams {
  eventsEnabled?: boolean
  curEnabled?: boolean
  optimizationEnabled?: boolean
}

export type GetCEAwsTemplateProps = Omit<
  MutateProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get CE Aws Connector Template URL Environment Wise
 */
export const GetCEAwsTemplate = (props: GetCEAwsTemplateProps) => (
  <Mutate<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>
    verb="POST"
    path="/connectors/getceawstemplateurl"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCEAwsTemplateProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get CE Aws Connector Template URL Environment Wise
 */
export const useGetCEAwsTemplate = (props: UseGetCEAwsTemplateProps) =>
  useMutate<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>(
    'POST',
    `/connectors/getceawstemplateurl`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get CE Aws Connector Template URL Environment Wise
 */
export const getCEAwsTemplatePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/connectors/getceawstemplateurl`,
    props,
    signal
  )

export interface GetFilterQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path="/filters/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('ng/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path="/filters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector' | 'PipelineSetup' | 'PipelineExecution' | 'Deployment' | 'Audit'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path="/filters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path="/filters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier?: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path="/filters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface SyncGitBranchQueryParams {
  repoIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
}

export type SyncGitBranchProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync the new branch into harness
 */
export const SyncGitBranch = (props: SyncGitBranchProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>
    verb="POST"
    path="/git-sync-branch/sync"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncGitBranchProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync the new branch into harness
 */
export const useSyncGitBranch = (props: UseSyncGitBranchProps) =>
  useMutate<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>('POST', `/git-sync-branch/sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync the new branch into harness
 */
export const syncGitBranchPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync-branch/sync`,
    props,
    signal
  )

export interface GetListOfBranchesWithStatusQueryParams {
  yamlGitConfigIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  searchTerm?: string
}

export type GetListOfBranchesWithStatusProps = Omit<
  GetProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  'path'
>

/**
 * Gets list of branches with their status by Git Config Identifier
 */
export const GetListOfBranchesWithStatus = (props: GetListOfBranchesWithStatusProps) => (
  <Get<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>
    path="/git-sync-branch/listBranchesWithStatus"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesWithStatusProps = Omit<
  UseGetProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  'path'
>

/**
 * Gets list of branches with their status by Git Config Identifier
 */
export const useGetListOfBranchesWithStatus = (props: UseGetListOfBranchesWithStatusProps) =>
  useGet<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>(
    `/git-sync-branch/listBranchesWithStatus`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets list of branches with their status by Git Config Identifier
 */
export const getListOfBranchesWithStatusPromise = (
  props: GetUsingFetchProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-branch/listBranchesWithStatus`,
    props,
    signal
  )

export interface ListGitSyncEntitiesByTypeQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  gitSyncConfigId?: string
  branch?: string
  page?: number
  size?: number
  moduleType?: string
}

export interface ListGitSyncEntitiesByTypePathParams {
  entityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
}

export type ListGitSyncEntitiesByTypeProps = Omit<
  GetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const ListGitSyncEntitiesByType = ({ entityType, ...props }: ListGitSyncEntitiesByTypeProps) => (
  <Get<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >
    path="/git-sync-entities/${entityType}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesByTypeProps = Omit<
  UseGetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const useListGitSyncEntitiesByType = ({ entityType, ...props }: UseListGitSyncEntitiesByTypeProps) =>
  useGet<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >((paramsInPath: ListGitSyncEntitiesByTypePathParams) => `/git-sync-entities/${paramsInPath.entityType}`, {
    base: getConfig('ng/api'),
    pathParams: { entityType },
    ...props
  })

/**
 * Get Git Sync Entity By Type
 */
export const listGitSyncEntitiesByTypePromise = (
  {
    entityType,
    ...props
  }: GetUsingFetchProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  > & {
    entityType:
      | 'Projects'
      | 'Pipelines'
      | 'PipelineSteps'
      | 'Connectors'
      | 'Secrets'
      | 'Service'
      | 'Environment'
      | 'InputSets'
      | 'CvConfig'
      | 'Delegates'
      | 'DelegateConfigurations'
      | 'CvVerificationJob'
      | 'IntegrationStage'
      | 'IntegrationSteps'
      | 'CvKubernetesActivitySource'
      | 'DeploymentSteps'
      | 'DeploymentStage'
      | 'ApprovalStage'
      | 'Triggers'
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >(getConfig('ng/api'), `/git-sync-entities/${entityType}`, props, signal)

export interface ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  size?: number
  gitSyncConfigId?: string
}

export interface ListGitSyncEntitiesSummaryForRepoAndBranchPathParams {
  branch: string
}

export type ListGitSyncEntitiesSummaryForRepoAndBranchProps = Omit<
  MutateProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >,
  'path' | 'verb'
> &
  ListGitSyncEntitiesSummaryForRepoAndBranchPathParams

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const ListGitSyncEntitiesSummaryForRepoAndBranch = ({
  branch,
  ...props
}: ListGitSyncEntitiesSummaryForRepoAndBranchProps) => (
  <Mutate<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >
    verb="POST"
    path="/git-sync-entities/branch/${branch}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesSummaryForRepoAndBranchProps = Omit<
  UseMutateProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >,
  'path' | 'verb'
> &
  ListGitSyncEntitiesSummaryForRepoAndBranchPathParams

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const useListGitSyncEntitiesSummaryForRepoAndBranch = ({
  branch,
  ...props
}: UseListGitSyncEntitiesSummaryForRepoAndBranchProps) =>
  useMutate<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >(
    'POST',
    (paramsInPath: ListGitSyncEntitiesSummaryForRepoAndBranchPathParams) =>
      `/git-sync-entities/branch/${paramsInPath.branch}`,
    { base: getConfig('ng/api'), pathParams: { branch }, ...props }
  )

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const listGitSyncEntitiesSummaryForRepoAndBranchPromise = (
  {
    branch,
    ...props
  }: MutateUsingFetchProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  > & { branch: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >('POST', getConfig('ng/api'), `/git-sync-entities/branch/${branch}`, props, signal)

export interface ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  size?: number
}

export type ListGitSyncEntitiesSummaryForRepoAndTypesProps = Omit<
  MutateProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const ListGitSyncEntitiesSummaryForRepoAndTypes = (props: ListGitSyncEntitiesSummaryForRepoAndTypesProps) => (
  <Mutate<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >
    verb="POST"
    path="/git-sync-entities/summary"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesSummaryForRepoAndTypesProps = Omit<
  UseMutateProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const useListGitSyncEntitiesSummaryForRepoAndTypes = (
  props: UseListGitSyncEntitiesSummaryForRepoAndTypesProps
) =>
  useMutate<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >('POST', `/git-sync-entities/summary`, { base: getConfig('ng/api'), ...props })

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const listGitSyncEntitiesSummaryForRepoAndTypesPromise = (
  props: MutateUsingFetchProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/git-sync-entities/summary`, props, signal)

export interface GetFileContentQueryParams {
  yamlGitConfigIdentifier: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  filePath: string
  branch?: string
  commitId?: string
}

export type GetFileContentProps = Omit<
  GetProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  'path'
>

/**
 * Gets file content
 */
export const GetFileContent = (props: GetFileContentProps) => (
  <Get<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>
    path="/scm/fileContent"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileContentProps = Omit<
  UseGetProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  'path'
>

/**
 * Gets file content
 */
export const useGetFileContent = (props: UseGetFileContentProps) =>
  useGet<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>(`/scm/fileContent`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets file content
 */
export const getFileContentPromise = (
  props: GetUsingFetchProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>(
    getConfig('ng/api'),
    `/scm/fileContent`,
    props,
    signal
  )

export interface GetListOfBranchesByGitConfigQueryParams {
  yamlGitConfigIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  searchTerm?: string
}

export type GetListOfBranchesByGitConfigProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Git Config Identifier
 */
export const GetListOfBranchesByGitConfig = (props: GetListOfBranchesByGitConfigProps) => (
  <Get<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>
    path="/scm/listBranchesByGitConfig"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesByGitConfigProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Git Config Identifier
 */
export const useGetListOfBranchesByGitConfig = (props: UseGetListOfBranchesByGitConfigProps) =>
  useGet<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>(
    `/scm/listBranchesByGitConfig`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets list of branches by Git Config Identifier
 */
export const getListOfBranchesByGitConfigPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>(
    getConfig('ng/api'),
    `/scm/listBranchesByGitConfig`,
    props,
    signal
  )

export interface GetListOfBranchesByConnectorQueryParams {
  connectorIdentifierRef?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoURL?: string
  page?: number
  size?: number
  searchTerm?: string
}

export type GetListOfBranchesByConnectorProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Connector Identifier
 */
export const GetListOfBranchesByConnector = (props: GetListOfBranchesByConnectorProps) => (
  <Get<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>
    path="/scm/listRepoBranches"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesByConnectorProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Connector Identifier
 */
export const useGetListOfBranchesByConnector = (props: UseGetListOfBranchesByConnectorProps) =>
  useGet<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>(`/scm/listRepoBranches`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets list of branches by Connector Identifier
 */
export const getListOfBranchesByConnectorPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>(
    getConfig('ng/api'),
    `/scm/listRepoBranches`,
    props,
    signal
  )

export interface ListGitSyncQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
}

export type ListGitSyncProps = Omit<GetProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const ListGitSync = (props: ListGitSyncProps) => (
  <Get<GitSyncConfig[], unknown, ListGitSyncQueryParams, void> path="/git-sync" base={getConfig('ng/api')} {...props} />
)

export type UseListGitSyncProps = Omit<UseGetProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const useListGitSync = (props: UseListGitSyncProps) =>
  useGet<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>(`/git-sync`, { base: getConfig('ng/api'), ...props })

/**
 * List Git Sync
 */
export const listGitSyncPromise = (
  props: GetUsingFetchProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>(getConfig('ng/api'), `/git-sync`, props, signal)

export interface PostGitSyncQueryParams {
  accountIdentifier?: string
}

export type PostGitSyncProps = Omit<
  MutateProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const PostGitSync = (props: PostGitSyncProps) => (
  <Mutate<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>
    verb="POST"
    path="/git-sync"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostGitSyncProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const usePostGitSync = (props: UsePostGitSyncProps) =>
  useMutate<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>('POST', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Git Sync
 */
export const postGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface PutGitSyncQueryParams {
  accountIdentifier?: string
}

export type PutGitSyncProps = Omit<
  MutateProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Git Sync by id
 */
export const PutGitSync = (props: PutGitSyncProps) => (
  <Mutate<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>
    verb="PUT"
    path="/git-sync"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Git Sync by id
 */
export const usePutGitSync = (props: UsePutGitSyncProps) =>
  useMutate<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>('PUT', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Update Git Sync by id
 */
export const putGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface PutGitSyncDefaultQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncDefaultPathParams {
  identifier: string
  folderIdentifier: string
}

export type PutGitSyncDefaultProps = Omit<
  MutateProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const PutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: PutGitSyncDefaultProps) => (
  <Mutate<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>
    verb="PUT"
    path="/git-sync/${identifier}/folder/${folderIdentifier}/default"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncDefaultProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const usePutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: UsePutGitSyncDefaultProps) =>
  useMutate<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    (paramsInPath: PutGitSyncDefaultPathParams) =>
      `/git-sync/${paramsInPath.identifier}/folder/${paramsInPath.folderIdentifier}/default`,
    { base: getConfig('ng/api'), pathParams: { identifier, folderIdentifier }, ...props }
  )

/**
 * Update Git Sync default by id
 */
export const putGitSyncDefaultPromise = (
  {
    identifier,
    folderIdentifier,
    ...props
  }: MutateUsingFetchProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams> & {
    identifier: string
    folderIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync/${identifier}/folder/${folderIdentifier}/default`,
    props,
    signal
  )

export interface IsGitSyncEnabledQueryParams {
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
}

export type IsGitSyncEnabledProps = Omit<GetProps<boolean, unknown, IsGitSyncEnabledQueryParams, void>, 'path'>

/**
 * Is Git Sync EnabledForProject
 */
export const IsGitSyncEnabled = (props: IsGitSyncEnabledProps) => (
  <Get<boolean, unknown, IsGitSyncEnabledQueryParams, void>
    path="/git-sync/git-sync-enabled"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsGitSyncEnabledProps = Omit<UseGetProps<boolean, unknown, IsGitSyncEnabledQueryParams, void>, 'path'>

/**
 * Is Git Sync EnabledForProject
 */
export const useIsGitSyncEnabled = (props: UseIsGitSyncEnabledProps) =>
  useGet<boolean, unknown, IsGitSyncEnabledQueryParams, void>(`/git-sync/git-sync-enabled`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Is Git Sync EnabledForProject
 */
export const isGitSyncEnabledPromise = (
  props: GetUsingFetchProps<boolean, unknown, IsGitSyncEnabledQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<boolean, unknown, IsGitSyncEnabledQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync/git-sync-enabled`,
    props,
    signal
  )

export interface WebhookCatcherQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface WebhookCatcherPathParams {
  entityToken: string
}

export type WebhookCatcherProps = Omit<
  MutateProps<RestResponse, unknown, WebhookCatcherQueryParams, string, WebhookCatcherPathParams>,
  'path' | 'verb'
> &
  WebhookCatcherPathParams

export const WebhookCatcher = ({ entityToken, ...props }: WebhookCatcherProps) => (
  <Mutate<RestResponse, unknown, WebhookCatcherQueryParams, string, WebhookCatcherPathParams>
    verb="POST"
    path="/git-sync-trigger/webhook/${entityToken}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseWebhookCatcherProps = Omit<
  UseMutateProps<RestResponse, unknown, WebhookCatcherQueryParams, string, WebhookCatcherPathParams>,
  'path' | 'verb'
> &
  WebhookCatcherPathParams

export const useWebhookCatcher = ({ entityToken, ...props }: UseWebhookCatcherProps) =>
  useMutate<RestResponse, unknown, WebhookCatcherQueryParams, string, WebhookCatcherPathParams>(
    'POST',
    (paramsInPath: WebhookCatcherPathParams) => `/git-sync-trigger/webhook/${paramsInPath.entityToken}`,
    { base: getConfig('ng/api'), pathParams: { entityToken }, ...props }
  )

export const webhookCatcherPromise = (
  {
    entityToken,
    ...props
  }: MutateUsingFetchProps<RestResponse, unknown, WebhookCatcherQueryParams, string, WebhookCatcherPathParams> & {
    entityToken: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponse, unknown, WebhookCatcherQueryParams, string, WebhookCatcherPathParams>(
    'POST',
    getConfig('ng/api'),
    `/git-sync-trigger/webhook/${entityToken}`,
    props,
    signal
  )

export interface GetModuleLicenseByAccountAndModuleTypeQueryParams {
  accountIdentifier: string
  moduleType: 'CD' | 'CI' | 'CV' | 'CE' | 'CF'
}

export type GetModuleLicenseByAccountAndModuleTypeProps = Omit<
  GetProps<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByAccountAndModuleTypeQueryParams, void>,
  'path'
>

/**
 * Gets Module License By Account And ModuleType
 */
export const GetModuleLicenseByAccountAndModuleType = (props: GetModuleLicenseByAccountAndModuleTypeProps) => (
  <Get<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByAccountAndModuleTypeQueryParams, void>
    path="/licenses"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetModuleLicenseByAccountAndModuleTypeProps = Omit<
  UseGetProps<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByAccountAndModuleTypeQueryParams, void>,
  'path'
>

/**
 * Gets Module License By Account And ModuleType
 */
export const useGetModuleLicenseByAccountAndModuleType = (props: UseGetModuleLicenseByAccountAndModuleTypeProps) =>
  useGet<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByAccountAndModuleTypeQueryParams, void>(
    `/licenses`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Module License By Account And ModuleType
 */
export const getModuleLicenseByAccountAndModuleTypePromise = (
  props: GetUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    GetModuleLicenseByAccountAndModuleTypeQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByAccountAndModuleTypeQueryParams, void>(
    getConfig('ng/api'),
    `/licenses`,
    props,
    signal
  )

export type CreateModuleLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates Module License
 */
export const CreateModuleLicense = (props: CreateModuleLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>
    verb="POST"
    path="/licenses"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateModuleLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates Module License
 */
export const useCreateModuleLicense = (props: UseCreateModuleLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>('POST', `/licenses`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Creates Module License
 */
export const createModuleLicensePromise = (
  props: MutateUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/licenses`,
    props,
    signal
  )

export type UpdateModuleLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates Module License
 */
export const UpdateModuleLicense = (props: UpdateModuleLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>
    verb="PUT"
    path="/licenses"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateModuleLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates Module License
 */
export const useUpdateModuleLicense = (props: UseUpdateModuleLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>('PUT', `/licenses`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Updates Module License
 */
export const updateModuleLicensePromise = (
  props: MutateUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, void, ModuleLicenseDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/licenses`,
    props,
    signal
  )

export interface GetModuleLicensePathParams {
  identifier: string
}

export type GetModuleLicenseProps = Omit<
  GetProps<ResponseModuleLicenseDTO, Failure | Error, void, GetModuleLicensePathParams>,
  'path'
> &
  GetModuleLicensePathParams

/**
 * Gets Module License
 */
export const GetModuleLicense = ({ identifier, ...props }: GetModuleLicenseProps) => (
  <Get<ResponseModuleLicenseDTO, Failure | Error, void, GetModuleLicensePathParams>
    path="/licenses/${identifier}}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetModuleLicenseProps = Omit<
  UseGetProps<ResponseModuleLicenseDTO, Failure | Error, void, GetModuleLicensePathParams>,
  'path'
> &
  GetModuleLicensePathParams

/**
 * Gets Module License
 */
export const useGetModuleLicense = ({ identifier, ...props }: UseGetModuleLicenseProps) =>
  useGet<ResponseModuleLicenseDTO, Failure | Error, void, GetModuleLicensePathParams>(
    (paramsInPath: GetModuleLicensePathParams) => `/licenses/${paramsInPath.identifier}}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets Module License
 */
export const getModuleLicensePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, void, GetModuleLicensePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseModuleLicenseDTO, Failure | Error, void, GetModuleLicensePathParams>(
    getConfig('ng/api'),
    `/licenses/${identifier}}`,
    props,
    signal
  )

export interface DeleteModuleLicenseQueryParams {
  accountIdentifier?: string
}

export type DeleteModuleLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, DeleteModuleLicenseQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes Module License
 */
export const DeleteModuleLicense = (props: DeleteModuleLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, DeleteModuleLicenseQueryParams, string, void>
    verb="DELETE"
    path="/licenses"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteModuleLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, DeleteModuleLicenseQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes Module License
 */
export const useDeleteModuleLicense = (props: UseDeleteModuleLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, DeleteModuleLicenseQueryParams, string, void>(
    'DELETE',
    `/licenses`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes Module License
 */
export const deleteModuleLicensePromise = (
  props: MutateUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, DeleteModuleLicenseQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, DeleteModuleLicenseQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/licenses`,
    props,
    signal
  )

export interface GetAccountLicensesQueryParams {
  accountIdentifier?: string
}

export type GetAccountLicensesProps = Omit<
  GetProps<ResponseAccountLicensesDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module License Information in Account
 */
export const GetAccountLicenses = (props: GetAccountLicensesProps) => (
  <Get<ResponseAccountLicensesDTO, Failure | Error, GetAccountLicensesQueryParams, void>
    path="/licenses/account"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountLicensesProps = Omit<
  UseGetProps<ResponseAccountLicensesDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module License Information in Account
 */
export const useGetAccountLicenses = (props: UseGetAccountLicensesProps) =>
  useGet<ResponseAccountLicensesDTO, Failure | Error, GetAccountLicensesQueryParams, void>(`/licenses/account`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets All Module License Information in Account
 */
export const getAccountLicensesPromise = (
  props: GetUsingFetchProps<ResponseAccountLicensesDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountLicensesDTO, Failure | Error, GetAccountLicensesQueryParams, void>(
    getConfig('ng/api'),
    `/licenses/account`,
    props,
    signal
  )

export interface StartTrialLicenseQueryParams {
  accountIdentifier: string
}

export type StartTrialLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Starts Trail License For A Module
 */
export const StartTrialLicense = (props: StartTrialLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialRequestDTO, void>
    verb="POST"
    path="/licenses/trial"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseStartTrialLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Starts Trail License For A Module
 */
export const useStartTrialLicense = (props: UseStartTrialLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialRequestDTO, void>(
    'POST',
    `/licenses/trial`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Starts Trail License For A Module
 */
export const startTrialLicensePromise = (
  props: MutateUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    StartTrialLicenseQueryParams,
    StartTrialRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialRequestDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/licenses/trial`,
    props,
    signal
  )

export type GetVersionInfoProps = Omit<GetProps<RestResponseVersionPackage, unknown, void, void>, 'path'>

/**
 * Get Version Info
 */
export const GetVersionInfo = (props: GetVersionInfoProps) => (
  <Get<RestResponseVersionPackage, unknown, void, void> path="/version" base={getConfig('ng/api')} {...props} />
)

export type UseGetVersionInfoProps = Omit<UseGetProps<RestResponseVersionPackage, unknown, void, void>, 'path'>

/**
 * Get Version Info
 */
export const useGetVersionInfo = (props: UseGetVersionInfoProps) =>
  useGet<RestResponseVersionPackage, unknown, void, void>(`/version`, { base: getConfig('ng/api'), ...props })

/**
 * Get Version Info
 */
export const getVersionInfoPromise = (
  props: GetUsingFetchProps<RestResponseVersionPackage, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<RestResponseVersionPackage, unknown, void, void>(getConfig('ng/api'), `/version`, props, signal)

export interface GetFilteredRoleAssignmentListQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetFilteredRoleAssignmentListProps = Omit<
  MutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilter,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Filtered Role Assignments
 */
export const GetFilteredRoleAssignmentList = (props: GetFilteredRoleAssignmentListProps) => (
  <Mutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilter,
    void
  >
    verb="POST"
    path="/roleassignments/filter"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilteredRoleAssignmentListProps = Omit<
  UseMutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilter,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Filtered Role Assignments
 */
export const useGetFilteredRoleAssignmentList = (props: UseGetFilteredRoleAssignmentListProps) =>
  useMutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilter,
    void
  >('POST', `/roleassignments/filter`, { base: getConfig('ng/api'), ...props })

/**
 * Get Filtered Role Assignments
 */
export const getFilteredRoleAssignmentListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilter,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilter,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/filter`, props, signal)

export interface CreateRoleAssignmentQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateRoleAssignmentProps = Omit<
  MutateProps<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>,
  'path' | 'verb'
>

/**
 * Create Role Assignment
 */
export const CreateRoleAssignment = (props: CreateRoleAssignmentProps) => (
  <Mutate<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>
    verb="POST"
    path="/roleassignments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Role Assignment
 */
export const useCreateRoleAssignment = (props: UseCreateRoleAssignmentProps) =>
  useMutate<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>(
    'POST',
    `/roleassignments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create Role Assignment
 */
export const createRoleAssignmentPromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >('POST', getConfig('ng/api'), `/roleassignments`, props, signal)

export interface CreateRoleAssignmentsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateRoleAssignmentsProps = Omit<
  MutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Multiple Role Assignments
 */
export const CreateRoleAssignments = (props: CreateRoleAssignmentsProps) => (
  <Mutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >
    verb="POST"
    path="/roleassignments/multi"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentsProps = Omit<
  UseMutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Multiple Role Assignments
 */
export const useCreateRoleAssignments = (props: UseCreateRoleAssignmentsProps) =>
  useMutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >('POST', `/roleassignments/multi`, { base: getConfig('ng/api'), ...props })

/**
 * Create Multiple Role Assignments
 */
export const createRoleAssignmentsPromise = (
  props: MutateUsingFetchProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    BatchRoleAssignmentCreateRequest,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/multi`, props, signal)

export interface RemoveOauthMechanismQueryParams {
  accountIdentifier?: string
}

export type RemoveOauthMechanismProps = Omit<
  MutateProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Remove Oauth mechanism for an account
 */
export const RemoveOauthMechanism = (props: RemoveOauthMechanismProps) => (
  <Mutate<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>
    verb="DELETE"
    path="/authentication-settings/oauth/remove-mechanism"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveOauthMechanismProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Remove Oauth mechanism for an account
 */
export const useRemoveOauthMechanism = (props: UseRemoveOauthMechanismProps) =>
  useMutate<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>(
    'DELETE',
    `/authentication-settings/oauth/remove-mechanism`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Remove Oauth mechanism for an account
 */
export const removeOauthMechanismPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/authentication-settings/oauth/remove-mechanism`,
    props,
    signal
  )

export interface UpdateAuthMechanismQueryParams {
  accountIdentifier?: string
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export type UpdateAuthMechanismProps = Omit<
  MutateProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Update Auth mechanism for an account
 */
export const UpdateAuthMechanism = (props: UpdateAuthMechanismProps) => (
  <Mutate<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>
    verb="PUT"
    path="/authentication-settings/update-auth-mechanism"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAuthMechanismProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Update Auth mechanism for an account
 */
export const useUpdateAuthMechanism = (props: UseUpdateAuthMechanismProps) =>
  useMutate<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>(
    'PUT',
    `/authentication-settings/update-auth-mechanism`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update Auth mechanism for an account
 */
export const updateAuthMechanismPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/update-auth-mechanism`,
    props,
    signal
  )

export interface PutLoginSettingsQueryParams {
  accountIdentifier?: string
}

export interface PutLoginSettingsPathParams {
  loginSettingsId: string
}

export type PutLoginSettingsProps = Omit<
  MutateProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >,
  'path' | 'verb'
> &
  PutLoginSettingsPathParams

/**
 * Update login settings - lockout, expiration, strength
 */
export const PutLoginSettings = ({ loginSettingsId, ...props }: PutLoginSettingsProps) => (
  <Mutate<RestResponseLoginSettings, unknown, PutLoginSettingsQueryParams, LoginSettings, PutLoginSettingsPathParams>
    verb="PUT"
    path="/authentication-settings/login-settings/${loginSettingsId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutLoginSettingsProps = Omit<
  UseMutateProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >,
  'path' | 'verb'
> &
  PutLoginSettingsPathParams

/**
 * Update login settings - lockout, expiration, strength
 */
export const usePutLoginSettings = ({ loginSettingsId, ...props }: UsePutLoginSettingsProps) =>
  useMutate<RestResponseLoginSettings, unknown, PutLoginSettingsQueryParams, LoginSettings, PutLoginSettingsPathParams>(
    'PUT',
    (paramsInPath: PutLoginSettingsPathParams) =>
      `/authentication-settings/login-settings/${paramsInPath.loginSettingsId}`,
    { base: getConfig('ng/api'), pathParams: { loginSettingsId }, ...props }
  )

/**
 * Update login settings - lockout, expiration, strength
 */
export const putLoginSettingsPromise = (
  {
    loginSettingsId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  > & { loginSettingsId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >('PUT', getConfig('ng/api'), `/authentication-settings/login-settings/${loginSettingsId}`, props, signal)

export interface GetAuthenticationSettingsQueryParams {
  accountIdentifier?: string
}

export type GetAuthenticationSettingsProps = Omit<
  GetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>,
  'path'
>

/**
 * Get authentication settings for an account
 */
export const GetAuthenticationSettings = (props: GetAuthenticationSettingsProps) => (
  <Get<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>
    path="/authentication-settings"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAuthenticationSettingsProps = Omit<
  UseGetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>,
  'path'
>

/**
 * Get authentication settings for an account
 */
export const useGetAuthenticationSettings = (props: UseGetAuthenticationSettingsProps) =>
  useGet<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>(
    `/authentication-settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get authentication settings for an account
 */
export const getAuthenticationSettingsPromise = (
  props: GetUsingFetchProps<
    RestResponseAuthenticationSettingsResponse,
    unknown,
    GetAuthenticationSettingsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings`,
    props,
    signal
  )

export interface UpdateOauthProvidersQueryParams {
  accountIdentifier?: string
}

export type UpdateOauthProvidersProps = Omit<
  MutateProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  'path' | 'verb'
>

/**
 * Update Oauth providers for an account
 */
export const UpdateOauthProviders = (props: UpdateOauthProvidersProps) => (
  <Mutate<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>
    verb="PUT"
    path="/authentication-settings/oauth/update-providers"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateOauthProvidersProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  'path' | 'verb'
>

/**
 * Update Oauth providers for an account
 */
export const useUpdateOauthProviders = (props: UseUpdateOauthProvidersProps) =>
  useMutate<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>(
    'PUT',
    `/authentication-settings/oauth/update-providers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update Oauth providers for an account
 */
export const updateOauthProvidersPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/oauth/update-providers`,
    props,
    signal
  )

export interface SetTwoFactorAuthAtAccountLevelQueryParams {
  accountIdentifier?: string
}

export type SetTwoFactorAuthAtAccountLevelProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  'path' | 'verb'
>

/**
 * Set account level two factor auth setting
 */
export const SetTwoFactorAuthAtAccountLevel = (props: SetTwoFactorAuthAtAccountLevelProps) => (
  <Mutate<RestResponseBoolean, unknown, SetTwoFactorAuthAtAccountLevelQueryParams, TwoFactorAdminOverrideSettings, void>
    verb="PUT"
    path="/authentication-settings/two-factor-admin-override-settings"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSetTwoFactorAuthAtAccountLevelProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  'path' | 'verb'
>

/**
 * Set account level two factor auth setting
 */
export const useSetTwoFactorAuthAtAccountLevel = (props: UseSetTwoFactorAuthAtAccountLevelProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >('PUT', `/authentication-settings/two-factor-admin-override-settings`, { base: getConfig('ng/api'), ...props })

/**
 * Set account level two factor auth setting
 */
export const setTwoFactorAuthAtAccountLevelPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/two-factor-admin-override-settings`, props, signal)

export interface GetPasswordStrengthSettingsQueryParams {
  accountIdentifier?: string
}

export type GetPasswordStrengthSettingsProps = Omit<
  GetProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  'path'
>

/**
 * Get Password strength settings
 */
export const GetPasswordStrengthSettings = (props: GetPasswordStrengthSettingsProps) => (
  <Get<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>
    path="/authentication-settings/login-settings/password-strength"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPasswordStrengthSettingsProps = Omit<
  UseGetProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  'path'
>

/**
 * Get Password strength settings
 */
export const useGetPasswordStrengthSettings = (props: UseGetPasswordStrengthSettingsProps) =>
  useGet<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>(
    `/authentication-settings/login-settings/password-strength`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Password strength settings
 */
export const getPasswordStrengthSettingsPromise = (
  props: GetUsingFetchProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/login-settings/password-strength`,
    props,
    signal
  )

export interface UpdateWhitelistedDomainsQueryParams {
  accountIdentifier?: string
}

export type UpdateWhitelistedDomainsProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Whitelisted domains for an account
 */
export const UpdateWhitelistedDomains = (props: UpdateWhitelistedDomainsProps) => (
  <Mutate<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >
    verb="PUT"
    path="/authentication-settings/whitelisted-domains"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateWhitelistedDomainsProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Whitelisted domains for an account
 */
export const useUpdateWhitelistedDomains = (props: UseUpdateWhitelistedDomainsProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('PUT', `/authentication-settings/whitelisted-domains`, { base: getConfig('ng/api'), ...props })

/**
 * Update Whitelisted domains for an account
 */
export const updateWhitelistedDomainsPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/whitelisted-domains`, props, signal)

export interface UploadSamlMetaDataQueryParams {
  accountId?: string
}

export type UploadSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SAML Config
 */
export const UploadSamlMetaData = (props: UploadSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>
    verb="POST"
    path="/authentication-settings/saml-metadata-upload"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUploadSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SAML Config
 */
export const useUploadSamlMetaData = (props: UseUploadSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'POST',
    `/authentication-settings/saml-metadata-upload`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create SAML Config
 */
export const uploadSamlMetaDataPromise = (
  props: MutateUsingFetchProps<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UploadSamlMetaDataRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/authentication-settings/saml-metadata-upload`,
    props,
    signal
  )

export interface UpdateSamlMetaDataQueryParams {
  accountId?: string
}

export type UpdateSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Edit SAML Config
 */
export const UpdateSamlMetaData = (props: UpdateSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>
    verb="PUT"
    path="/authentication-settings/saml-metadata-upload"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Edit SAML Config
 */
export const useUpdateSamlMetaData = (props: UseUpdateSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'PUT',
    `/authentication-settings/saml-metadata-upload`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Edit SAML Config
 */
export const updateSamlMetaDataPromise = (
  props: MutateUsingFetchProps<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataQueryParams,
    UploadSamlMetaDataRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/saml-metadata-upload`,
    props,
    signal
  )

export interface DeleteSamlMetaDataQueryParams {
  accountIdentifier?: string
}

export type DeleteSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete SAML Config
 */
export const DeleteSamlMetaData = (props: DeleteSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>
    verb="DELETE"
    path="/authentication-settings/delete-saml-metadata"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete SAML Config
 */
export const useDeleteSamlMetaData = (props: UseDeleteSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>(
    'DELETE',
    `/authentication-settings/delete-saml-metadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete SAML Config
 */
export const deleteSamlMetaDataPromise = (
  props: MutateUsingFetchProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/authentication-settings/delete-saml-metadata`,
    props,
    signal
  )

export interface GetSamlLoginTestQueryParams {
  accountId?: string
}

export type GetSamlLoginTestProps = Omit<
  GetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  'path'
>

/**
 * Get SAML Login Test
 */
export const GetSamlLoginTest = (props: GetSamlLoginTestProps) => (
  <Get<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>
    path="/authentication-settings/saml-login-test"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSamlLoginTestProps = Omit<
  UseGetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  'path'
>

/**
 * Get SAML Login Test
 */
export const useGetSamlLoginTest = (props: UseGetSamlLoginTestProps) =>
  useGet<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>(
    `/authentication-settings/saml-login-test`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get SAML Login Test
 */
export const getSamlLoginTestPromise = (
  props: GetUsingFetchProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/saml-login-test`,
    props,
    signal
  )

export interface GetWorkloadsQueryParams {
  accountId: string
  orgIdentifier: string
  projectIdentifier: string
  startInterval: string
  endInterval?: string
}

export type GetWorkloadsProps = Omit<
  GetProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const GetWorkloads = (props: GetWorkloadsProps) => (
  <Get<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>
    path="/dashboard/getWorkloads"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetWorkloadsProps = Omit<
  UseGetProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const useGetWorkloads = (props: UseGetWorkloadsProps) =>
  useGet<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>(
    `/dashboard/getWorkloads`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get workloads
 */
export const getWorkloadsPromise = (
  props: GetUsingFetchProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getWorkloads`,
    props,
    signal
  )

export interface GetDeploymentHealthQueryParams {
  accountId: string
  orgIdentifier: string
  projectIdentifier: string
  startInterval: string
  endInterval: string
}

export type GetDeploymentHealthProps = Omit<
  GetProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  'path'
>

/**
 * Get deployment health
 */
export const GetDeploymentHealth = (props: GetDeploymentHealthProps) => (
  <Get<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>
    path="/dashboard/deploymentHealth"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentHealthProps = Omit<
  UseGetProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  'path'
>

/**
 * Get deployment health
 */
export const useGetDeploymentHealth = (props: UseGetDeploymentHealthProps) =>
  useGet<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>(
    `/dashboard/deploymentHealth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployment health
 */
export const getDeploymentHealthPromise = (
  props: GetUsingFetchProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/deploymentHealth`,
    props,
    signal
  )

export interface GetDeploymentExecutionQueryParams {
  accountId: string
  orgIdentifier: string
  projectIdentifier: string
  startInterval: string
  endInterval: string
}

export type GetDeploymentExecutionProps = Omit<
  GetProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  'path'
>

/**
 * Get deployment execution
 */
export const GetDeploymentExecution = (props: GetDeploymentExecutionProps) => (
  <Get<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>
    path="/dashboard/deploymentExecution"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentExecutionProps = Omit<
  UseGetProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  'path'
>

/**
 * Get deployment execution
 */
export const useGetDeploymentExecution = (props: UseGetDeploymentExecutionProps) =>
  useGet<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>(
    `/dashboard/deploymentExecution`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployment execution
 */
export const getDeploymentExecutionPromise = (
  props: GetUsingFetchProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/deploymentExecution`,
    props,
    signal
  )

export interface GetDeploymentsQueryParams {
  accountId: string
  orgIdentifier: string
  projectIdentifier: string
  top?: number
}

export type GetDeploymentsProps = Omit<
  GetProps<ResponseDashboardDeploymentActiveFailedRunningInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get deployments
 */
export const GetDeployments = (props: GetDeploymentsProps) => (
  <Get<ResponseDashboardDeploymentActiveFailedRunningInfo, Failure | Error, GetDeploymentsQueryParams, void>
    path="/dashboard/getDeployments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentsProps = Omit<
  UseGetProps<ResponseDashboardDeploymentActiveFailedRunningInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get deployments
 */
export const useGetDeployments = (props: UseGetDeploymentsProps) =>
  useGet<ResponseDashboardDeploymentActiveFailedRunningInfo, Failure | Error, GetDeploymentsQueryParams, void>(
    `/dashboard/getDeployments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployments
 */
export const getDeploymentsPromise = (
  props: GetUsingFetchProps<
    ResponseDashboardDeploymentActiveFailedRunningInfo,
    Failure | Error,
    GetDeploymentsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardDeploymentActiveFailedRunningInfo, Failure | Error, GetDeploymentsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getDeployments`,
    props,
    signal
  )

export interface ListActivitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  status?: 'SUCCESS' | 'FAILED'
  referredEntityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  referredByEntityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
}

export type ListActivitiesProps = Omit<GetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>, 'path'>

/**
 * Get Activities where this resource was used
 */
export const ListActivities = (props: ListActivitiesProps) => (
  <Get<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>
    path="/activityHistory"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListActivitiesProps = Omit<
  UseGetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  'path'
>

/**
 * Get Activities where this resource was used
 */
export const useListActivities = (props: UseListActivitiesProps) =>
  useGet<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(`/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities where this resource was used
 */
export const listActivitiesPromise = (
  props: GetUsingFetchProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export type PostActivityProps = Omit<MutateProps<ResponseActivity, unknown, void, Activity, void>, 'path' | 'verb'>

/**
 * Saves the activity
 */
export const PostActivity = (props: PostActivityProps) => (
  <Mutate<ResponseActivity, unknown, void, Activity, void>
    verb="POST"
    path="/activityHistory"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostActivityProps = Omit<
  UseMutateProps<ResponseActivity, unknown, void, Activity, void>,
  'path' | 'verb'
>

/**
 * Saves the activity
 */
export const usePostActivity = (props: UsePostActivityProps) =>
  useMutate<ResponseActivity, unknown, void, Activity, void>('POST', `/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Saves the activity
 */
export const postActivityPromise = (
  props: MutateUsingFetchProps<ResponseActivity, unknown, void, Activity, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseActivity, unknown, void, Activity, void>(
    'POST',
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export interface GetConnectivitySummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
}

export type GetConnectivitySummaryProps = Omit<
  GetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const GetConnectivitySummary = (props: GetConnectivitySummaryProps) => (
  <Get<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>
    path="/activityHistory/connectivityCheckSummary"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectivitySummaryProps = Omit<
  UseGetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const useGetConnectivitySummary = (props: UseGetConnectivitySummaryProps) =>
  useGet<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    `/activityHistory/connectivityCheckSummary`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ConnectivityCheck Summary
 */
export const getConnectivitySummaryPromise = (
  props: GetUsingFetchProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/connectivityCheckSummary`,
    props,
    signal
  )

export interface GetActivitiesSummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  timeGroupType: 'DAY' | 'HOUR'
  referredEntityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  referredByEntityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
}

export type GetActivitiesSummaryProps = Omit<
  GetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const GetActivitiesSummary = (props: GetActivitiesSummaryProps) => (
  <Get<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>
    path="/activityHistory/summary"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActivitiesSummaryProps = Omit<
  UseGetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const useGetActivitiesSummary = (props: UseGetActivitiesSummaryProps) =>
  useGet<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(`/activityHistory/summary`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities Summary
 */
export const getActivitiesSummaryPromise = (
  props: GetUsingFetchProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/summary`,
    props,
    signal
  )

export interface GetBuildDetailsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetBuildDetailsForDockerProps = Omit<
  GetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const GetBuildDetailsForDocker = (props: GetBuildDetailsForDockerProps) => (
  <Get<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>
    path="/artifacts/docker/getBuildDetails"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForDockerProps = Omit<
  UseGetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const useGetBuildDetailsForDocker = (props: UseGetBuildDetailsForDockerProps) =>
  useGet<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    `/artifacts/docker/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker build details
 */
export const getBuildDetailsForDockerPromise = (
  props: GetUsingFetchProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/getBuildDetails`,
    props,
    signal
  )

export interface ValidateArtifactServerForDockerQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactServerForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const ValidateArtifactServerForDocker = (props: ValidateArtifactServerForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>
    path="/artifacts/docker/validateArtifactServer"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const useValidateArtifactServerForDocker = (props: UseValidateArtifactServerForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact server
 */
export const validateArtifactServerForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactImageForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const ValidateArtifactImageForDocker = (props: ValidateArtifactImageForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>
    path="/artifacts/docker/validateArtifactSource"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const useValidateArtifactImageForDocker = (props: UseValidateArtifactImageForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker image
 */
export const validateArtifactImageForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactSource`,
    props,
    signal
  )

export interface ValidateArtifactForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const ValidateArtifactForDocker = (props: ValidateArtifactForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, void>
    path="/artifacts/docker/validateArtifact"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const useValidateArtifactForDocker = (props: UseValidateArtifactForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const validateArtifactForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifact`,
    props,
    signal
  )

export interface GetLastSuccessfulBuildForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLastSuccessfulBuildForDockerProps = Omit<
  MutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const GetLastSuccessfulBuildForDocker = (props: GetLastSuccessfulBuildForDockerProps) => (
  <Mutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >
    verb="POST"
    path="/artifacts/docker/getLastSuccessfulBuild"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const useGetLastSuccessfulBuildForDocker = (props: UseGetLastSuccessfulBuildForDockerProps) =>
  useMutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker last successful build
 */
export const getLastSuccessfulBuildForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLastSuccessfulBuild`, props, signal)

export interface GetLabelsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLabelsForDockerProps = Omit<
  MutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const GetLabelsForDocker = (props: GetLabelsForDockerProps) => (
  <Mutate<ResponseDockerResponseDTO, Failure | Error, GetLabelsForDockerQueryParams, DockerRequestDTORequestBody, void>
    verb="POST"
    path="/artifacts/docker/getLabels"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLabelsForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const useGetLabelsForDocker = (props: UseGetLabelsForDockerProps) =>
  useMutate<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLabels`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker labels
 */
export const getLabelsForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLabels`, props, signal)

export interface GetBuildDetailsForEcrQueryParams {
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetBuildDetailsForEcrProps = Omit<
  GetProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr build details
 */
export const GetBuildDetailsForEcr = (props: GetBuildDetailsForEcrProps) => (
  <Get<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>
    path="/artifacts/ecr/getBuildDetails"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForEcrProps = Omit<
  UseGetProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr build details
 */
export const useGetBuildDetailsForEcr = (props: UseGetBuildDetailsForEcrProps) =>
  useGet<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>(
    `/artifacts/ecr/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets ecr build details
 */
export const getBuildDetailsForEcrPromise = (
  props: GetUsingFetchProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/getBuildDetails`,
    props,
    signal
  )

export interface ValidateArtifactServerForEcrQueryParams {
  imagePath: string
  connectorRef: string
  region: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactServerForEcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  'path'
>

/**
 * Validate ecr artifact server
 */
export const ValidateArtifactServerForEcr = (props: ValidateArtifactServerForEcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>
    path="/artifacts/ecr/validateArtifactServer"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForEcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  'path'
>

/**
 * Validate ecr artifact server
 */
export const useValidateArtifactServerForEcr = (props: UseValidateArtifactServerForEcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>(
    `/artifacts/ecr/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate ecr artifact server
 */
export const validateArtifactServerForEcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForEcrQueryParams {
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactImageForEcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr image
 */
export const ValidateArtifactImageForEcr = (props: ValidateArtifactImageForEcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>
    path="/artifacts/ecr/validateArtifactSource"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForEcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr image
 */
export const useValidateArtifactImageForEcr = (props: UseValidateArtifactImageForEcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>(
    `/artifacts/ecr/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Ecr image
 */
export const validateArtifactImageForEcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifactSource`,
    props,
    signal
  )

export interface ValidateArtifactForEcrQueryParams {
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactForEcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr Artifact
 */
export const ValidateArtifactForEcr = (props: ValidateArtifactForEcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, void>
    path="/artifacts/ecr/validateArtifact"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForEcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr Artifact
 */
export const useValidateArtifactForEcr = (props: UseValidateArtifactForEcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, void>(`/artifacts/ecr/validateArtifact`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Validate Ecr Artifact
 */
export const validateArtifactForEcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifact`,
    props,
    signal
  )

export interface GetLastSuccessfulBuildForEcrQueryParams {
  imagePath: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLastSuccessfulBuildForEcrProps = Omit<
  MutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build
 */
export const GetLastSuccessfulBuildForEcr = (props: GetLastSuccessfulBuildForEcrProps) => (
  <Mutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path="/artifacts/ecr/getLastSuccessfulBuild"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForEcrProps = Omit<
  UseMutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build
 */
export const useGetLastSuccessfulBuildForEcr = (props: UseGetLastSuccessfulBuildForEcrProps) =>
  useMutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/ecr/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ecr last successful build
 */
export const getLastSuccessfulBuildForEcrPromise = (
  props: MutateUsingFetchProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ecr/getLastSuccessfulBuild`, props, signal)

export interface GetBuildDetailsForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetBuildDetailsForGcrProps = Omit<
  GetProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  'path'
>

/**
 * Gets gcr build details
 */
export const GetBuildDetailsForGcr = (props: GetBuildDetailsForGcrProps) => (
  <Get<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>
    path="/artifacts/gcr/getBuildDetails"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForGcrProps = Omit<
  UseGetProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  'path'
>

/**
 * Gets gcr build details
 */
export const useGetBuildDetailsForGcr = (props: UseGetBuildDetailsForGcrProps) =>
  useGet<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>(
    `/artifacts/gcr/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets gcr build details
 */
export const getBuildDetailsForGcrPromise = (
  props: GetUsingFetchProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/getBuildDetails`,
    props,
    signal
  )

export interface ValidateArtifactServerForGcrQueryParams {
  imagePath: string
  connectorRef: string
  registryHostname: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactServerForGcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  'path'
>

/**
 * Validate gcr artifact server
 */
export const ValidateArtifactServerForGcr = (props: ValidateArtifactServerForGcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>
    path="/artifacts/gcr/validateArtifactServer"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForGcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  'path'
>

/**
 * Validate gcr artifact server
 */
export const useValidateArtifactServerForGcr = (props: UseValidateArtifactServerForGcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>(
    `/artifacts/gcr/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate gcr artifact server
 */
export const validateArtifactServerForGcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactImageForGcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr image
 */
export const ValidateArtifactImageForGcr = (props: ValidateArtifactImageForGcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>
    path="/artifacts/gcr/validateArtifactSource"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForGcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr image
 */
export const useValidateArtifactImageForGcr = (props: UseValidateArtifactImageForGcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>(
    `/artifacts/gcr/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Gcr image
 */
export const validateArtifactImageForGcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifactSource`,
    props,
    signal
  )

export interface ValidateArtifactForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactForGcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr Artifact
 */
export const ValidateArtifactForGcr = (props: ValidateArtifactForGcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, void>
    path="/artifacts/gcr/validateArtifact"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForGcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr Artifact
 */
export const useValidateArtifactForGcr = (props: UseValidateArtifactForGcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, void>(`/artifacts/gcr/validateArtifact`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Validate Gcr Artifact
 */
export const validateArtifactForGcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifact`,
    props,
    signal
  )

export interface GetLastSuccessfulBuildForGcrQueryParams {
  imagePath: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLastSuccessfulBuildForGcrProps = Omit<
  MutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build
 */
export const GetLastSuccessfulBuildForGcr = (props: GetLastSuccessfulBuildForGcrProps) => (
  <Mutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path="/artifacts/gcr/getLastSuccessfulBuild"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForGcrProps = Omit<
  UseMutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build
 */
export const useGetLastSuccessfulBuildForGcr = (props: UseGetLastSuccessfulBuildForGcrProps) =>
  useMutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/gcr/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets gcr last successful build
 */
export const getLastSuccessfulBuildForGcrPromise = (
  props: MutateUsingFetchProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gcr/getLastSuccessfulBuild`, props, signal)

export interface ListDelegateProfilesNgQueryParams {
  offset?: string
  limit?: string
  fieldsIncluded?: string[]
  fieldsExcluded?: string[]
  accountId?: string
  orgId?: string
  projectId?: string
}

export type ListDelegateProfilesNgProps = Omit<
  GetProps<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>,
  'path'
>

/**
 * Lists the delegate profiles
 */
export const ListDelegateProfilesNg = (props: ListDelegateProfilesNgProps) => (
  <Get<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>
    path="/delegate-profiles/ng"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateProfilesNgProps = Omit<
  UseGetProps<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>,
  'path'
>

/**
 * Lists the delegate profiles
 */
export const useListDelegateProfilesNg = (props: UseListDelegateProfilesNgProps) =>
  useGet<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>(
    `/delegate-profiles/ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists the delegate profiles
 */
export const listDelegateProfilesNgPromise = (
  props: GetUsingFetchProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateProfilesNgQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-profiles/ng`,
    props,
    signal
  )

export interface AddDelegateProfileNgQueryParams {
  accountId?: string
}

export type AddDelegateProfileNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Adds a delegate profile
 */
export const AddDelegateProfileNg = (props: AddDelegateProfileNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >
    verb="POST"
    path="/delegate-profiles/ng"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddDelegateProfileNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Adds a delegate profile
 */
export const useAddDelegateProfileNg = (props: UseAddDelegateProfileNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >('POST', `/delegate-profiles/ng`, { base: getConfig('ng/api'), ...props })

/**
 * Adds a delegate profile
 */
export const addDelegateProfileNgPromise = (
  props: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >('POST', getConfig('ng/api'), `/delegate-profiles/ng`, props, signal)

export interface GetDelegateProfileNgQueryParams {
  accountId?: string
}

export interface GetDelegateProfileNgPathParams {
  delegateProfileId: string
}

export type GetDelegateProfileNgProps = Omit<
  GetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >,
  'path'
> &
  GetDelegateProfileNgPathParams

/**
 * Gets delegate profile
 */
export const GetDelegateProfileNg = ({ delegateProfileId, ...props }: GetDelegateProfileNgProps) => (
  <Get<RestResponseDelegateProfileDetailsNg, unknown, GetDelegateProfileNgQueryParams, GetDelegateProfileNgPathParams>
    path="/delegate-profiles/ng/${delegateProfileId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateProfileNgProps = Omit<
  UseGetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >,
  'path'
> &
  GetDelegateProfileNgPathParams

/**
 * Gets delegate profile
 */
export const useGetDelegateProfileNg = ({ delegateProfileId, ...props }: UseGetDelegateProfileNgProps) =>
  useGet<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >((paramsInPath: GetDelegateProfileNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}`, {
    base: getConfig('ng/api'),
    pathParams: { delegateProfileId },
    ...props
  })

/**
 * Gets delegate profile
 */
export const getDelegateProfileNgPromise = (
  {
    delegateProfileId,
    ...props
  }: GetUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >(getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}`, props, signal)

export interface UpdateDelegateProfileNgQueryParams {
  accountId?: string
}

export interface UpdateDelegateProfileNgPathParams {
  delegateProfileId: string
}

export type UpdateDelegateProfileNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateProfileNgPathParams

/**
 * Updates a delegate profile
 */
export const UpdateDelegateProfileNg = ({ delegateProfileId, ...props }: UpdateDelegateProfileNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >
    verb="PUT"
    path="/delegate-profiles/ng/${delegateProfileId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateDelegateProfileNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateProfileNgPathParams

/**
 * Updates a delegate profile
 */
export const useUpdateDelegateProfileNg = ({ delegateProfileId, ...props }: UseUpdateDelegateProfileNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateDelegateProfileNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates a delegate profile
 */
export const updateDelegateProfileNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}`, props, signal)

export interface DeleteDelegateProfileNgQueryParams {
  accountId?: string
}

export type DeleteDelegateProfileNgProps = Omit<
  MutateProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a delegate profile
 */
export const DeleteDelegateProfileNg = (props: DeleteDelegateProfileNgProps) => (
  <Mutate<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>
    verb="DELETE"
    path="/delegate-profiles/ng"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteDelegateProfileNgProps = Omit<
  UseMutateProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a delegate profile
 */
export const useDeleteDelegateProfileNg = (props: UseDeleteDelegateProfileNgProps) =>
  useMutate<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>(
    'DELETE',
    `/delegate-profiles/ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes a delegate profile
 */
export const deleteDelegateProfileNgPromise = (
  props: MutateUsingFetchProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/delegate-profiles/ng`,
    props,
    signal
  )

export interface UpdateScopingRulesNgQueryParams {
  accountId?: string
}

export interface UpdateScopingRulesNgPathParams {
  delegateProfileId: string
}

export type UpdateScopingRulesNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNg[],
    UpdateScopingRulesNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgPathParams

/**
 * Updates the scoping rules inside the delegate profile
 */
export const UpdateScopingRulesNg = ({ delegateProfileId, ...props }: UpdateScopingRulesNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNg[],
    UpdateScopingRulesNgPathParams
  >
    verb="PUT"
    path="/delegate-profiles/ng/${delegateProfileId}/scoping-rules"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScopingRulesNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNg[],
    UpdateScopingRulesNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgPathParams

/**
 * Updates the scoping rules inside the delegate profile
 */
export const useUpdateScopingRulesNg = ({ delegateProfileId, ...props }: UseUpdateScopingRulesNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNg[],
    UpdateScopingRulesNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateScopingRulesNgPathParams) =>
      `/delegate-profiles/ng/${paramsInPath.delegateProfileId}/scoping-rules`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates the scoping rules inside the delegate profile
 */
export const updateScopingRulesNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNg[],
    UpdateScopingRulesNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNg[],
    UpdateScopingRulesNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}/scoping-rules`, props, signal)

export interface UpdateSelectorsNgQueryParams {
  accountId?: string
}

export interface UpdateSelectorsNgPathParams {
  delegateProfileId: string
}

export type UpdateSelectorsNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgPathParams

/**
 * Updates the selectors inside the delegate profile
 */
export const UpdateSelectorsNg = ({ delegateProfileId, ...props }: UpdateSelectorsNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >
    verb="PUT"
    path="/delegate-profiles/ng/${delegateProfileId}/selectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSelectorsNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgPathParams

/**
 * Updates the selectors inside the delegate profile
 */
export const useUpdateSelectorsNg = ({ delegateProfileId, ...props }: UseUpdateSelectorsNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateSelectorsNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}/selectors`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates the selectors inside the delegate profile
 */
export const updateSelectorsNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}/selectors`, props, signal)

export interface SyncTaskD2QueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SyncTaskD2Props = Omit<
  MutateProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync task using Delegate 2.0 framework
 */
export const SyncTaskD2 = (props: SyncTaskD2Props) => (
  <Mutate<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>
    verb="POST"
    path="/delegate2-tasks/sync"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncTaskD2Props = Omit<
  UseMutateProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync task using Delegate 2.0 framework
 */
export const useSyncTaskD2 = (props: UseSyncTaskD2Props) =>
  useMutate<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>('POST', `/delegate2-tasks/sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync task using Delegate 2.0 framework
 */
export const syncTaskD2Promise = (
  props: MutateUsingFetchProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate2-tasks/sync`,
    props,
    signal
  )

export interface AsyncTaskD2QueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type AsyncTaskD2Props = Omit<MutateProps<string, unknown, AsyncTaskD2QueryParams, void, void>, 'path' | 'verb'>

/**
 * Create a delegate tasks
 */
export const AsyncTaskD2 = (props: AsyncTaskD2Props) => (
  <Mutate<string, unknown, AsyncTaskD2QueryParams, void, void>
    verb="POST"
    path="/delegate2-tasks/async"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAsyncTaskD2Props = Omit<
  UseMutateProps<string, unknown, AsyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a delegate tasks
 */
export const useAsyncTaskD2 = (props: UseAsyncTaskD2Props) =>
  useMutate<string, unknown, AsyncTaskD2QueryParams, void, void>('POST', `/delegate2-tasks/async`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a delegate tasks
 */
export const asyncTaskD2Promise = (
  props: MutateUsingFetchProps<string, unknown, AsyncTaskD2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<string, unknown, AsyncTaskD2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate2-tasks/async`,
    props,
    signal
  )

export interface ListReferredByEntitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  referredEntityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  searchTerm?: string
}

export type ListReferredByEntitiesProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const ListReferredByEntities = (props: ListReferredByEntitiesProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>
    path="/entitySetupUsage"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListReferredByEntitiesProps = Omit<
  UseGetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const useListReferredByEntities = (props: UseListReferredByEntitiesProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(`/entitySetupUsage`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Entities referring this resource
 */
export const listReferredByEntitiesPromise = (
  props: GetUsingFetchProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(
    getConfig('ng/api'),
    `/entitySetupUsage`,
    props,
    signal
  )

export interface GetEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetEnvironmentPathParams {
  environmentIdentifier: string
}

export type GetEnvironmentProps = Omit<
  GetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironment = ({ environmentIdentifier, ...props }: GetEnvironmentProps) => (
  <Get<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>
    path="/environments/${environmentIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentProps = Omit<
  UseGetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironment = ({ environmentIdentifier, ...props }: UseGetEnvironmentProps) =>
  useGet<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    (paramsInPath: GetEnvironmentPathParams) => `/environments/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentPromise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    getConfig('ng/api'),
    `/environments/${environmentIdentifier}`,
    props,
    signal
  )

export interface DeleteEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteEnvironmentProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironment = (props: DeleteEnvironmentProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>
    verb="DELETE"
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironment = (props: UseDeleteEnvironmentProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>('DELETE', `/environments`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface GetEnvironmentListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  envIdentifiers?: string[]
  sort?: string[]
}

export type GetEnvironmentListForProjectProps = Omit<
  GetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const GetEnvironmentListForProject = (props: GetEnvironmentListForProjectProps) => (
  <Get<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListForProjectProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const useGetEnvironmentListForProject = (props: UseGetEnvironmentListForProjectProps) =>
  useGet<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    `/environments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets environment list for a project
 */
export const getEnvironmentListForProjectPromise = (
  props: GetUsingFetchProps<
    ResponsePageEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentListForProjectQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface CreateEnvironmentQueryParams {
  accountId?: string
}

export type CreateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironment = (props: CreateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironment = (props: UseCreateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environments`, props, signal)

export interface UpdateEnvironmentQueryParams {
  accountId?: string
}

export type UpdateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironment = (props: UpdateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironment = (props: UseUpdateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments`, props, signal)

export interface UpsertEnvironmentQueryParams {
  accountId?: string
}

export type UpsertEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironment = (props: UpsertEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path="/environments/upsert"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironment = (props: UseUpsertEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments/upsert`, props, signal)

export interface GetEnvironmentV2QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetEnvironmentV2PathParams {
  environmentIdentifier: string
}

export type GetEnvironmentV2Props = Omit<
  GetProps<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>,
  'path'
> &
  GetEnvironmentV2PathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironmentV2 = ({ environmentIdentifier, ...props }: GetEnvironmentV2Props) => (
  <Get<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>
    path="/environmentsV2/${environmentIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentV2Props = Omit<
  UseGetProps<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>,
  'path'
> &
  GetEnvironmentV2PathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironmentV2 = ({ environmentIdentifier, ...props }: UseGetEnvironmentV2Props) =>
  useGet<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>(
    (paramsInPath: GetEnvironmentV2PathParams) => `/environmentsV2/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentV2Promise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    GetEnvironmentV2QueryParams,
    GetEnvironmentV2PathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>(
    getConfig('ng/api'),
    `/environmentsV2/${environmentIdentifier}`,
    props,
    signal
  )

export interface DeleteEnvironmentV2QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteEnvironmentV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironmentV2 = (props: DeleteEnvironmentV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>
    verb="DELETE"
    path="/environmentsV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironmentV2 = (props: UseDeleteEnvironmentV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>(
    'DELETE',
    `/environmentsV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environmentsV2`,
    props,
    signal
  )

export interface GetEnvironmentListQueryParams {
  page?: number
  size?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  envIdentifiers?: string[]
  sort?: string[]
}

export type GetEnvironmentListProps = Omit<
  GetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  'path'
>

/**
 * Gets environment list
 */
export const GetEnvironmentList = (props: GetEnvironmentListProps) => (
  <Get<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>
    path="/environmentsV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  'path'
>

/**
 * Gets environment list
 */
export const useGetEnvironmentList = (props: UseGetEnvironmentListProps) =>
  useGet<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>(`/environmentsV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets environment list
 */
export const getEnvironmentListPromise = (
  props: GetUsingFetchProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2`,
    props,
    signal
  )

export interface CreateEnvironmentV2QueryParams {
  accountIdentifier?: string
}

export type CreateEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironmentV2 = (props: CreateEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path="/environmentsV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironmentV2 = (props: UseCreateEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environmentsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2`, props, signal)

export interface UpdateEnvironmentV2QueryParams {
  accountIdentifier?: string
}

export type UpdateEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironmentV2 = (props: UpdateEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path="/environmentsV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironmentV2 = (props: UseUpdateEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environmentsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environmentsV2`, props, signal)

export interface UpsertEnvironmentV2QueryParams {
  accountIdentifier?: string
}

export type UpsertEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironmentV2 = (props: UpsertEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path="/environmentsV2/upsert"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironmentV2 = (props: UseUpsertEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environmentsV2/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environmentsV2/upsert`, props, signal)

export interface UpdateInviteQueryParams {
  accountIdentifier?: string
}

export interface UpdateInvitePathParams {
  inviteId: string
}

export type UpdateInviteProps = Omit<
  MutateProps<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const UpdateInvite = ({ inviteId, ...props }: UpdateInviteProps) => (
  <Mutate<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>
    verb="PUT"
    path="/invites/${inviteId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInviteProps = Omit<
  UseMutateProps<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const useUpdateInvite = ({ inviteId, ...props }: UseUpdateInviteProps) =>
  useMutate<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>(
    'PUT',
    (paramsInPath: UpdateInvitePathParams) => `/invites/${paramsInPath.inviteId}`,
    { base: getConfig('ng/api'), pathParams: { inviteId }, ...props }
  )

/**
 * Resend invite mail
 */
export const updateInvitePromise = (
  {
    inviteId,
    ...props
  }: MutateUsingFetchProps<
    ResponseOptionalInvite,
    Failure | Error,
    UpdateInviteQueryParams,
    Invite,
    UpdateInvitePathParams
  > & { inviteId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/invites/${inviteId}`,
    props,
    signal
  )

export type DeleteInviteProps = Omit<
  MutateProps<ResponseOptionalInvite, Failure | Error, void, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const DeleteInvite = (props: DeleteInviteProps) => (
  <Mutate<ResponseOptionalInvite, Failure | Error, void, string, void>
    verb="DELETE"
    path="/invites"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInviteProps = Omit<
  UseMutateProps<ResponseOptionalInvite, Failure | Error, void, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const useDeleteInvite = (props: UseDeleteInviteProps) =>
  useMutate<ResponseOptionalInvite, Failure | Error, void, string, void>('DELETE', `/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a invite for the specified project/organization
 */
export const deleteInvitePromise = (
  props: MutateUsingFetchProps<ResponseOptionalInvite, Failure | Error, void, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOptionalInvite, Failure | Error, void, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface GetInvitesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetInvitesProps = Omit<GetProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>, 'path'>

/**
 * Get all invites for the queried project/organization
 */
export const GetInvites = (props: GetInvitesProps) => (
  <Get<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>
    path="/invites"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInvitesProps = Omit<
  UseGetProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>,
  'path'
>

/**
 * Get all invites for the queried project/organization
 */
export const useGetInvites = (props: UseGetInvitesProps) =>
  useGet<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>(`/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all invites for the queried project/organization
 */
export const getInvitesPromise = (
  props: GetUsingFetchProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>(
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface SendInviteQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SendInviteProps = Omit<
  MutateProps<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project/organization
 */
export const SendInvite = (props: SendInviteProps) => (
  <Mutate<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>
    verb="POST"
    path="/invites"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSendInviteProps = Omit<
  UseMutateProps<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project/organization
 */
export const useSendInvite = (props: UseSendInviteProps) =>
  useMutate<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>(
    'POST',
    `/invites`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Add a new invite for the specified project/organization
 */
export const sendInvitePromise = (
  props: MutateUsingFetchProps<
    ResponseListInviteOperationResponse,
    Failure | Error,
    SendInviteQueryParams,
    CreateInvite,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>(
    'POST',
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface GetPendingUsersAggregatedQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetPendingUsersAggregatedProps = Omit<
  MutateProps<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of pending users for access control
 */
export const GetPendingUsersAggregated = (props: GetPendingUsersAggregatedProps) => (
  <Mutate<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>
    verb="POST"
    path="/invites/aggregate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPendingUsersAggregatedProps = Omit<
  UseMutateProps<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of pending users for access control
 */
export const useGetPendingUsersAggregated = (props: UseGetPendingUsersAggregatedProps) =>
  useMutate<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>(
    'POST',
    `/invites/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a page of pending users for access control
 */
export const getPendingUsersAggregatedPromise = (
  props: MutateUsingFetchProps<
    ResponsePageInvite,
    Failure | Error,
    GetPendingUsersAggregatedQueryParams,
    ACLAggregateFilter,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>(
    'POST',
    getConfig('ng/api'),
    `/invites/aggregate`,
    props,
    signal
  )

export interface GetClusterNamesForGcpQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetClusterNamesForGcpProps = Omit<
  GetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names
 */
export const GetClusterNamesForGcp = (props: GetClusterNamesForGcpProps) => (
  <Get<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>
    path="/gcp/clusters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetClusterNamesForGcpProps = Omit<
  UseGetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names
 */
export const useGetClusterNamesForGcp = (props: UseGetClusterNamesForGcpProps) =>
  useGet<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>(`/gcp/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets gcp cluster names
 */
export const getClusterNamesForGcpPromise = (
  props: GetUsingFetchProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>(
    getConfig('ng/api'),
    `/gcp/clusters`,
    props,
    signal
  )

export type GetNGManagerHealthStatusProps = Omit<GetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * get health for NGManager service
 */
export const GetNGManagerHealthStatus = (props: GetNGManagerHealthStatusProps) => (
  <Get<ResponseString, unknown, void, void> path="/health" base={getConfig('ng/api')} {...props} />
)

export type UseGetNGManagerHealthStatusProps = Omit<UseGetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * get health for NGManager service
 */
export const useGetNGManagerHealthStatus = (props: UseGetNGManagerHealthStatusProps) =>
  useGet<ResponseString, unknown, void, void>(`/health`, { base: getConfig('ng/api'), ...props })

/**
 * get health for NGManager service
 */
export const getNGManagerHealthStatusPromise = (
  props: GetUsingFetchProps<ResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<ResponseString, unknown, void, void>(getConfig('ng/api'), `/health`, props, signal)

export interface GetOrganizationAggregateDTOQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationAggregateDTOPathParams {
  identifier: string
}

export type GetOrganizationAggregateDTOProps = Omit<
  GetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const GetOrganizationAggregateDTO = ({ identifier, ...props }: GetOrganizationAggregateDTOProps) => (
  <Get<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >
    path="/aggregate/organizations/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOProps = Omit<
  UseGetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const useGetOrganizationAggregateDTO = ({ identifier, ...props }: UseGetOrganizationAggregateDTOProps) =>
  useGet<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >((paramsInPath: GetOrganizationAggregateDTOPathParams) => `/aggregate/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const getOrganizationAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/organizations/${identifier}`, props, signal)

export interface GetProjectAggregateDTOQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectAggregateDTOPathParams {
  identifier: string
}

export type GetProjectAggregateDTOProps = Omit<
  GetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const GetProjectAggregateDTO = ({ identifier, ...props }: GetProjectAggregateDTOProps) => (
  <Get<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >
    path="/aggregate/projects/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOProps = Omit<
  UseGetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const useGetProjectAggregateDTO = ({ identifier, ...props }: UseGetProjectAggregateDTOProps) =>
  useGet<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >((paramsInPath: GetProjectAggregateDTOPathParams) => `/aggregate/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const getProjectAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/projects/${identifier}`, props, signal)

export interface GetUserGroupAggregateListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  searchTerm?: string
  userSize?: number
}

export type GetUserGroupAggregateListProps = Omit<
  GetProps<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>,
  'path'
>

/**
 * Get Aggregated User Group list
 */
export const GetUserGroupAggregateList = (props: GetUserGroupAggregateListProps) => (
  <Get<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>
    path="/aggregate/acl/usergroups"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateListProps = Omit<
  UseGetProps<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>,
  'path'
>

/**
 * Get Aggregated User Group list
 */
export const useGetUserGroupAggregateList = (props: UseGetUserGroupAggregateListProps) =>
  useGet<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>(
    `/aggregate/acl/usergroups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Aggregated User Group list
 */
export const getUserGroupAggregateListPromise = (
  props: GetUsingFetchProps<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/acl/usergroups`,
    props,
    signal
  )

export interface GetUserGroupAggregateListsWithFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetUserGroupAggregateListsWithFilterProps = Omit<
  MutateProps<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Aggregated User Group list with filter
 */
export const GetUserGroupAggregateListsWithFilter = (props: GetUserGroupAggregateListsWithFilterProps) => (
  <Mutate<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >
    verb="POST"
    path="/aggregate/acl/usergroups/filter"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateListsWithFilterProps = Omit<
  UseMutateProps<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Aggregated User Group list with filter
 */
export const useGetUserGroupAggregateListsWithFilter = (props: UseGetUserGroupAggregateListsWithFilterProps) =>
  useMutate<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >('POST', `/aggregate/acl/usergroups/filter`, { base: getConfig('ng/api'), ...props })

/**
 * Get Aggregated User Group list with filter
 */
export const getUserGroupAggregateListsWithFilterPromise = (
  props: MutateUsingFetchProps<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >('POST', getConfig('ng/api'), `/aggregate/acl/usergroups/filter`, props, signal)

export interface GetUserGroupAggregateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetUserGroupAggregatePathParams {
  identifier: string
}

export type GetUserGroupAggregateProps = Omit<
  GetProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >,
  'path'
> &
  GetUserGroupAggregatePathParams

/**
 * Get Aggregated User Group
 */
export const GetUserGroupAggregate = ({ identifier, ...props }: GetUserGroupAggregateProps) => (
  <Get<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >
    path="/aggregate/acl/usergroups/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateProps = Omit<
  UseGetProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >,
  'path'
> &
  GetUserGroupAggregatePathParams

/**
 * Get Aggregated User Group
 */
export const useGetUserGroupAggregate = ({ identifier, ...props }: UseGetUserGroupAggregateProps) =>
  useGet<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >((paramsInPath: GetUserGroupAggregatePathParams) => `/aggregate/acl/usergroups/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get Aggregated User Group
 */
export const getUserGroupAggregatePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >(getConfig('ng/api'), `/aggregate/acl/usergroups/${identifier}`, props, signal)

export interface GetOrganizationAggregateDTOListQueryParams {
  accountIdentifier: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetOrganizationAggregateDTOListProps = Omit<
  GetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const GetOrganizationAggregateDTOList = (props: GetOrganizationAggregateDTOListProps) => (
  <Get<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>
    path="/aggregate/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const useGetOrganizationAggregateDTOList = (props: UseGetOrganizationAggregateDTOListProps) =>
  useGet<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>(
    `/aggregate/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get OrganizationAggregateDTO list
 */
export const getOrganizationAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >(getConfig('ng/api'), `/aggregate/organizations`, props, signal)

export interface GetProjectAggregateDTOListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetProjectAggregateDTOListProps = Omit<
  GetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const GetProjectAggregateDTOList = (props: GetProjectAggregateDTOListProps) => (
  <Get<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>
    path="/aggregate/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const useGetProjectAggregateDTOList = (props: UseGetProjectAggregateDTOListProps) =>
  useGet<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    `/aggregate/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ProjectAggregateDTO list
 */
export const getProjectAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/projects`,
    props,
    signal
  )

export interface PutSecretFilePathParams {
  identifier: string
}

export type PutSecretFileProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>,
  'path' | 'verb'
> &
  PutSecretFilePathParams

/**
 * Update a secret file
 */
export const PutSecretFile = ({ identifier, ...props }: PutSecretFileProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>
    verb="PUT"
    path="/secrets/files/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>,
  'path' | 'verb'
> &
  PutSecretFilePathParams

/**
 * Update a secret file
 */
export const usePutSecretFile = ({ identifier, ...props }: UsePutSecretFileProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>(
    'PUT',
    (paramsInPath: PutSecretFilePathParams) => `/secrets/files/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret file
 */
export const putSecretFilePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/files/${identifier}`,
    props,
    signal
  )

export interface PutSecretFileViaYamlPathParams {
  identifier: string
}

export type PutSecretFileViaYamlProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretFileViaYamlPathParams

/**
 * Update a secret file via yaml
 */
export const PutSecretFileViaYaml = ({ identifier, ...props }: PutSecretFileViaYamlProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>
    verb="PUT"
    path="/secrets/files/${identifier}/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileViaYamlProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretFileViaYamlPathParams

/**
 * Update a secret file via yaml
 */
export const usePutSecretFileViaYaml = ({ identifier, ...props }: UsePutSecretFileViaYamlProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>(
    'PUT',
    (paramsInPath: PutSecretFileViaYamlPathParams) => `/secrets/files/${paramsInPath.identifier}/yaml`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret file via yaml
 */
export const putSecretFileViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    void,
    SecretFileDTORequestBody,
    PutSecretFileViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/files/${identifier}/yaml`,
    props,
    signal
  )

export type PostSecretFileViaYamlProps = Omit<
  MutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret file via yaml
 */
export const PostSecretFileViaYaml = (props: PostSecretFileViaYamlProps) => (
  <Mutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>
    verb="POST"
    path="/secrets/files/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileViaYamlProps = Omit<
  UseMutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret file via yaml
 */
export const usePostSecretFileViaYaml = (props: UsePostSecretFileViaYamlProps) =>
  useMutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>(
    'POST',
    `/secrets/files/yaml`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret file via yaml
 */
export const postSecretFileViaYamlPromise = (
  props: MutateUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets/files/yaml`,
    props,
    signal
  )

export interface GetMetadataQueryParams {
  accountIdentifier: string
}

export type GetMetadataProps = Omit<
  MutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const GetMetadata = (props: GetMetadataProps) => (
  <Mutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >
    verb="POST"
    path="/secret-managers/meta-data"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMetadataProps = Omit<
  UseMutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const useGetMetadata = (props: UseGetMetadataProps) =>
  useMutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', `/secret-managers/meta-data`, { base: getConfig('ng/api'), ...props })

/**
 * Get metadata of secret manager
 */
export const getMetadataPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/secret-managers/meta-data`, props, signal)

export interface GetSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretPathParams {
  identifier: string
}

export type GetSecretProps = Omit<
  GetProps<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>,
  'path'
> &
  GetSecretPathParams

/**
 * Gets secret
 */
export const GetSecret = ({ identifier, ...props }: GetSecretProps) => (
  <Get<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>
    path="/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretProps = Omit<
  UseGetProps<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>,
  'path'
> &
  GetSecretPathParams

/**
 * Gets secret
 */
export const useGetSecret = ({ identifier, ...props }: UseGetSecretProps) =>
  useGet<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>(
    (paramsInPath: GetSecretPathParams) => `/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>(
    getConfig('ng/api'),
    `/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretTextPathParams {
  identifier: string
}

export type PutSecretTextProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>,
  'path' | 'verb'
> &
  PutSecretTextPathParams

/**
 * Update a secret text
 */
export const PutSecretText = ({ identifier, ...props }: PutSecretTextProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>
    verb="PUT"
    path="/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretTextProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>,
  'path' | 'verb'
> &
  PutSecretTextPathParams

/**
 * Update a secret text
 */
export const usePutSecretText = ({ identifier, ...props }: UsePutSecretTextProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>(
    'PUT',
    (paramsInPath: PutSecretTextPathParams) => `/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret text
 */
export const putSecretTextPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    void,
    SecretTextDTO2RequestBody,
    PutSecretTextPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/${identifier}`,
    props,
    signal
  )

export interface DeleteSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const DeleteSecret = (props: DeleteSecretProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>
    verb="DELETE"
    path="/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const useDeleteSecret = (props: UseDeleteSecretProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>('DELETE', `/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a secret text
 */
export const deleteSecretPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export interface ListSecretsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
}

export type ListSecretsProps = Omit<
  GetProps<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const ListSecrets = (props: ListSecretsProps) => (
  <Get<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>
    path="/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsProps = Omit<
  UseGetProps<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const useListSecrets = (props: UseListSecretsProps) =>
  useGet<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>(`/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get secrets for an account
 */
export const listSecretsPromise = (
  props: GetUsingFetchProps<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>(
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export type PostSecretTextProps = Omit<
  MutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const PostSecretText = (props: PostSecretTextProps) => (
  <Mutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>
    verb="POST"
    path="/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretTextProps = Omit<
  UseMutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const usePostSecretText = (props: UsePostSecretTextProps) =>
  useMutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>('POST', `/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a secret text
 */
export const postSecretTextPromise = (
  props: MutateUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export type PostSecretTextViaYamlProps = Omit<
  MutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text via yaml
 */
export const PostSecretTextViaYaml = (props: PostSecretTextViaYamlProps) => (
  <Mutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>
    verb="POST"
    path="/secrets/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretTextViaYamlProps = Omit<
  UseMutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text via yaml
 */
export const usePostSecretTextViaYaml = (props: UsePostSecretTextViaYamlProps) =>
  useMutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>('POST', `/secrets/yaml`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a secret text via yaml
 */
export const postSecretTextViaYamlPromise = (
  props: MutateUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets/yaml`,
    props,
    signal
  )

export interface PutSecretTextViaYamlPathParams {
  identifier: string
}

export type PutSecretTextViaYamlProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretTextViaYamlPathParams

/**
 * Update a secret text via yaml
 */
export const PutSecretTextViaYaml = ({ identifier, ...props }: PutSecretTextViaYamlProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>
    verb="PUT"
    path="/secrets/${identifier}/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretTextViaYamlProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretTextViaYamlPathParams

/**
 * Update a secret text via yaml
 */
export const usePutSecretTextViaYaml = ({ identifier, ...props }: UsePutSecretTextViaYamlProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>(
    'PUT',
    (paramsInPath: PutSecretTextViaYamlPathParams) => `/secrets/${paramsInPath.identifier}/yaml`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret text via yaml
 */
export const putSecretTextViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    void,
    SecretTextDTORequestBody,
    PutSecretTextViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/${identifier}/yaml`,
    props,
    signal
  )

export interface GetSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretV2PathParams {
  identifier: string
}

export type GetSecretV2Props = Omit<
  GetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const GetSecretV2 = ({ identifier, ...props }: GetSecretV2Props) => (
  <Get<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>
    path="/v2/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretV2Props = Omit<
  UseGetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const useGetSecretV2 = ({ identifier, ...props }: UseGetSecretV2Props) =>
  useGet<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    (paramsInPath: GetSecretV2PathParams) => `/v2/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretV2Promise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    GetSecretV2QueryParams,
    GetSecretV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    getConfig('ng/api'),
    `/v2/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretPathParams {
  identifier: string
}

export type PutSecretProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const PutSecret = ({ identifier, ...props }: PutSecretProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >
    verb="PUT"
    path="/v2/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const usePutSecret = ({ identifier, ...props }: UsePutSecretProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', (paramsInPath: PutSecretPathParams) => `/v2/secrets/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret
 */
export const putSecretPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}`, props, signal)

export interface DeleteSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const DeleteSecretV2 = (props: DeleteSecretV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>
    verb="DELETE"
    path="/v2/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const useDeleteSecretV2 = (props: UseDeleteSecretV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>('DELETE', `/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete secret
 */
export const deleteSecretV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface ListSecretsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  searchTerm?: string
  types?: ('SecretFile' | 'SecretText' | 'SSHKey')[]
  includeSecretsFromEverySubScope?: boolean
  pageIndex?: number
  pageSize?: number
}

export type ListSecretsV2Props = Omit<
  GetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const ListSecretsV2 = (props: ListSecretsV2Props) => (
  <Get<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>
    path="/v2/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsV2Props = Omit<
  UseGetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const useListSecretsV2 = (props: UseListSecretsV2Props) =>
  useGet<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(`/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get secrets
 */
export const listSecretsV2Promise = (
  props: GetUsingFetchProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface PostSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostSecretProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const PostSecret = (props: PostSecretProps) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapperRequestBody, void>
    verb="POST"
    path="/v2/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const usePostSecret = (props: UsePostSecretProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', `/v2/secrets`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret
 */
export const postSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets`, props, signal)

export interface ValidateSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateSecretProps = Omit<
  MutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const ValidateSecret = (props: ValidateSecretProps) => (
  <Mutate<ResponseSecretValidationResultDTO, Failure | Error, ValidateSecretQueryParams, SecretValidationMetaData, void>
    verb="POST"
    path="/v2/secrets/validate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretProps = Omit<
  UseMutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const useValidateSecret = (props: UseValidateSecretProps) =>
  useMutate<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', `/v2/secrets/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Validate a secret
 */
export const validateSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/validate`, props, signal)

export interface PostSecretViaYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const PostSecretViaYaml = (props: PostSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >
    verb="POST"
    path="/v2/secrets/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const usePostSecretViaYaml = (props: UsePostSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', `/v2/secrets/yaml`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret via yaml
 */
export const postSecretViaYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/yaml`, props, signal)

export interface ValidateSecretIdentifierIsUniqueQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ValidateSecretIdentifierIsUniquePathParams {
  identifier: string
}

export type ValidateSecretIdentifierIsUniqueProps = Omit<
  GetProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >,
  'path'
> &
  ValidateSecretIdentifierIsUniquePathParams

/**
 * Validate Secret Identifier is unique
 */
export const ValidateSecretIdentifierIsUnique = ({ identifier, ...props }: ValidateSecretIdentifierIsUniqueProps) => (
  <Get<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >
    path="/v2/secrets/validateUniqueIdentifier/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretIdentifierIsUniqueProps = Omit<
  UseGetProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >,
  'path'
> &
  ValidateSecretIdentifierIsUniquePathParams

/**
 * Validate Secret Identifier is unique
 */
export const useValidateSecretIdentifierIsUnique = ({
  identifier,
  ...props
}: UseValidateSecretIdentifierIsUniqueProps) =>
  useGet<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >(
    (paramsInPath: ValidateSecretIdentifierIsUniquePathParams) =>
      `/v2/secrets/validateUniqueIdentifier/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Validate Secret Identifier is unique
 */
export const validateSecretIdentifierIsUniquePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >(getConfig('ng/api'), `/v2/secrets/validateUniqueIdentifier/${identifier}`, props, signal)

export interface PutSecretViaYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretViaYamlPathParams {
  identifier: string
}

export type PutSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const PutSecretViaYaml = ({ identifier, ...props }: PutSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >
    verb="PUT"
    path="/v2/secrets/${identifier}/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const usePutSecretViaYaml = ({ identifier, ...props }: UsePutSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', (paramsInPath: PutSecretViaYamlPathParams) => `/v2/secrets/${paramsInPath.identifier}/yaml`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret via yaml
 */
export const putSecretViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}/yaml`, props, signal)

export interface PutSecretFileV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretFileV2PathParams {
  identifier: string
}

export type PutSecretFileV2Props = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const PutSecretFileV2 = ({ identifier, ...props }: PutSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PutSecretFileV2QueryParams, void, PutSecretFileV2PathParams>
    verb="PUT"
    path="/v2/secrets/files/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileV2Props = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const usePutSecretFileV2 = ({ identifier, ...props }: UsePutSecretFileV2Props) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', (paramsInPath: PutSecretFileV2PathParams) => `/v2/secrets/files/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret file
 */
export const putSecretFileV2Promise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/files/${identifier}`, props, signal)

export interface PostSecretFileV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostSecretFileV2Props = Omit<
  MutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const PostSecretFileV2 = (props: PostSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>
    verb="POST"
    path="/v2/secrets/files"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileV2Props = Omit<
  UseMutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const usePostSecretFileV2 = (props: UsePostSecretFileV2Props) =>
  useMutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    `/v2/secrets/files`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret file
 */
export const postSecretFileV2Promise = (
  props: MutateUsingFetchProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/v2/secrets/files`,
    props,
    signal
  )

export interface GetOrganizationQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationPathParams {
  identifier: string
}

export type GetOrganizationProps = Omit<
  GetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const GetOrganization = ({ identifier, ...props }: GetOrganizationProps) => (
  <Get<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>
    path="/organizations/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationProps = Omit<
  UseGetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const useGetOrganization = ({ identifier, ...props }: UseGetOrganizationProps) =>
  useGet<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    (paramsInPath: GetOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get an Organization by identifier
 */
export const getOrganizationPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    GetOrganizationQueryParams,
    GetOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    getConfig('ng/api'),
    `/organizations/${identifier}`,
    props,
    signal
  )

export interface PutOrganizationQueryParams {
  accountIdentifier: string
}

export interface PutOrganizationPathParams {
  identifier: string
}

export type PutOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by identifier
 */
export const PutOrganization = ({ identifier, ...props }: PutOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >
    verb="PUT"
    path="/organizations/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by identifier
 */
export const usePutOrganization = ({ identifier, ...props }: UsePutOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', (paramsInPath: PutOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update an Organization by identifier
 */
export const putOrganizationPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', getConfig('ng/api'), `/organizations/${identifier}`, props, signal)

export interface DeleteOrganizationQueryParams {
  accountIdentifier: string
}

export type DeleteOrganizationProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const DeleteOrganization = (props: DeleteOrganizationProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>
    verb="DELETE"
    path="/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteOrganizationProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const useDeleteOrganization = (props: UseDeleteOrganizationProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>('DELETE', `/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete an Organization by identifier
 */
export const deleteOrganizationPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface GetOrganizationListQueryParams {
  accountIdentifier: string
  identifiers?: string[]
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetOrganizationListProps = Omit<
  GetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const GetOrganizationList = (props: GetOrganizationListProps) => (
  <Get<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>
    path="/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationListProps = Omit<
  UseGetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const useGetOrganizationList = (props: UseGetOrganizationListProps) =>
  useGet<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(`/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Organization list
 */
export const getOrganizationListPromise = (
  props: GetUsingFetchProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface PostOrganizationQueryParams {
  accountIdentifier: string
}

export type PostOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const PostOrganization = (props: PostOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >
    verb="POST"
    path="/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const usePostOrganization = (props: UsePostOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', `/organizations`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Organization
 */
export const postOrganizationPromise = (
  props: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/organizations`, props, signal)

export interface GetProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectPathParams {
  identifier: string
}

export type GetProjectProps = Omit<
  GetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const GetProject = ({ identifier, ...props }: GetProjectProps) => (
  <Get<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>
    path="/projects/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectProps = Omit<
  UseGetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const useGetProject = ({ identifier, ...props }: UseGetProjectProps) =>
  useGet<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    (paramsInPath: GetProjectPathParams) => `/projects/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets a Project by identifier
 */
export const getProjectPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    getConfig('ng/api'),
    `/projects/${identifier}`,
    props,
    signal
  )

export interface PutProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface PutProjectPathParams {
  identifier: string
}

export type PutProjectProps = Omit<
  MutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const PutProject = ({ identifier, ...props }: PutProjectProps) => (
  <Mutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >
    verb="PUT"
    path="/projects/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutProjectProps = Omit<
  UseMutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const usePutProject = ({ identifier, ...props }: UsePutProjectProps) =>
  useMutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', (paramsInPath: PutProjectPathParams) => `/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a project by identifier
 */
export const putProjectPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', getConfig('ng/api'), `/projects/${identifier}`, props, signal)

export interface DeleteProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type DeleteProjectProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a project by identifier
 */
export const DeleteProject = (props: DeleteProjectProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>
    verb="DELETE"
    path="/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteProjectProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a project by identifier
 */
export const useDeleteProject = (props: UseDeleteProjectProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>('DELETE', `/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a project by identifier
 */
export const deleteProjectPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetProjectListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  identifiers?: string[]
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetProjectListProps = Omit<
  GetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const GetProjectList = (props: GetProjectListProps) => (
  <Get<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>
    path="/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectListProps = Omit<
  UseGetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const useGetProjectList = (props: UseGetProjectListProps) =>
  useGet<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(`/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Project list
 */
export const getProjectListPromise = (
  props: GetUsingFetchProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface PostProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type PostProjectProps = Omit<
  MutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const PostProject = (props: PostProjectProps) => (
  <Mutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>
    verb="POST"
    path="/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostProjectProps = Omit<
  UseMutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const usePostProject = (props: UsePostProjectProps) =>
  useMutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    `/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Project
 */
export const postProjectPromise = (
  props: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PostProjectQueryParams,
    ProjectRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetUserGroupPathParams {
  identifier: string
}

export type GetUserGroupProps = Omit<
  GetProps<ResponseUserGroupDTO, Failure | Error, GetUserGroupQueryParams, GetUserGroupPathParams>,
  'path'
> &
  GetUserGroupPathParams

/**
 * Get a User Group
 */
export const GetUserGroup = ({ identifier, ...props }: GetUserGroupProps) => (
  <Get<ResponseUserGroupDTO, Failure | Error, GetUserGroupQueryParams, GetUserGroupPathParams>
    path="/user-groups/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupProps = Omit<
  UseGetProps<ResponseUserGroupDTO, Failure | Error, GetUserGroupQueryParams, GetUserGroupPathParams>,
  'path'
> &
  GetUserGroupPathParams

/**
 * Get a User Group
 */
export const useGetUserGroup = ({ identifier, ...props }: UseGetUserGroupProps) =>
  useGet<ResponseUserGroupDTO, Failure | Error, GetUserGroupQueryParams, GetUserGroupPathParams>(
    (paramsInPath: GetUserGroupPathParams) => `/user-groups/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get a User Group
 */
export const getUserGroupPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseUserGroupDTO, Failure | Error, GetUserGroupQueryParams, GetUserGroupPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseUserGroupDTO, Failure | Error, GetUserGroupQueryParams, GetUserGroupPathParams>(
    getConfig('ng/api'),
    `/user-groups/${identifier}`,
    props,
    signal
  )

export interface DeleteUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteUserGroupProps = Omit<
  MutateProps<ResponseUserGroupDTO, Failure | Error, DeleteUserGroupQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a User Group
 */
export const DeleteUserGroup = (props: DeleteUserGroupProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | Error, DeleteUserGroupQueryParams, string, void>
    verb="DELETE"
    path="/user-groups"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteUserGroupProps = Omit<
  UseMutateProps<ResponseUserGroupDTO, Failure | Error, DeleteUserGroupQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a User Group
 */
export const useDeleteUserGroup = (props: UseDeleteUserGroupProps) =>
  useMutate<ResponseUserGroupDTO, Failure | Error, DeleteUserGroupQueryParams, string, void>('DELETE', `/user-groups`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a User Group
 */
export const deleteUserGroupPromise = (
  props: MutateUsingFetchProps<ResponseUserGroupDTO, Failure | Error, DeleteUserGroupQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserGroupDTO, Failure | Error, DeleteUserGroupQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export interface GetUserGroupListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUserGroupListProps = Omit<
  GetProps<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const GetUserGroupList = (props: GetUserGroupListProps) => (
  <Get<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>
    path="/user-groups"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupListProps = Omit<
  UseGetProps<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const useGetUserGroupList = (props: UseGetUserGroupListProps) =>
  useGet<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>(`/user-groups`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get User Group List
 */
export const getUserGroupListPromise = (
  props: GetUsingFetchProps<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>(
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export interface PostUserGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostUserGroupProps = Omit<
  MutateProps<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const PostUserGroup = (props: PostUserGroupProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTORequestBody, void>
    verb="POST"
    path="/user-groups"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostUserGroupProps = Omit<
  UseMutateProps<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const usePostUserGroup = (props: UsePostUserGroupProps) =>
  useMutate<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTORequestBody, void>(
    'POST',
    `/user-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a User Group
 */
export const postUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export interface PutUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PutUserGroupProps = Omit<
  MutateProps<ResponseUserGroupDTO, Failure | Error, PutUserGroupQueryParams, UserGroupDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const PutUserGroup = (props: PutUserGroupProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | Error, PutUserGroupQueryParams, UserGroupDTORequestBody, void>
    verb="PUT"
    path="/user-groups"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutUserGroupProps = Omit<
  UseMutateProps<ResponseUserGroupDTO, Failure | Error, PutUserGroupQueryParams, UserGroupDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const usePutUserGroup = (props: UsePutUserGroupProps) =>
  useMutate<ResponseUserGroupDTO, Failure | Error, PutUserGroupQueryParams, UserGroupDTORequestBody, void>(
    'PUT',
    `/user-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a User Group
 */
export const putUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserGroupDTO, Failure | Error, PutUserGroupQueryParams, UserGroupDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export type GetBatchUserGroupListProps = Omit<
  MutateProps<ResponseListUserGroupDTO, Failure | Error, void, UserGroupFilterDTO, void>,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const GetBatchUserGroupList = (props: GetBatchUserGroupListProps) => (
  <Mutate<ResponseListUserGroupDTO, Failure | Error, void, UserGroupFilterDTO, void>
    verb="POST"
    path="/user-groups/batch"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBatchUserGroupListProps = Omit<
  UseMutateProps<ResponseListUserGroupDTO, Failure | Error, void, UserGroupFilterDTO, void>,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const useGetBatchUserGroupList = (props: UseGetBatchUserGroupListProps) =>
  useMutate<ResponseListUserGroupDTO, Failure | Error, void, UserGroupFilterDTO, void>('POST', `/user-groups/batch`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Batch User Group List
 */
export const getBatchUserGroupListPromise = (
  props: MutateUsingFetchProps<ResponseListUserGroupDTO, Failure | Error, void, UserGroupFilterDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListUserGroupDTO, Failure | Error, void, UserGroupFilterDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/user-groups/batch`,
    props,
    signal
  )

export interface GetUsersInUserGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export interface GetUsersInUserGroupPathParams {
  identifier: string
}

export type GetUsersInUserGroupProps = Omit<
  MutateProps<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >,
  'path' | 'verb'
> &
  GetUsersInUserGroupPathParams

/**
 * List users in a user group
 */
export const GetUsersInUserGroup = ({ identifier, ...props }: GetUsersInUserGroupProps) => (
  <Mutate<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >
    verb="POST"
    path="/user-groups/${identifier}/users"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersInUserGroupProps = Omit<
  UseMutateProps<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >,
  'path' | 'verb'
> &
  GetUsersInUserGroupPathParams

/**
 * List users in a user group
 */
export const useGetUsersInUserGroup = ({ identifier, ...props }: UseGetUsersInUserGroupProps) =>
  useMutate<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >('POST', (paramsInPath: GetUsersInUserGroupPathParams) => `/user-groups/${paramsInPath.identifier}/users`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * List users in a user group
 */
export const getUsersInUserGroupPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >('POST', getConfig('ng/api'), `/user-groups/${identifier}/users`, props, signal)

export interface CheckMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface CheckMemberPathParams {
  identifier: string
  userIdentifier: string
}

export type CheckMemberProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, CheckMemberQueryParams, CheckMemberPathParams>,
  'path'
> &
  CheckMemberPathParams

/**
 * Check if the user is part of the user group
 */
export const CheckMember = ({ identifier, userIdentifier, ...props }: CheckMemberProps) => (
  <Get<ResponseBoolean, Failure | Error, CheckMemberQueryParams, CheckMemberPathParams>
    path="/user-groups/${identifier}/member/${userIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckMemberProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, CheckMemberQueryParams, CheckMemberPathParams>,
  'path'
> &
  CheckMemberPathParams

/**
 * Check if the user is part of the user group
 */
export const useCheckMember = ({ identifier, userIdentifier, ...props }: UseCheckMemberProps) =>
  useGet<ResponseBoolean, Failure | Error, CheckMemberQueryParams, CheckMemberPathParams>(
    (paramsInPath: CheckMemberPathParams) =>
      `/user-groups/${paramsInPath.identifier}/member/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier, userIdentifier }, ...props }
  )

/**
 * Check if the user is part of the user group
 */
export const checkMemberPromise = (
  {
    identifier,
    userIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseBoolean, Failure | Error, CheckMemberQueryParams, CheckMemberPathParams> & {
    identifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, CheckMemberQueryParams, CheckMemberPathParams>(
    getConfig('ng/api'),
    `/user-groups/${identifier}/member/${userIdentifier}`,
    props,
    signal
  )

export interface AddMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface AddMemberPathParams {
  identifier: string
  userIdentifier: string
}

export type AddMemberProps = Omit<
  MutateProps<ResponseUserGroupDTO, Failure | Error, AddMemberQueryParams, void, AddMemberPathParams>,
  'path' | 'verb'
> &
  AddMemberPathParams

/**
 * Add a user to the user group
 */
export const AddMember = ({ identifier, userIdentifier, ...props }: AddMemberProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | Error, AddMemberQueryParams, void, AddMemberPathParams>
    verb="PUT"
    path="/user-groups/${identifier}/member/${userIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddMemberProps = Omit<
  UseMutateProps<ResponseUserGroupDTO, Failure | Error, AddMemberQueryParams, void, AddMemberPathParams>,
  'path' | 'verb'
> &
  AddMemberPathParams

/**
 * Add a user to the user group
 */
export const useAddMember = ({ identifier, userIdentifier, ...props }: UseAddMemberProps) =>
  useMutate<ResponseUserGroupDTO, Failure | Error, AddMemberQueryParams, void, AddMemberPathParams>(
    'PUT',
    (paramsInPath: AddMemberPathParams) =>
      `/user-groups/${paramsInPath.identifier}/member/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier, userIdentifier }, ...props }
  )

/**
 * Add a user to the user group
 */
export const addMemberPromise = (
  {
    identifier,
    userIdentifier,
    ...props
  }: MutateUsingFetchProps<ResponseUserGroupDTO, Failure | Error, AddMemberQueryParams, void, AddMemberPathParams> & {
    identifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserGroupDTO, Failure | Error, AddMemberQueryParams, void, AddMemberPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/user-groups/${identifier}/member/${userIdentifier}`,
    props,
    signal
  )

export interface RemoveMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface RemoveMemberPathParams {
  identifier: string
}

export type RemoveMemberProps = Omit<
  MutateProps<ResponseUserGroupDTO, Failure | Error, RemoveMemberQueryParams, string, RemoveMemberPathParams>,
  'path' | 'verb'
> &
  RemoveMemberPathParams

/**
 * Remove a user from the user group
 */
export const RemoveMember = ({ identifier, ...props }: RemoveMemberProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | Error, RemoveMemberQueryParams, string, RemoveMemberPathParams>
    verb="DELETE"
    path="/user-groups/${identifier}/member"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveMemberProps = Omit<
  UseMutateProps<ResponseUserGroupDTO, Failure | Error, RemoveMemberQueryParams, string, RemoveMemberPathParams>,
  'path' | 'verb'
> &
  RemoveMemberPathParams

/**
 * Remove a user from the user group
 */
export const useRemoveMember = ({ identifier, ...props }: UseRemoveMemberProps) =>
  useMutate<ResponseUserGroupDTO, Failure | Error, RemoveMemberQueryParams, string, RemoveMemberPathParams>(
    'DELETE',
    (paramsInPath: RemoveMemberPathParams) => `/user-groups/${paramsInPath.identifier}/member`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Remove a user from the user group
 */
export const removeMemberPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserGroupDTO, Failure | Error, RemoveMemberQueryParams, string, RemoveMemberPathParams>(
    'DELETE',
    getConfig('ng/api'),
    `/user-groups/${identifier}/member`,
    props,
    signal
  )

export interface SchemafileQueryParams {
  filename?: string
}

export type SchemafileProps = Omit<GetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const Schemafile = (props: SchemafileProps) => (
  <Get<void, void, SchemafileQueryParams, void> path="/yamlschema/schemafile" base={getConfig('ng/api')} {...props} />
)

export type UseSchemafileProps = Omit<UseGetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const useSchemafile = (props: UseSchemafileProps) =>
  useGet<void, void, SchemafileQueryParams, void>(`/yamlschema/schemafile`, { base: getConfig('ng/api'), ...props })

/**
 * Get Schema for the given entity type
 */
export const schemafilePromise = (
  props: GetUsingFetchProps<void, void, SchemafileQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, SchemafileQueryParams, void>(getConfig('ng/api'), `/yamlschema/schemafile`, props, signal)

export interface GetServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetServicePathParams {
  serviceIdentifier: string
}

export type GetServiceProps = Omit<
  GetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const GetService = ({ serviceIdentifier, ...props }: GetServiceProps) => (
  <Get<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>
    path="/services/${serviceIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceProps = Omit<
  UseGetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const useGetService = ({ serviceIdentifier, ...props }: UseGetServiceProps) =>
  useGet<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    (paramsInPath: GetServicePathParams) => `/services/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServicePromise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams> & {
    serviceIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    getConfig('ng/api'),
    `/services/${serviceIdentifier}`,
    props,
    signal
  )

export interface DeleteServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteService = (props: DeleteServiceProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>
    verb="DELETE"
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteService = (props: UseDeleteServiceProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>('DELETE', `/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServicePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface GetServiceListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifiers?: string[]
  sort?: string[]
}

export type GetServiceListForProjectProps = Omit<
  GetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const GetServiceListForProject = (props: GetServiceListForProjectProps) => (
  <Get<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListForProjectProps = Omit<
  UseGetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const useGetServiceListForProject = (props: UseGetServiceListForProjectProps) =>
  useGet<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(`/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Service list for a project
 */
export const getServiceListForProjectPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface CreateServiceQueryParams {
  accountId?: string
}

export type CreateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateService = (props: CreateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="POST"
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateService = (props: UseCreateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'POST',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Service
 */
export const createServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/services`, props, signal)

export interface UpdateServiceQueryParams {
  accountId?: string
}

export type UpdateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateService = (props: UpdateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateService = (props: UseUpdateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a service by identifier
 */
export const updateServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services`, props, signal)

export interface CreateServicesQueryParams {
  accountId?: string
}

export type CreateServicesProps = Omit<
  MutateProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const CreateServices = (props: CreateServicesProps) => (
  <Mutate<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >
    verb="POST"
    path="/services/batch"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServicesProps = Omit<
  UseMutateProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const useCreateServices = (props: UseCreateServicesProps) =>
  useMutate<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', `/services/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Create Services
 */
export const createServicesPromise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', getConfig('ng/api'), `/services/batch`, props, signal)

export interface UpsertServiceQueryParams {
  accountId?: string
}

export type UpsertServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertService = (props: UpsertServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path="/services/upsert"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertService = (props: UseUpsertServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services/upsert`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Upsert a service by identifier
 */
export const upsertServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services/upsert`, props, signal)

export interface GetServiceListQueryParams {
  page?: number
  size?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  serviceIdentifiers?: string[]
  sort?: string[]
}

export type GetServiceListProps = Omit<
  GetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  'path'
>

/**
 * Gets Service list
 */
export const GetServiceList = (props: GetServiceListProps) => (
  <Get<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>
    path="/servicesV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListProps = Omit<
  UseGetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  'path'
>

/**
 * Gets Service list
 */
export const useGetServiceList = (props: UseGetServiceListProps) =>
  useGet<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>(`/servicesV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Service list
 */
export const getServiceListPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2`,
    props,
    signal
  )

export interface CreateServiceV2QueryParams {
  accountIdentifier?: string
}

export type CreateServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateServiceV2 = (props: CreateServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="POST"
    path="/servicesV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateServiceV2 = (props: UseCreateServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'POST',
    `/servicesV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Service
 */
export const createServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/servicesV2`, props, signal)

export interface UpdateServiceV2QueryParams {
  accountIdentifier?: string
}

export type UpdateServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateServiceV2 = (props: UpdateServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path="/servicesV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateServiceV2 = (props: UseUpdateServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/servicesV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a service by identifier
 */
export const updateServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/servicesV2`, props, signal)

export interface GetServiceV2QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetServiceV2PathParams {
  serviceIdentifier: string
}

export type GetServiceV2Props = Omit<
  GetProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>,
  'path'
> &
  GetServiceV2PathParams

/**
 * Gets a Service by identifier
 */
export const GetServiceV2 = ({ serviceIdentifier, ...props }: GetServiceV2Props) => (
  <Get<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>
    path="/servicesV2/${serviceIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceV2Props = Omit<
  UseGetProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>,
  'path'
> &
  GetServiceV2PathParams

/**
 * Gets a Service by identifier
 */
export const useGetServiceV2 = ({ serviceIdentifier, ...props }: UseGetServiceV2Props) =>
  useGet<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>(
    (paramsInPath: GetServiceV2PathParams) => `/servicesV2/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServiceV2Promise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams> & {
    serviceIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>(
    getConfig('ng/api'),
    `/servicesV2/${serviceIdentifier}`,
    props,
    signal
  )

export interface DeleteServiceV2QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteServiceV2 = (props: DeleteServiceV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>
    verb="DELETE"
    path="/servicesV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteServiceV2 = (props: UseDeleteServiceV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>('DELETE', `/servicesV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServiceV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/servicesV2`,
    props,
    signal
  )

export interface CreateServicesV2QueryParams {
  accountIdentifier?: string
}

export type CreateServicesV2Props = Omit<
  MutateProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const CreateServicesV2 = (props: CreateServicesV2Props) => (
  <Mutate<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >
    verb="POST"
    path="/servicesV2/batch"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServicesV2Props = Omit<
  UseMutateProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const useCreateServicesV2 = (props: UseCreateServicesV2Props) =>
  useMutate<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', `/servicesV2/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Create Services
 */
export const createServicesV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', getConfig('ng/api'), `/servicesV2/batch`, props, signal)

export interface UpsertServiceV2QueryParams {
  accountIdentifier?: string
}

export type UpsertServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertServiceV2 = (props: UpsertServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path="/servicesV2/upsert"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertServiceV2 = (props: UseUpsertServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/servicesV2/upsert`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Upsert a service by identifier
 */
export const upsertServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/servicesV2/upsert`, props, signal)

export interface GetAggregatedUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetAggregatedUsersProps = Omit<
  MutateProps<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of active users for access control
 */
export const GetAggregatedUsers = (props: GetAggregatedUsersProps) => (
  <Mutate<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>
    verb="POST"
    path="/user/aggregate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedUsersProps = Omit<
  UseMutateProps<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of active users for access control
 */
export const useGetAggregatedUsers = (props: UseGetAggregatedUsersProps) =>
  useMutate<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>(
    'POST',
    `/user/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a page of active users for access control
 */
export const getAggregatedUsersPromise = (
  props: MutateUsingFetchProps<
    ResponsePageUserAggregate,
    Failure | Error,
    GetAggregatedUsersQueryParams,
    ACLAggregateFilter,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>(
    'POST',
    getConfig('ng/api'),
    `/user/aggregate`,
    props,
    signal
  )

export interface GetAggregatedUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAggregatedUserPathParams {
  userId: string
}

export type GetAggregatedUserProps = Omit<
  GetProps<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>,
  'path'
> &
  GetAggregatedUserPathParams

/**
 * Get a user by userId for access control
 */
export const GetAggregatedUser = ({ userId, ...props }: GetAggregatedUserProps) => (
  <Get<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>
    path="/user/aggregate/${userId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedUserProps = Omit<
  UseGetProps<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>,
  'path'
> &
  GetAggregatedUserPathParams

/**
 * Get a user by userId for access control
 */
export const useGetAggregatedUser = ({ userId, ...props }: UseGetAggregatedUserProps) =>
  useGet<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>(
    (paramsInPath: GetAggregatedUserPathParams) => `/user/aggregate/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * Get a user by userId for access control
 */
export const getAggregatedUserPromise = (
  {
    userId,
    ...props
  }: GetUsingFetchProps<
    ResponseUserAggregate,
    Failure | Error,
    GetAggregatedUserQueryParams,
    GetAggregatedUserPathParams
  > & { userId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>(
    getConfig('ng/api'),
    `/user/aggregate/${userId}`,
    props,
    signal
  )

export type GetCurrentUserInfoProps = Omit<GetProps<ResponseUserInfo, Failure | Error, void, void>, 'path'>

/**
 * get current user information
 */
export const GetCurrentUserInfo = (props: GetCurrentUserInfoProps) => (
  <Get<ResponseUserInfo, Failure | Error, void, void> path="/user/currentUser" base={getConfig('ng/api')} {...props} />
)

export type UseGetCurrentUserInfoProps = Omit<UseGetProps<ResponseUserInfo, Failure | Error, void, void>, 'path'>

/**
 * get current user information
 */
export const useGetCurrentUserInfo = (props: UseGetCurrentUserInfoProps) =>
  useGet<ResponseUserInfo, Failure | Error, void, void>(`/user/currentUser`, { base: getConfig('ng/api'), ...props })

/**
 * get current user information
 */
export const getCurrentUserInfoPromise = (
  props: GetUsingFetchProps<ResponseUserInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseUserInfo, Failure | Error, void, void>(getConfig('ng/api'), `/user/currentUser`, props, signal)

export interface GetTwoFactorAuthSettingsPathParams {
  authMechanism: 'TOTP'
}

export type GetTwoFactorAuthSettingsProps = Omit<
  GetProps<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>,
  'path'
> &
  GetTwoFactorAuthSettingsPathParams

/**
 * get two factor auth settings
 */
export const GetTwoFactorAuthSettings = ({ authMechanism, ...props }: GetTwoFactorAuthSettingsProps) => (
  <Get<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>
    path="/user/two-factor-auth/${authMechanism}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTwoFactorAuthSettingsProps = Omit<
  UseGetProps<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>,
  'path'
> &
  GetTwoFactorAuthSettingsPathParams

/**
 * get two factor auth settings
 */
export const useGetTwoFactorAuthSettings = ({ authMechanism, ...props }: UseGetTwoFactorAuthSettingsProps) =>
  useGet<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>(
    (paramsInPath: GetTwoFactorAuthSettingsPathParams) => `/user/two-factor-auth/${paramsInPath.authMechanism}`,
    { base: getConfig('ng/api'), pathParams: { authMechanism }, ...props }
  )

/**
 * get two factor auth settings
 */
export const getTwoFactorAuthSettingsPromise = (
  {
    authMechanism,
    ...props
  }: GetUsingFetchProps<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    void,
    GetTwoFactorAuthSettingsPathParams
  > & { authMechanism: 'TOTP' },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>(
    getConfig('ng/api'),
    `/user/two-factor-auth/${authMechanism}`,
    props,
    signal
  )

export type EnableTwoFactorAuthProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, void, TwoFactorAuthSettingsInfo, void>,
  'path' | 'verb'
>

/**
 * enable two factor auth settings
 */
export const EnableTwoFactorAuth = (props: EnableTwoFactorAuthProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, void, TwoFactorAuthSettingsInfo, void>
    verb="PUT"
    path="/user/enable-two-factor-auth"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseEnableTwoFactorAuthProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, void, TwoFactorAuthSettingsInfo, void>,
  'path' | 'verb'
>

/**
 * enable two factor auth settings
 */
export const useEnableTwoFactorAuth = (props: UseEnableTwoFactorAuthProps) =>
  useMutate<ResponseUserInfo, Failure | Error, void, TwoFactorAuthSettingsInfo, void>(
    'PUT',
    `/user/enable-two-factor-auth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * enable two factor auth settings
 */
export const enableTwoFactorAuthPromise = (
  props: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, void, TwoFactorAuthSettingsInfo, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, void, TwoFactorAuthSettingsInfo, void>(
    'PUT',
    getConfig('ng/api'),
    `/user/enable-two-factor-auth`,
    props,
    signal
  )

export type DisableTwoFactorAuthProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * disable two factor auth settings
 */
export const DisableTwoFactorAuth = (props: DisableTwoFactorAuthProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, void, void, void>
    verb="PUT"
    path="/user/disable-two-factor-auth"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDisableTwoFactorAuthProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * disable two factor auth settings
 */
export const useDisableTwoFactorAuth = (props: UseDisableTwoFactorAuthProps) =>
  useMutate<ResponseUserInfo, Failure | Error, void, void, void>('PUT', `/user/disable-two-factor-auth`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * disable two factor auth settings
 */
export const disableTwoFactorAuthPromise = (
  props: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, void, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, void, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/user/disable-two-factor-auth`,
    props,
    signal
  )

export interface GetUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUsersProps = Omit<
  MutateProps<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get a list of users
 */
export const GetUsers = (props: GetUsersProps) => (
  <Mutate<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>
    verb="POST"
    path="/user/batch"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersProps = Omit<
  UseMutateProps<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get a list of users
 */
export const useGetUsers = (props: UseGetUsersProps) =>
  useMutate<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>(
    'POST',
    `/user/batch`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a list of users
 */
export const getUsersPromise = (
  props: MutateUsingFetchProps<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersQueryParams,
    UserFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/user/batch`,
    props,
    signal
  )

export interface GetCurrentGenUsersQueryParams {
  accountIdentifier: string
  searchString?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetCurrentGenUsersProps = Omit<
  GetProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  'path'
>

/**
 * Get users from current gen for an account
 */
export const GetCurrentGenUsers = (props: GetCurrentGenUsersProps) => (
  <Get<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>
    path="/user/currentgen"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCurrentGenUsersProps = Omit<
  UseGetProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  'path'
>

/**
 * Get users from current gen for an account
 */
export const useGetCurrentGenUsers = (props: UseGetCurrentGenUsersProps) =>
  useGet<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>(`/user/currentgen`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get users from current gen for an account
 */
export const getCurrentGenUsersPromise = (
  props: GetUsingFetchProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>(
    getConfig('ng/api'),
    `/user/currentgen`,
    props,
    signal
  )

export interface GetUserProjectInfoQueryParams {
  accountId?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUserProjectInfoProps = Omit<
  GetProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  'path'
>

/**
 * get user project information
 */
export const GetUserProjectInfo = (props: GetUserProjectInfoProps) => (
  <Get<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>
    path="/user/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserProjectInfoProps = Omit<
  UseGetProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  'path'
>

/**
 * get user project information
 */
export const useGetUserProjectInfo = (props: UseGetUserProjectInfoProps) =>
  useGet<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>(`/user/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get user project information
 */
export const getUserProjectInfoPromise = (
  props: GetUsingFetchProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>(
    getConfig('ng/api'),
    `/user/projects`,
    props,
    signal
  )

export type UpdateUserInfoProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, void, UserInfo, void>,
  'path' | 'verb'
>

/**
 * update user information
 */
export const UpdateUserInfo = (props: UpdateUserInfoProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, void, UserInfo, void>
    verb="PUT"
    path="/user"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateUserInfoProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, void, UserInfo, void>,
  'path' | 'verb'
>

/**
 * update user information
 */
export const useUpdateUserInfo = (props: UseUpdateUserInfoProps) =>
  useMutate<ResponseUserInfo, Failure | Error, void, UserInfo, void>('PUT', `/user`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * update user information
 */
export const updateUserInfoPromise = (
  props: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, void, UserInfo, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, void, UserInfo, void>(
    'PUT',
    getConfig('ng/api'),
    `/user`,
    props,
    signal
  )

export interface RemoveUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type RemoveUserProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Remove user as the collaborator from the scope
 */
export const RemoveUser = (props: RemoveUserProps) => (
  <Mutate<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>
    verb="DELETE"
    path="/user"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveUserProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Remove user as the collaborator from the scope
 */
export const useRemoveUser = (props: UseRemoveUserProps) =>
  useMutate<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>('DELETE', `/user`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Remove user as the collaborator from the scope
 */
export const removeUserPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/user`,
    props,
    signal
  )

export interface GetListOfExecutionsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
  serviceIdentifiers?: string[]
  envIdentifiers?: string[]
  pipelineIdentifiers?: string[]
  executionStatuses?: (
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
  )[]
  startTime?: number
  endTime?: number
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetListOfExecutionsProps = Omit<
  GetProps<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>,
  'path'
>

/**
 * Gets Executions list
 */
export const GetListOfExecutions = (props: GetListOfExecutionsProps) => (
  <Get<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>
    path="/executions"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfExecutionsProps = Omit<
  UseGetProps<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>,
  'path'
>

/**
 * Gets Executions list
 */
export const useGetListOfExecutions = (props: UseGetListOfExecutionsProps) =>
  useGet<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>(
    `/executions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Executions list
 */
export const getListOfExecutionsPromise = (
  props: GetUsingFetchProps<
    ResponsePagePipelineExecutionSummaryDTO,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>(
    getConfig('ng/api'),
    `/executions`,
    props,
    signal
  )

export type GetDummyCDStageModuleInfoProps = Omit<
  GetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDStageModuleInfo = (props: GetDummyCDStageModuleInfoProps) => (
  <Get<ResponseCDStageModuleInfo, Failure | Error, void, void>
    path="/executions/dummyCDStageModuleInfo"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDStageModuleInfoProps = Omit<
  UseGetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDStageModuleInfo = (props: UseGetDummyCDStageModuleInfoProps) =>
  useGet<ResponseCDStageModuleInfo, Failure | Error, void, void>(`/executions/dummyCDStageModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDStageModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDStageModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDStageModuleInfo`,
    props,
    signal
  )

export type GetDummyCDPipelineModuleInfoProps = Omit<
  GetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDPipelineModuleInfo = (props: GetDummyCDPipelineModuleInfoProps) => (
  <Get<ResponseCDPipelineModuleInfo, Failure | Error, void, void>
    path="/executions/dummyCDPipelineModuleInfo"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDPipelineModuleInfoProps = Omit<
  UseGetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDPipelineModuleInfo = (props: UseGetDummyCDPipelineModuleInfoProps) =>
  useGet<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(`/executions/dummyCDPipelineModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDPipelineModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDPipelineModuleInfo`,
    props,
    signal
  )

export interface HandleInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType: 'Abort' | 'Pause' | 'Resume'
}

export interface HandleInterruptPathParams {
  planExecutionId: string
}

export type HandleInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const HandleInterrupt = ({ planExecutionId, ...props }: HandleInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >
    verb="PUT"
    path="/executions/interrupt/${planExecutionId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHandleInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const useHandleInterrupt = ({ planExecutionId, ...props }: UseHandleInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', (paramsInPath: HandleInterruptPathParams) => `/executions/interrupt/${paramsInPath.planExecutionId}`, {
    base: getConfig('ng/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * pause, resume or stop the pipeline executions
 */
export const handleInterruptPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', getConfig('ng/api'), `/executions/interrupt/${planExecutionId}`, props, signal)

export interface GetPipelineExecutionDetailQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageIdentifier?: string
}

export interface GetPipelineExecutionDetailPathParams {
  planExecutionId: string
}

export type GetPipelineExecutionDetailProps = Omit<
  GetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >,
  'path'
> &
  GetPipelineExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const GetPipelineExecutionDetail = ({ planExecutionId, ...props }: GetPipelineExecutionDetailProps) => (
  <Get<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >
    path="/executions/${planExecutionId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineExecutionDetailProps = Omit<
  UseGetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >,
  'path'
> &
  GetPipelineExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const useGetPipelineExecutionDetail = ({ planExecutionId, ...props }: UseGetPipelineExecutionDetailProps) =>
  useGet<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >((paramsInPath: GetPipelineExecutionDetailPathParams) => `/executions/${paramsInPath.planExecutionId}`, {
    base: getConfig('ng/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Gets Execution Detail
 */
export const getPipelineExecutionDetailPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >(getConfig('ng/api'), `/executions/${planExecutionId}`, props, signal)

export type GetExecutionStatusesProps = Omit<GetProps<ResponseListExecutionStatus, Failure | Error, void, void>, 'path'>

/**
 * Gets Execution Status list
 */
export const GetExecutionStatuses = (props: GetExecutionStatusesProps) => (
  <Get<ResponseListExecutionStatus, Failure | Error, void, void>
    path="/executions/executionStatus"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStatusesProps = Omit<
  UseGetProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Status list
 */
export const useGetExecutionStatuses = (props: UseGetExecutionStatusesProps) =>
  useGet<ResponseListExecutionStatus, Failure | Error, void, void>(`/executions/executionStatus`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Execution Status list
 */
export const getExecutionStatusesPromise = (
  props: GetUsingFetchProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListExecutionStatus, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/executionStatus`,
    props,
    signal
  )

export interface GetJiraProjectsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetJiraProjectsProps = Omit<
  GetProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const GetJiraProjects = (props: GetJiraProjectsProps) => (
  <Get<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>
    path="/jira/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraProjectsProps = Omit<
  UseGetProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const useGetJiraProjects = (props: UseGetJiraProjectsProps) =>
  useGet<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>(`/jira/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira projects
 */
export const getJiraProjectsPromise = (
  props: GetUsingFetchProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/projects`,
    props,
    signal
  )

export interface ValidateJiraCredentialsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateJiraCredentialsProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const ValidateJiraCredentials = (props: ValidateJiraCredentialsProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>
    path="/jira/validate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateJiraCredentialsProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const useValidateJiraCredentials = (props: UseValidateJiraCredentialsProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(`/jira/validate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Validate jira credentials
 */
export const validateJiraCredentialsPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/validate`,
    props,
    signal
  )

export interface GetJiraStatusesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
  issueType?: string
}

export type GetJiraStatusesProps = Omit<
  GetProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira statuses
 */
export const GetJiraStatuses = (props: GetJiraStatusesProps) => (
  <Get<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>
    path="/jira/statuses"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraStatusesProps = Omit<
  UseGetProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira statuses
 */
export const useGetJiraStatuses = (props: UseGetJiraStatusesProps) =>
  useGet<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>(`/jira/statuses`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira statuses
 */
export const getJiraStatusesPromise = (
  props: GetUsingFetchProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>(
    getConfig('ng/api'),
    `/jira/statuses`,
    props,
    signal
  )

export interface GetJiraIssueCreateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
  issueType?: string
  expand?: string
  fetchStatus?: boolean
}

export type GetJiraIssueCreateMetadataProps = Omit<
  GetProps<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue create metadata
 */
export const GetJiraIssueCreateMetadata = (props: GetJiraIssueCreateMetadataProps) => (
  <Get<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>
    path="/jira/createMetadata"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraIssueCreateMetadataProps = Omit<
  UseGetProps<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue create metadata
 */
export const useGetJiraIssueCreateMetadata = (props: UseGetJiraIssueCreateMetadataProps) =>
  useGet<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>(
    `/jira/createMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira issue create metadata
 */
export const getJiraIssueCreateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseJiraIssueCreateMetadataNG,
    Failure | Error,
    GetJiraIssueCreateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/jira/createMetadata`,
    props,
    signal
  )

export interface GetJiraIssueUpdateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  issueKey?: string
}

export type GetJiraIssueUpdateMetadataProps = Omit<
  GetProps<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue update metadata
 */
export const GetJiraIssueUpdateMetadata = (props: GetJiraIssueUpdateMetadataProps) => (
  <Get<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>
    path="/jira/updateMetadata"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraIssueUpdateMetadataProps = Omit<
  UseGetProps<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue update metadata
 */
export const useGetJiraIssueUpdateMetadata = (props: UseGetJiraIssueUpdateMetadataProps) =>
  useGet<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>(
    `/jira/updateMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira issue update metadata
 */
export const getJiraIssueUpdateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseJiraIssueUpdateMetadataNG,
    Failure | Error,
    GetJiraIssueUpdateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/jira/updateMetadata`,
    props,
    signal
  )

export type GetSourceCodeManagersProps = Omit<GetProps<ResponseListSourceCodeManagerDTO, unknown, void, void>, 'path'>

/**
 * get source code manager information
 */
export const GetSourceCodeManagers = (props: GetSourceCodeManagersProps) => (
  <Get<ResponseListSourceCodeManagerDTO, unknown, void, void>
    path="/source-code-manager"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSourceCodeManagersProps = Omit<
  UseGetProps<ResponseListSourceCodeManagerDTO, unknown, void, void>,
  'path'
>

/**
 * get source code manager information
 */
export const useGetSourceCodeManagers = (props: UseGetSourceCodeManagersProps) =>
  useGet<ResponseListSourceCodeManagerDTO, unknown, void, void>(`/source-code-manager`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get source code manager information
 */
export const getSourceCodeManagersPromise = (
  props: GetUsingFetchProps<ResponseListSourceCodeManagerDTO, unknown, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListSourceCodeManagerDTO, unknown, void, void>(
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export type SaveSourceCodeManagersProps = Omit<
  MutateProps<ResponseSourceCodeManagerDTO, unknown, void, SourceCodeManagerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * save source code manager
 */
export const SaveSourceCodeManagers = (props: SaveSourceCodeManagersProps) => (
  <Mutate<ResponseSourceCodeManagerDTO, unknown, void, SourceCodeManagerDTORequestBody, void>
    verb="POST"
    path="/source-code-manager"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveSourceCodeManagersProps = Omit<
  UseMutateProps<ResponseSourceCodeManagerDTO, unknown, void, SourceCodeManagerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * save source code manager
 */
export const useSaveSourceCodeManagers = (props: UseSaveSourceCodeManagersProps) =>
  useMutate<ResponseSourceCodeManagerDTO, unknown, void, SourceCodeManagerDTORequestBody, void>(
    'POST',
    `/source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * save source code manager
 */
export const saveSourceCodeManagersPromise = (
  props: MutateUsingFetchProps<ResponseSourceCodeManagerDTO, unknown, void, SourceCodeManagerDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSourceCodeManagerDTO, unknown, void, SourceCodeManagerDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export interface UpdateSourceCodeManagersPathParams {
  identifier: string
}

export type UpdateSourceCodeManagersProps = Omit<
  MutateProps<
    ResponseSourceCodeManagerDTO,
    unknown,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >,
  'path' | 'verb'
> &
  UpdateSourceCodeManagersPathParams

/**
 * update source code manager
 */
export const UpdateSourceCodeManagers = ({ identifier, ...props }: UpdateSourceCodeManagersProps) => (
  <Mutate<
    ResponseSourceCodeManagerDTO,
    unknown,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >
    verb="PUT"
    path="/source-code-manager/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSourceCodeManagersProps = Omit<
  UseMutateProps<
    ResponseSourceCodeManagerDTO,
    unknown,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >,
  'path' | 'verb'
> &
  UpdateSourceCodeManagersPathParams

/**
 * update source code manager
 */
export const useUpdateSourceCodeManagers = ({ identifier, ...props }: UseUpdateSourceCodeManagersProps) =>
  useMutate<
    ResponseSourceCodeManagerDTO,
    unknown,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >('PUT', (paramsInPath: UpdateSourceCodeManagersPathParams) => `/source-code-manager/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * update source code manager
 */
export const updateSourceCodeManagersPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSourceCodeManagerDTO,
    unknown,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSourceCodeManagerDTO,
    unknown,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >('PUT', getConfig('ng/api'), `/source-code-manager/${identifier}`, props, signal)

export type DeleteSourceCodeManagersProps = Omit<
  MutateProps<ResponseBoolean, unknown, void, string, void>,
  'path' | 'verb'
>

/**
 * delete source code manager
 */
export const DeleteSourceCodeManagers = (props: DeleteSourceCodeManagersProps) => (
  <Mutate<ResponseBoolean, unknown, void, string, void>
    verb="DELETE"
    path="/source-code-manager"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSourceCodeManagersProps = Omit<
  UseMutateProps<ResponseBoolean, unknown, void, string, void>,
  'path' | 'verb'
>

/**
 * delete source code manager
 */
export const useDeleteSourceCodeManagers = (props: UseDeleteSourceCodeManagersProps) =>
  useMutate<ResponseBoolean, unknown, void, string, void>('DELETE', `/source-code-manager`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * delete source code manager
 */
export const deleteSourceCodeManagersPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, unknown, void, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, unknown, void, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export interface WebhookEndpointQueryParams {
  accountIdentifier: string
}

export type WebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const WebhookEndpoint = (props: WebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>
    verb="POST"
    path="/webhook"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const useWebhookEndpoint = (props: UseWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>('POST', `/webhook`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * accept webhook event
 */
export const webhookEndpointPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>(
    'POST',
    getConfig('ng/api'),
    `/webhook`,
    props,
    signal
  )

export interface GetInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetInputSetForPipelineProps = Omit<
  GetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const GetInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetInputSetForPipelineProps) => (
  <Get<ResponseInputSetResponse, Failure | Error, GetInputSetForPipelineQueryParams, GetInputSetForPipelinePathParams>
    path="/inputSets/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const useGetInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseGetInputSetForPipelineProps) =>
  useGet<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >((paramsInPath: GetInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Gets an InputSet by identifier
 */
export const getInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >(getConfig('ng/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface UpdateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const UpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UpdateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >
    verb="PUT"
    path="/inputSets/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const useUpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseUpdateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', (paramsInPath: UpdateInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Update an InputSet by identifier
 */
export const updateInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', getConfig('ng/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface DeleteInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type DeleteInputSetForPipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const DeleteInputSetForPipeline = (props: DeleteInputSetForPipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>
    verb="DELETE"
    path="/inputSets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInputSetForPipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const useDeleteInputSetForPipeline = (props: UseDeleteInputSetForPipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    `/inputSets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete an inputSet by identifier
 */
export const deleteInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/inputSets`,
    props,
    signal
  )

export interface GetOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetOverlayInputSetForPipelineProps = Omit<
  GetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const GetOverlayInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetOverlayInputSetForPipelineProps) => (
  <Get<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >
    path="/inputSets/overlay/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOverlayInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const useGetOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseGetOverlayInputSetForPipelineProps) =>
  useGet<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(
    (paramsInPath: GetOverlayInputSetForPipelinePathParams) => `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Gets an Overlay InputSet by identifier
 */
export const getOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(getConfig('ng/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface UpdateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const UpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UpdateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >
    verb="PUT"
    path="/inputSets/overlay/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const useUpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseUpdateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >(
    'PUT',
    (paramsInPath: UpdateOverlayInputSetForPipelinePathParams) =>
      `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Update an Overlay InputSet by identifier
 */
export const updateOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >('PUT', getConfig('ng/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface GetInputSetsListForPipelineQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  inputSetType?: 'ALL' | 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  searchTerm?: string
  sortOrders?: string[]
}

export type GetInputSetsListForPipelineProps = Omit<
  GetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const GetInputSetsListForPipeline = (props: GetInputSetsListForPipelineProps) => (
  <Get<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>
    path="/inputSets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInputSetsListForPipelineProps = Omit<
  UseGetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const useGetInputSetsListForPipeline = (props: UseGetInputSetsListForPipelineProps) =>
  useGet<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    `/inputSets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets InputSets list for a pipeline
 */
export const getInputSetsListForPipelinePromise = (
  props: GetUsingFetchProps<
    ResponsePageInputSetSummaryResponse,
    Failure | Error,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    getConfig('ng/api'),
    `/inputSets`,
    props,
    signal
  )

export interface CreateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const CreateInputSetForPipeline = (props: CreateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >
    verb="POST"
    path="/inputSets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const useCreateInputSetForPipeline = (props: UseCreateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >('POST', `/inputSets`, { base: getConfig('ng/api'), ...props })

/**
 * Create an InputSet For Pipeline
 */
export const createInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets`, props, signal)

export interface CreateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const CreateOverlayInputSetForPipeline = (props: CreateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >
    verb="POST"
    path="/inputSets/overlay"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const useCreateOverlayInputSetForPipeline = (props: UseCreateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >('POST', `/inputSets/overlay`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Overlay InputSet For Pipeline
 */
export const createOverlayInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets/overlay`, props, signal)

export interface GetTemplateFromPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type GetTemplateFromPipelineProps = Omit<
  GetProps<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const GetTemplateFromPipeline = (props: GetTemplateFromPipelineProps) => (
  <Get<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>
    path="/inputSets/template"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTemplateFromPipelineProps = Omit<
  UseGetProps<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const useGetTemplateFromPipeline = (props: UseGetTemplateFromPipelineProps) =>
  useGet<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>(
    `/inputSets/template`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get template from a pipeline yaml
 */
export const getTemplateFromPipelinePromise = (
  props: GetUsingFetchProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>(
    getConfig('ng/api'),
    `/inputSets/template`,
    props,
    signal
  )

export interface GetMergeInputSetFromPipelineTemplateWithListInputQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  useFQNIfError?: boolean
}

export type GetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const GetMergeInputSetFromPipelineTemplateWithListInput = (
  props: GetMergeInputSetFromPipelineTemplateWithListInputProps
) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >
    verb="POST"
    path="/inputSets/merge"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const useGetMergeInputSetFromPipelineTemplateWithListInput = (
  props: UseGetMergeInputSetFromPipelineTemplateWithListInputProps
) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', `/inputSets/merge`, { base: getConfig('ng/api'), ...props })

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const getMergeInputSetFromPipelineTemplateWithListInputPromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets/merge`, props, signal)

export interface GetPipelineListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetPipelineListProps = Omit<
  GetProps<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const GetPipelineList = (props: GetPipelineListProps) => (
  <Get<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>
    path="/pipelines"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineListProps = Omit<
  UseGetProps<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const useGetPipelineList = (props: UseGetPipelineListProps) =>
  useGet<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>(`/pipelines`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Pipeline list
 */
export const getPipelineListPromise = (
  props: GetUsingFetchProps<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export interface PostPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type PostPipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const PostPipeline = (props: PostPipelineProps) => (
  <Mutate<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>
    verb="POST"
    path="/pipelines"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const usePostPipeline = (props: UsePostPipelineProps) =>
  useMutate<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>(
    'POST',
    `/pipelines`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Pipeline
 */
export const postPipelinePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export interface GetPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetPipelinePathParams {
  pipelineIdentifier: string
}

export type GetPipelineProps = Omit<
  GetProps<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipeline = ({ pipelineIdentifier, ...props }: GetPipelineProps) => (
  <Get<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>
    path="/pipelines/${pipelineIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineProps = Omit<
  UseGetProps<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipeline = ({ pipelineIdentifier, ...props }: UseGetPipelineProps) =>
  useGet<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    (paramsInPath: GetPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Gets a pipeline by identifier
 */
export const getPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams> & {
    pipelineIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    getConfig('ng/api'),
    `/pipelines/${pipelineIdentifier}`,
    props,
    signal
  )

export interface PutPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface PutPipelinePathParams {
  pipelineIdentifier: string
}

export type PutPipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const PutPipeline = ({ pipelineIdentifier, ...props }: PutPipelineProps) => (
  <Mutate<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>
    verb="PUT"
    path="/pipelines/${pipelineIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutPipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const usePutPipeline = ({ pipelineIdentifier, ...props }: UsePutPipelineProps) =>
  useMutate<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>(
    'PUT',
    (paramsInPath: PutPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Update a Pipeline
 */
export const putPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    NgPipelineRequestBody,
    PutPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    NgPipelineRequestBody,
    PutPipelinePathParams
  >('PUT', getConfig('ng/api'), `/pipelines/${pipelineIdentifier}`, props, signal)

export interface SoftDeletePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type SoftDeletePipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const SoftDeletePipeline = (props: SoftDeletePipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>
    verb="DELETE"
    path="/pipelines"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSoftDeletePipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const useSoftDeletePipeline = (props: UseSoftDeletePipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>('DELETE', `/pipelines`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a pipeline
 */
export const softDeletePipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export interface GetPipelineSummaryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetPipelineSummaryPathParams {
  pipelineIdentifier: string
}

export type GetPipelineSummaryProps = Omit<
  GetProps<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipelineSummary = ({ pipelineIdentifier, ...props }: GetPipelineSummaryProps) => (
  <Get<ResponseNGPipelineSummaryResponse, Failure | Error, GetPipelineSummaryQueryParams, GetPipelineSummaryPathParams>
    path="/pipelines/summary/${pipelineIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineSummaryProps = Omit<
  UseGetProps<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipelineSummary = ({ pipelineIdentifier, ...props }: UseGetPipelineSummaryProps) =>
  useGet<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >((paramsInPath: GetPipelineSummaryPathParams) => `/pipelines/summary/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Gets a pipeline by identifier
 */
export const getPipelineSummaryPromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >(getConfig('ng/api'), `/pipelines/summary/${pipelineIdentifier}`, props, signal)

export type DummyApiForSwaggerSchemaCheckProps = Omit<
  GetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const DummyApiForSwaggerSchemaCheck = (props: DummyApiForSwaggerSchemaCheckProps) => (
  <Get<ResponsePipelineConfig, Failure | Error, void, void>
    path="/pipelines/dummyApiForSwaggerSchemaCheck"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyApiForSwaggerSchemaCheckProps = Omit<
  UseGetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const useDummyApiForSwaggerSchemaCheck = (props: UseDummyApiForSwaggerSchemaCheckProps) =>
  useGet<ResponsePipelineConfig, Failure | Error, void, void>(`/pipelines/dummyApiForSwaggerSchemaCheck`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api for checking pms schema
 */
export const dummyApiForSwaggerSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponsePipelineConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePipelineConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/dummyApiForSwaggerSchemaCheck`,
    props,
    signal
  )

export interface SignupQueryParams {
  captchaToken?: string
}

export type SignupProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, SignupQueryParams, SignupDTO, void>,
  'path' | 'verb'
>

export const Signup = (props: SignupProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, SignupQueryParams, SignupDTO, void>
    verb="POST"
    path="/signup"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSignupProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, SignupQueryParams, SignupDTO, void>,
  'path' | 'verb'
>

export const useSignup = (props: UseSignupProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, SignupQueryParams, SignupDTO, void>('POST', `/signup`, {
    base: getConfig('ng/api'),
    ...props
  })

export const signupPromise = (
  props: MutateUsingFetchProps<RestResponseUserInfo, Failure | Error, SignupQueryParams, SignupDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, SignupQueryParams, SignupDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/signup`,
    props,
    signal
  )

export type SignupOAuthProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>,
  'path' | 'verb'
>

export const SignupOAuth = (props: SignupOAuthProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>
    verb="POST"
    path="/signup/oauth"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSignupOAuthProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>,
  'path' | 'verb'
>

export const useSignupOAuth = (props: UseSignupOAuthProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>('POST', `/signup/oauth`, {
    base: getConfig('ng/api'),
    ...props
  })

export const signupOAuthPromise = (
  props: MutateUsingFetchProps<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/oauth`,
    props,
    signal
  )

export interface GetPartialYamlSchemaQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetPartialYamlSchemaProps = Omit<
  GetProps<ResponsePartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const GetPartialYamlSchema = (props: GetPartialYamlSchemaProps) => (
  <Get<ResponsePartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>
    path="/partial-yaml-schema"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPartialYamlSchemaProps = Omit<
  UseGetProps<ResponsePartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const useGetPartialYamlSchema = (props: UseGetPartialYamlSchemaProps) =>
  useGet<ResponsePartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(`/partial-yaml-schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Partial Yaml Schema
 */
export const getPartialYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponsePartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/partial-yaml-schema`,
    props,
    signal
  )

export interface GetYamlSchemaQueryParams {
  entityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'Triggers'
  subtype?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
}

export type GetYamlSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetYamlSchema = (props: GetYamlSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>
    path="/yaml-schema"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetYamlSchema = (props: UseGetYamlSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(`/yaml-schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-schema`,
    props,
    signal
  )

export interface GetYamlSnippetMetadataQueryParams {
  tags: (
    | 'k8s'
    | 'git'
    | 'docker'
    | 'connector'
    | 'secretmanager'
    | 'secret'
    | 'secretText'
    | 'secretFile'
    | 'sshKey'
    | 'service'
    | 'infra'
    | 'steps'
    | 'pipeline'
    | 'http'
    | 'splunk'
    | 'appdynamics'
    | 'vault'
    | 'local'
    | 'gcpkms'
    | 'gcp'
    | 'aws'
    | 'awskms'
    | 'artifactory'
    | 'jira'
    | 'nexus'
    | 'github'
    | 'gitlab'
    | 'bitbucket'
    | 'ceaws'
    | 'ceazure'
    | 'cek8s'
    | 'codecommit'
    | 'httphelmrepo'
    | 'newrelic'
    | 'gcpcloudcost'
    | 'prometheus'
  )[]
}

export type GetYamlSnippetMetadataProps = Omit<
  GetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const GetYamlSnippetMetadata = (props: GetYamlSnippetMetadataProps) => (
  <Get<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>
    path="/yaml-snippet"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetMetadataProps = Omit<
  UseGetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const useGetYamlSnippetMetadata = (props: UseGetYamlSnippetMetadataProps) =>
  useGet<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(`/yaml-snippet`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Snippet Metadata
 */
export const getYamlSnippetMetadataPromise = (
  props: GetUsingFetchProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-snippet`,
    props,
    signal
  )

export interface GetYamlSnippetQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export interface GetYamlSnippetPathParams {
  identifier: string
}

export type GetYamlSnippetProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const GetYamlSnippet = ({ identifier, ...props }: GetYamlSnippetProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>
    path="/yaml-snippet/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const useGetYamlSnippet = ({ identifier, ...props }: UseGetYamlSnippetProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>(
    (paramsInPath: GetYamlSnippetPathParams) => `/yaml-snippet/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Yaml Snippet
 */
export const getYamlSnippetPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>(
    getConfig('ng/api'),
    `/yaml-snippet/${identifier}`,
    props,
    signal
  )
