/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export interface Response {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseStepCategory {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: StepCategory
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StepCategory {
  name?: string
  stepsData?: StepData[]
  stepCategories?: StepCategory[]
}

export interface StepData {
  type?:
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'Placeholder'
    | 'ShellScript'
    | 'Http'
    | 'Placeholder'
    | 'Placeholder'
  name?: string
}

export interface Failure {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
  message?: string
  correlationId?: string
  errors?: ValidationError[]
}

export interface ValidationError {
  fieldId?: string
  error?: string
}

export interface Error {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
  message?: string
  correlationId?: string
  detailedMessage?: string
}

export interface ResponseMapServiceDefinitionTypeListExecutionStrategyType {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: {
    [key: string]: ('Basic' | 'Canary' | 'BlueGreen' | 'Rolling')[]
  }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListServiceDefinitionType {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ('Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf')[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPipelineValidationInfo {
  pipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: VisitorErrorResponseWrapper
  }
  errorResponse?: boolean
}

export interface ResponseNGPipelineValidationInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineValidationInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface VisitorErrorResponse {
  fieldName?: string
  message?: string
}

export interface VisitorErrorResponseWrapper {
  errors?: VisitorErrorResponse[]
}

export interface NGPipelineError {
  fieldName?: string
  message?: string
  identifierOfErrorSource?: string
}

export interface NGPipelineErrorResponse {
  errors?: NGPipelineError[]
}

export interface NGPipelineErrorWrapper {
  errorPipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: NGPipelineErrorResponse
  }
}

export interface NGPipelineExecutionResponse {
  planExecution?: PlanExecution
  pipelineErrorResponse?: NGPipelineErrorWrapper
  errorResponse?: boolean
}

export interface PlanExecution {
  uuid?: string
  createdAt?: number
  setupAbstractions?: {
    [key: string]: string
  }
  validUntil?: string
  status?:
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'UNRECOGNIZED'
  startTs?: number
  endTs?: number
  lastUpdatedAt?: number
  version?: number
}

export interface ResponseNGPipelineExecutionResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineExecutionResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & { [key: string]: any }

export interface ArtifactConfig {
  [key: string]: any
}

export interface ArtifactListConfig {
  primary?: ArtifactSpecWrapper
  sidecars?: SidecarArtifactWrapper[]
  metadata?: string
}

export interface ArtifactOverrideSets {
  identifier: string
  artifacts?: ArtifactListConfig
  metadata?: string
}

export interface ArtifactSpecWrapper {
  metadata?: string
  type: 'Dockerhub' | 'Gcr'
  spec?: ArtifactConfig
}

export interface CodeBase {
  type: 'GitHub'
  spec: CodeBaseSpec
}

export interface CodeBaseSpec {
  [key: string]: any
}

export type DeploymentStage = StageType & {
  variables?: NGVariable[]
  service?: ServiceConfig
  infrastructure?: PipelineInfrastructure
  execution?: ExecutionElement
  skipCondition?: string
  metadata?: string
}

export type DockerHubArtifactConfig = ArtifactConfig & {
  connectorRef?: string
  imagePath?: string
  tag?: string
  tagRegex?: string
  metadata?: string
}

export interface EnvironmentYaml {
  name?: string
  identifier?: string
  description?: string
  type?: 'PreProduction' | 'Production'
  tags?: {
    [key: string]: string
  }
  metadata?: string
}

export interface ExecutionElement {
  steps?: ExecutionWrapper[]
  rollbackSteps?: ExecutionWrapper[]
  metadata?: string
}

export interface ExecutionWrapper {
  [key: string]: any
}

export interface FailureStrategyActionConfig {
  [key: string]: any
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig
}

export type GcrArtifactConfig = ArtifactConfig & {
  connectorRef?: string
  registryHostname?: string
  imagePath?: string
  metadata?: string
}

export type GitStore = StoreConfig & {
  connectorRef?: string
  gitFetchType?: 'BRANCH' | 'COMMIT'
  branch?: string
  commitId?: string
  paths?: string[]
  metadata?: string
}

export type HttpStepInfo = StepSpecType & {
  url?: string
  method?: string
  header?: string
  body?: string
  assertion?: string
  socketTimeoutMillis?: number
  metadata?: string
}

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & { [key: string]: any }

export interface InfraOverrides {
  environment?: EnvironmentYaml
  infrastructureDefinition?: InfrastructureDef
  metadata?: string
}

export interface InfraUseFromStage {
  stage: string
  overrides?: InfraOverrides
  metadata?: string
}

export interface Infrastructure {
  [key: string]: any
}

export interface InfrastructureDef {
  type?: string
  metadata?: string
  spec?: Infrastructure
}

export interface InputSetValidator {
  validatorType?: 'ALLOWED_VALUES' | 'REGEX'
  parameters?: string
}

export type K8SDirectInfrastructure = Infrastructure & {
  connectorRef?: string
  namespace?: string
  releaseName?: string
  metadata?: string
}

export type K8sApplyStepInfo = StepSpecType & {
  timeout?: string
  skipDryRun?: boolean
  skipSteadyStateCheck?: boolean
  filePaths?: string[]
  metadata?: string
}

export type K8sBlueGreenStepInfo = StepSpecType & {
  timeout?: string
  skipDryRun?: boolean
  metadata?: string
}

export type K8sManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  metadata?: string
}

export type K8sRollingRollbackStepInfo = StepSpecType & {
  timeout?: string
  metadata?: string
}

export type K8sRollingStepInfo = StepSpecType & {
  timeout?: string
  skipDryRun?: boolean
  metadata?: string
}

export type KubernetesServiceSpec = ServiceSpec & {
  variables?: NGVariable[]
  variableOverrideSets?: NGVariableOverrideSets[]
  metadata?: string
}

export interface ManifestAttributes {
  [key: string]: any
}

export type ManifestConfig = ManifestConfigWrapper & {
  type?: string
  metadata?: string
  spec?: ManifestAttributes
}

export interface ManifestConfigWrapper {
  identifier: string
}

export interface ManifestOverrideSets {
  identifier: string
  manifests?: ManifestConfigWrapper[]
  metadata?: string
}

export interface ManualFailureSpecConfig {
  timeout: string
  onTimeout: OnTimeoutConfig
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec?: ManualFailureSpecConfig
}

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & { [key: string]: any }

export interface NGVariable {
  name?: string
  value?: ParameterFieldObject
  type?: 'String' | 'Number'
  description?: string
  required?: boolean
  metadata?: string
}

export interface NGVariableOverrideSets {
  identifier: string
  variables?: NGVariable[]
  metadata?: string
}

export interface NgPipeline {
  name: string
  identifier: string
  description?: string
  tags?: {
    [key: string]: string
  }
  variables?: NGVariable[]
  ciCodebase?: CodeBase
  stages?: StageElementWrapper[]
  metadata?: string
}

export type NumberNGVariable = NGVariable & {
  value: number
  default?: number
}

export interface OnFailureConfig {
  errors: string[]
  action: FailureStrategyActionConfig
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig
}

export interface OrchestrationFieldType {
  type?: string
}

export type ParallelStageElement = StageElementWrapper & {
  sections: StageElementWrapper[]
  metadata?: string
}

export type ParallelStepElement = ExecutionWrapper & {
  sections: ExecutionWrapper[]
  metadata?: string
}

export interface ParameterFieldObject {
  expressionValue?: string
  expression?: boolean
  value?: { [key: string]: any }
  typeString?: boolean
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  type?: OrchestrationFieldType
}

export interface PipelineInfrastructure {
  infrastructureDefinition?: InfrastructureDef
  useFromStage?: InfraUseFromStage
  environment?: EnvironmentYaml
  metadata?: string
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec?: RetryFailureSpecConfig
}

export interface RetryFailureSpecConfig {
  retryCount: number
  retryInterval: string[]
  onRetryFailure: OnRetryFailureConfig
}

export interface ServiceConfig {
  useFromStage?: ServiceUseFromStage
  identifier?: string
  name?: string
  description?: string
  serviceDefinition?: ServiceDefinition
  stageOverrides?: StageOverridesConfig
  tags?: {
    [key: string]: string
  }
  metadata?: string
}

export interface ServiceDefinition {
  type?: string
  metadata?: string
  spec?: ServiceSpec
}

export interface ServiceOverrides {
  name?: string
  description?: string
  metadata?: string
}

export interface ServiceSpec {
  manifestOverrideSets?: ManifestOverrideSets[]
  manifests?: ManifestConfigWrapper[]
  artifactOverrideSets?: ArtifactOverrideSets[]
  artifacts?: ArtifactListConfig
}

export interface ServiceUseFromStage {
  stage: string
  overrides?: ServiceOverrides
  metadata?: string
}

export type ShellScriptStepInfo = StepSpecType & {
  executeOnDelegate?: boolean
  host?: string
  tags?: string[]
  connectionType?: 'SSH' | 'WINRM'
  sshKeyRef?: string
  connectionAttributes?: string
  commandPath?: string
  scriptType?: 'BASH' | 'POWERSHELL'
  scriptString?: string
  timeoutSecs?: string
  outputVars?: string
  sweepingOutputName?: string
  sweepingOutputScope?: string
  metadata?: string
}

export type SidecarArtifact = SidecarArtifactWrapper & {
  metadata?: string
  type: 'Dockerhub' | 'Gcr'
  spec?: ArtifactConfig
}

export interface SidecarArtifactWrapper {
  identifier: string
}

export type StageElement = StageElementWrapper & {
  identifier: string
  name?: string
  description?: string
  failureStrategies: FailureStrategyConfig[]
  type?: string
  skipCondition?: string
  metadata?: string
  spec?: StageType
}

export interface StageElementWrapper {
  [key: string]: any
}

export interface StageOverridesConfig {
  variables?: NGVariable[]
  useVariableOverrideSets?: string[]
  useArtifactOverrideSets?: string[]
  artifacts?: ArtifactListConfig
  useManifestOverrideSets?: string[]
  manifests?: ManifestConfigWrapper[]
  metadata?: string
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & { [key: string]: any }

export interface StageType {
  identifier: string
}

export type StepElement = ExecutionWrapper & {
  identifier: string
  name?: string
  failureStrategies?: FailureStrategyConfig[]
  type?: string
  skipCondition?: string
  metadata?: string
  spec?: StepSpecType
}

export type StepGroupElement = ExecutionWrapper & {
  identifier: string
  name?: string
  failureStrategies?: FailureStrategyConfig[]
  steps: ExecutionWrapper[]
  rollbackSteps?: ExecutionWrapper[]
  metadata?: string
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & { [key: string]: any }

export interface StepSpecType {
  [key: string]: any
}

export interface StoreConfig {
  [key: string]: any
}

export interface StoreConfigWrapper {
  type?: string
  metadata?: string
  spec?: StoreConfig
}

export type StringNGVariable = NGVariable & {
  value: string
  default?: string
}

export type ValuesManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
  metadata?: string
}

export interface MergeInputSetRequest {
  inputSetReferences?: string[]
}

export interface ConnectorListFilter {
  orgIdentifier?: string[]
  projectIdentifier?: string[]
  searchTerm?: string
  name?: string[]
  connectorIdentifier?: string[]
  description?: string[]
  type?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
  )[]
  scope?: ('account' | 'org' | 'project')[]
  category?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CONNECTOR'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  connectivityStatus?: ('SUCCESS' | 'FAILURE')[]
  filterIdentifier?: string
  filterOrgIdentifier?: string
  filterProjectIdentifier?: string
  inheritingCredentialsFromDelegate?: boolean
}

export interface ResponseConnectorListFilter {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorListFilter
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseBoolean {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: boolean
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Page {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: { [key: string]: any }[]
  pageIndex?: number
  empty?: boolean
}

export interface PageConnectorListFilter {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ConnectorListFilter[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageConnectorListFilter {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageConnectorListFilter
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  username: string
  accountname: string
  controllerUrl: string
  accountId: string
  passwordRef: string
}

export interface ArtifactoryAuthCredentials {
  [key: string]: any
}

export interface ArtifactoryAuthentication {
  type: 'UsernamePassword'
  spec: ArtifactoryAuthCredentials
}

export type ArtifactoryConnector = ConnectorConfigDTO & {
  artifactoryServerUrl: string
  auth?: ArtifactoryAuthentication
}

export type ArtifactoryUsernamePasswordAuth = ArtifactoryAuthCredentials & {
  username: string
  passwordRef: string
}

export type AwsConnector = ConnectorConfigDTO & {
  credential: AwsCredential
}

export interface AwsCredential {
  crossAccountAccess?: CrossAccountAccess
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec: AwsCredentialSpec
}

export interface AwsCredentialSpec {
  [key: string]: any
}

export type AwsInheritFromDelegateSpec = AwsCredentialSpec & {
  delegateSelector: string
}

export type AwsManualConfigSpec = AwsCredentialSpec & {
  accessKey: string
  secretKeyRef: string
}

export interface ConnectorConfigDTO {
  [key: string]: any
}

export interface ConnectorConnectivityDetails {
  status?: 'SUCCESS' | 'FAILURE'
  errorMessage?: string
  lastTestedAt?: number
  lastConnectedAt?: number
}

export interface ConnectorInfoDTO {
  name: string
  identifier: string
  description?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  type:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
  spec: ConnectorConfigDTO
}

export interface ConnectorResponse {
  connector?: ConnectorInfoDTO
  createdAt?: number
  lastModifiedAt?: number
  status?: ConnectorConnectivityDetails
  harnessManaged?: boolean
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string
  externalId?: string
}

export interface CustomCommitAttributes {
  authorName?: string
  authorEmail?: string
  commitMessage?: string
}

export interface DockerAuthCredentialsDTO {
  [key: string]: any
}

export interface DockerAuthenticationDTO {
  type: 'UsernamePassword' | 'Anonymous'
  spec?: DockerAuthCredentialsDTO
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  dockerRegistryUrl: string
  providerType: 'DockerHub' | 'Harbor' | 'Quay' | 'Other'
  auth?: DockerAuthenticationDTO
}

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  username: string
  passwordRef: string
}

export type GcpConnector = ConnectorConfigDTO & {
  credential?: GcpConnectorCredential
}

export interface GcpConnectorCredential {
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec: GcpCredentialSpec
}

export interface GcpCredentialSpec {
  [key: string]: any
}

export type GcpDelegateDetails = GcpCredentialSpec & {
  delegateSelector?: string
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  projectId?: string
  region?: string
  keyRing?: string
  keyName?: string
  credentials?: string[]
  default?: boolean
}

export type GcpManualDetails = GcpCredentialSpec & {
  secretKeyRef: string
}

export interface GitAuthenticationDTO {
  [key: string]: any
}

export type GitConfigDTO = ConnectorConfigDTO & {
  url: string
  branchName?: string
  type: 'Http' | 'Ssh'
  connectionType: 'Account' | 'Repo'
  spec: GitAuthenticationDTO
  gitSync?: GitSyncConfig
}

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  username: string
  passwordRef: string
}

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyReference?: string
}

export interface GitSyncConfig {
  enabled?: boolean
  customCommitAttributes?: CustomCommitAttributes
  syncEnabled?: boolean
}

export interface GithubApiAccess {
  type: 'GithubApp' | 'Token'
  spec?: GithubApiAccessSpecDTO
}

export interface GithubApiAccessSpecDTO {
  [key: string]: any
}

export type GithubAppSpec = GithubApiAccessSpecDTO & {
  installationId: string
  applicationId: string
  privateKeyRef: string
}

export interface GithubAuthentication {
  type: 'Http' | 'Ssh'
  spec?: GithubCredentialsDTO
}

export type GithubConnector = ConnectorConfigDTO & {
  type: 'Account' | 'Repo'
  url: string
  authentication: GithubAuthentication
  apiAccess?: GithubApiAccess
}

export interface GithubCredentialsDTO {
  [key: string]: any
}

export type GithubHttpCredentials = GithubCredentialsDTO & {
  type: 'UsernameAndPassword' | 'UsernameAndToken'
  spec?: GithubHttpCredentialsSpecDTO
}

export interface GithubHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GithubSshCredentials = GithubCredentialsDTO & {
  spec: GithubSshCredentialsSpec
}

export interface GithubSshCredentialsSpec {
  sshKeyRef: string
}

export type GithubTokenSpec = GithubApiAccessSpecDTO & {
  tokenRef: string
}

export type GithubUsernamePassword = GithubHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type GithubUsernameToken = GithubHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  tokenRef: string
}

export interface GitlabApiAccess {
  type: 'Token'
  spec?: GitlabApiAccessSpecDTO
}

export interface GitlabApiAccessSpecDTO {
  [key: string]: any
}

export interface GitlabAuthentication {
  type: 'Http' | 'Ssh'
  spec?: GitlabCredentialsDTO
}

export type GitlabConnector = ConnectorConfigDTO & {
  type: 'Account' | 'Repo'
  url: string
  authentication: GitlabAuthentication
  apiAccess?: GitlabApiAccess
}

export interface GitlabCredentialsDTO {
  [key: string]: any
}

export type GitlabHttpCredentials = GitlabCredentialsDTO & {
  type: 'UsernameAndPassword' | 'UsernameAndToken'
  spec?: GitlabHttpCredentialsSpecDTO
}

export interface GitlabHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GitlabSshCredentials = GitlabCredentialsDTO & {
  spec: GitlabSshCredentialsSpec
}

export interface GitlabSshCredentialsSpec {
  sshKeyRef: string
}

export type GitlabTokenSpec = GitlabApiAccessSpecDTO & {
  tokenRef: string
}

export type GitlabUsernamePassword = GitlabHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  passwordRef: string
}

export type GitlabUsernameToken = GitlabHttpCredentialsSpecDTO & {
  username?: string
  usernameRef?: string
  tokenRef: string
}

export type JiraConnector = ConnectorConfigDTO & {
  jiraUrl: string
  username?: string
  passwordRef: string
}

export interface KubernetesAuthCredentialDTO {
  [key: string]: any
}

export interface KubernetesAuthDTO {
  type: 'UsernamePassword' | 'ClientKeyCert' | 'ServiceAccount' | 'OpenIdConnect'
  spec: KubernetesAuthCredentialDTO
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string
  clientCertRef: string
  clientKeyRef: string
  clientKeyPassphraseRef: string
  clientKeyAlgo?: string
}

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential?: KubernetesCredentialDTO
}

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  masterUrl: string
  auth: KubernetesAuthDTO
}

export interface KubernetesCredentialDTO {
  type: 'InheritFromDelegate' | 'ManualConfig'
  spec: KubernetesCredentialSpecDTO
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any
}

export type KubernetesDelegateDetailsDTO = KubernetesCredentialSpecDTO & {
  delegateName: string
}

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcIssuerUrl: string
  oidcUsername: string
  oidcClientIdRef: string
  oidcPasswordRef: string
  oidcSecretRef?: string
  oidcScopes?: string
}

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  serviceAccountTokenRef: string
}

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  username: string
  passwordRef: string
}

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean
}

export interface NexusAuthCredentials {
  [key: string]: any
}

export interface NexusAuthentication {
  type: 'UsernamePassword'
  spec: NexusAuthCredentials
}

export type NexusConnector = ConnectorConfigDTO & {
  nexusServerUrl: string
  version: string
  auth?: NexusAuthentication
}

export type NexusUsernamePasswordAuth = NexusAuthCredentials & {
  username: string
  passwordRef: string
}

export interface ResponseConnectorResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  splunkUrl?: string
  username?: string
  accountId: string
  passwordRef: string
}

export type VaultConnectorDTO = ConnectorConfigDTO & {
  authToken?: string
  basePath?: string
  vaultUrl?: string
  renewIntervalHours?: number
  secretEngineName?: string
  appRoleId?: string
  secretId?: string
  secretEngineVersion?: number
  default?: boolean
  readOnly?: boolean
}

export interface Connector {
  connector?: ConnectorInfoDTO
}

export interface PageConnectorResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ConnectorResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageConnectorResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageConnectorResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ConnectorCatalogueItem {
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CONNECTOR'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  connectors?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
  )[]
}

export interface ConnectorCatalogueResponse {
  catalogue?: ConnectorCatalogueItem[]
}

export interface ResponseConnectorCatalogueResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorCatalogueResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ConnectorValidationResult {
  valid?: boolean
  errorMessage?: string
  testedAt?: number
}

export interface ResponseConnectorValidationResult {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorValidationResult
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ConnectorStatistics {
  typeStats?: ConnectorTypeStatistics[]
  statusStats?: ConnectorStatusStatistics[]
}

export interface ConnectorStatusStatistics {
  status?: 'SUCCESS' | 'FAILURE'
  count?: number
}

export interface ConnectorTypeStatistics {
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
  count?: number
}

export interface ResponseConnectorStatistics {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectorStatistics
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitSyncEntityDTO {
  entityName?: string
  entityType?: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets'
  entityIdentifier?: string
  gitConnectorId?: string
  repositoryName?: string
  branch?: string
  filePath?: string
  repoProviderType?: 'github' | 'gitlab' | 'bitbucket' | 'unknown'
}

export interface GitSyncEntityListDTO {
  entityType?: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets'
  count?: number
  gitSyncEntities?: GitSyncEntityDTO[]
}

export interface GitSyncProductDTO {
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  gitSyncEntityListDTOList?: GitSyncEntityListDTO[]
}

export interface ResponseGitSyncProductDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: GitSyncProductDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageGitSyncEntityListDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: GitSyncEntityListDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageGitSyncEntityListDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageGitSyncEntityListDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitSyncConfigDTO {
  identifier?: string
  projectId?: string
  organizationId?: string
  accountId?: string
  gitConnectorId?: string
  repo?: string
  branch?: string
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[]
}

export interface GitSyncFolderConfigDTO {
  rootFolder?: string
  isDefault?: boolean
  identifier?: string
  enabled?: boolean
}

export interface Activity {
  accountIdentifier?: string
  referredEntity?: EntityDetail
  type: 'CONNECTIVITY_CHECK' | 'ENTITY_USAGE' | 'ENTITY_CREATION' | 'ENTITY_UPDATE'
  activityStatus: 'SUCCESS' | 'FAILED'
  detail?: ActivityDetail
  activityTime: number
  description?: string
  errorMessage?: string
}

export interface ActivityDetail {
  [key: string]: any
}

export interface EntityDetail {
  type?: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets'
  entityRef?: EntityReference
  name?: string
}

export interface EntityReference {
  identifier?: string
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
}

export type IdentifierRef = EntityReference & {
  scope?: 'account' | 'org' | 'project'
}

export type InputSetReference = EntityReference & {
  pipelineIdentifier?: string
}

export interface PageActivity {
  totalElements?: number
  totalPages?: number
  size?: number
  content?: Activity[]
  number?: number
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  first?: boolean
  empty?: boolean
}

export interface Pageable {
  offset?: number
  sort?: Sort
  pageSize?: number
  unpaged?: boolean
  paged?: boolean
  pageNumber?: number
}

export interface ResponsePageActivity {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageActivity
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Sort {
  sorted?: boolean
  unsorted?: boolean
  empty?: boolean
}

export interface ResponseActivity {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: Activity
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ConnectivityCheckSummary {
  successCount?: number
  failureCount?: number
  startTime?: number
  endTime?: number
}

export interface ResponseConnectivityCheckSummary {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ConnectivityCheckSummary
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ActivitySummary {
  get_id?: number
  startTime?: number
  endTime?: number
  heartBeatFailuresCount?: number
  successfulActivitiesCount?: number
  failedActivitiesCount?: number
}

export interface PageActivitySummary {
  totalElements?: number
  totalPages?: number
  size?: number
  content?: ActivitySummary[]
  number?: number
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  first?: boolean
  empty?: boolean
}

export interface ResponsePageActivitySummary {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageActivitySummary
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DockerBuildDetailsDTO {
  tag?: string
  buildUrl?: string
  metadata?: {
    [key: string]: string
  }
  labels?: {
    [key: string]: string
  }
  imagePath?: string
}

export interface ResponseDockerBuildDetailsDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DockerBuildDetailsDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface DockerRequestDTO {
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface DockerResponseDTO {
  buildDetailsList?: DockerBuildDetailsDTO[]
}

export interface ResponseDockerResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: DockerResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ContextElement {
  uuid?: string
  name?: string
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
}

export interface DOMConfiguration {
  parameterNames?: DOMStringList
}

export interface DOMImplementation {
  [key: string]: any
}

export interface DOMStringList {
  length?: number
}

export interface DelegateMetaInfo {
  id?: string
  hostName?: string
}

export interface DelegateResponseData {
  [key: string]: any
}

export interface Document {
  implementation?: DOMImplementation
  doctype?: DocumentType
  documentElement?: Element
  inputEncoding?: string
  xmlEncoding?: string
  xmlStandalone?: boolean
  xmlVersion?: string
  strictErrorChecking?: boolean
  documentURI?: string
  domConfig?: DOMConfiguration
  attributes?: NamedNodeMap
  namespaceURI?: string
  prefix?: string
  localName?: string
  nodeType?: number
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface DocumentType {
  name?: string
  publicId?: string
  systemId?: string
  entities?: NamedNodeMap
  notations?: NamedNodeMap
  internalSubset?: string
  attributes?: NamedNodeMap
  namespaceURI?: string
  prefix?: string
  localName?: string
  nodeType?: number
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface Element {
  tagName?: string
  schemaTypeInfo?: TypeInfo
  attributes?: NamedNodeMap
  namespaceURI?: string
  prefix?: string
  localName?: string
  nodeType?: number
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface ExecutionDataValue {
  displayName?: string
  value?: { [key: string]: any }
}

export type HttpStateExecutionData = Outcome & {
  httpUrl?: string
  httpMethod?: string
  httpResponseCode?: number
  httpResponseBody?: string
  assertionStatement?: string
  assertionStatus?: string
  header?: string
  useProxy?: boolean
  warningMessage?: string
  document?: Document
  stateName?: string
  stateType?: string
  startTs?: number
  endTs?: number
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  errorMsg?: string
  waitInterval?: number
  element?: ContextElement
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  delegateMetaInfo?: DelegateMetaInfo
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
}

export interface NamedNodeMap {
  length?: number
}

export interface Node {
  attributes?: NamedNodeMap
  namespaceURI?: string
  prefix?: string
  localName?: string
  nodeType?: number
  nodeName?: string
  nodeValue?: string
  parentNode?: Node
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  previousSibling?: Node
  nextSibling?: Node
  ownerDocument?: Document
  baseURI?: string
  textContent?: string
}

export interface NodeList {
  length?: number
}

export type ScriptStateExecutionData = Outcome & {
  name?: string
  activityId?: string
  sweepingOutputEnvVariables?: {
    [key: string]: string
  }
  stateName?: string
  stateType?: string
  startTs?: number
  endTs?: number
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  errorMsg?: string
  waitInterval?: number
  element?: ContextElement
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  delegateMetaInfo?: DelegateMetaInfo
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
}

export interface TypeInfo {
  typeName?: string
  typeNamespace?: string
}

export interface EntitySetupUsageDTO {
  accountIdentifier?: string
  referredEntity?: EntityDetail
  referredByEntity?: EntityDetail
  createdAt?: number
}

export interface PageEntitySetupUsageDTO {
  totalElements?: number
  totalPages?: number
  size?: number
  content?: EntitySetupUsageDTO[]
  number?: number
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  first?: boolean
  empty?: boolean
}

export interface ResponsePageEntitySetupUsageDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEntitySetupUsageDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseEntitySetupUsageDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EntitySetupUsageDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EnvironmentResponseDTO {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  name?: string
  description?: string
  type?: 'PreProduction' | 'Production'
  deleted?: boolean
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ResponseEnvironmentResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EnvironmentResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EnvironmentRequestDTO {
  orgIdentifier: string
  projectIdentifier: string
  identifier: string
  tags?: {
    [key: string]: string
  }
  name?: string
  description?: string
  type: 'PreProduction' | 'Production'
  version?: number
}

export interface PageEnvironmentResponseDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: EnvironmentResponseDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageEnvironmentResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEnvironmentResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InviteDTO {
  id?: string
  name: string
  email: string
  role: RoleDTO
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE'
  approved: boolean
}

export interface ResponseOptionalInviteDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InviteDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RoleDTO {
  name: string
}

export interface PageInviteDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: InviteDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageInviteDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageInviteDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListInviteOperationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: (
    | 'ACCOUNT_INVITE_ACCEPTED_NEED_PASSWORD'
    | 'ACCOUNT_INVITE_ACCEPTED'
    | 'USER_INVITED_SUCCESSFULLY'
    | 'USER_ALREADY_ADDED'
    | 'USER_ALREADY_INVITED'
    | 'USER_REQUEST_REGISTERED'
    | 'USER_INVITE_RESENT'
    | 'FAIL'
  )[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CreateInviteListDTO {
  users: string[]
  role: RoleDTO
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE'
}

export interface ResponseOptionalListRoleDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: RoleDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Organization {
  accountIdentifier?: string
  identifier: string
  name: string
  description?: string
  tags?: {
    [key: string]: string
  }
}

export interface Project {
  accountIdentifier?: string
  orgIdentifier?: string
  identifier: string
  name: string
  color?: string
  modules?: ('CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE')[]
  description?: string
  tags?: {
    [key: string]: string
  }
}

export interface ProjectAggregateDTO {
  projectResponse: ProjectResponse
  organization?: Organization
  harnessManagedOrg?: boolean
  admins?: UserSearchDTO[]
  collaborators?: UserSearchDTO[]
}

export interface ProjectResponse {
  project: Project
  createdAt?: number
  lastModifiedAt?: number
}

export interface ResponseProjectAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ProjectAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UserSearchDTO {
  name: string
  email: string
  uuid: string
}

export interface OrganizationAggregateDTO {
  organizationResponse: OrganizationResponse
  projectsCount?: number
  admins?: UserSearchDTO[]
  collaborators?: UserSearchDTO[]
}

export interface OrganizationResponse {
  organization: Organization
  createdAt?: number
  lastModifiedAt?: number
  harnessManaged?: boolean
}

export interface ResponseOrganizationAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OrganizationAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageOrganizationAggregateDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: OrganizationAggregateDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageOrganizationAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageOrganizationAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageProjectAggregateDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ProjectAggregateDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageProjectAggregateDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageProjectAggregateDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretFileDTO {
  account: string
  org: string
  project?: string
  identifier: string
  secretManager: string
  name: string
  tags: string[]
  description?: string
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export interface EncryptedDataDTO {
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  valueType?: 'Inline' | 'Reference'
  value?: string
  draft?: boolean
  account?: string
  org?: string
  project?: string
  identifier?: string
  secretManager?: string
  secretManagerName?: string
  name?: string
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  tags?: string[]
  lastUpdatedAt?: number
  description?: string
}

export interface ResponseEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EncryptedDataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseSecretManagerMetadataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretManagerMetadataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretManagerMetadataDTO {
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  spec?: SecretManagerMetadataSpecDTO
}

export interface SecretManagerMetadataSpecDTO {
  [key: string]: any
}

export type VaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  secretEngines?: VaultSecretEngineDTO[]
}

export interface VaultSecretEngineDTO {
  name?: string
  description?: string
  type?: string
  version?: number
}

export interface SecretManagerMetadataRequestDTO {
  encryptionType: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  orgIdentifier?: string
  projectIdentifier?: string
  identifier: string
  spec: SecretManagerMetadataRequestSpecDTO
}

export interface SecretManagerMetadataRequestSpecDTO {
  [key: string]: any
}

export type VaultAppRoleCredentialDTO = VaultCredentialDTO & {
  appRoleId?: string
  secretId?: string
}

export type VaultAuthTokenCredentialDTO = VaultCredentialDTO & {
  authToken?: string
}

export interface VaultCredentialDTO {
  [key: string]: any
}

export type VaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  url: string
  accessType: 'APP_ROLE' | 'TOKEN'
  spec?: VaultCredentialDTO
}

export interface SecretTextDTO {
  account?: string
  org?: string
  project?: string
  identifier?: string
  secretManager?: string
  name?: string
  tags?: string[]
  description?: string
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
  valueType: 'Inline' | 'Reference'
  value?: string
}

export interface PageEncryptedDataDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: EncryptedDataDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageEncryptedDataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface BaseSSHSpecDTO {
  [key: string]: any
}

export type KerberosConfigDTO = BaseSSHSpecDTO & {
  principal: string
  realm: string
  tgtGenerationMethod?: 'KeyTabFilePath' | 'Password'
  spec?: TGTGenerationSpecDTO
}

export interface ResponseSecretResponseWrapper {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretResponseWrapper
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SSHAuthDTO {
  spec: BaseSSHSpecDTO
  type: 'SSH' | 'Kerberos'
}

export type SSHConfigDTO = BaseSSHSpecDTO & {
  credentialType: 'Password' | 'KeyPath' | 'KeyReference'
  spec: SSHCredentialSpecDTO
}

export interface SSHCredentialSpecDTO {
  [key: string]: any
}

export type SSHKeyPathCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  keyPath: string
  encryptedPassphrase?: string
}

export type SSHKeyReferenceCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  key?: string
  encryptedPassphrase?: string
}

export type SSHKeySpecDTO = SecretSpecDTO & {
  port?: number
  auth: SSHAuthDTO
}

export type SSHPasswordCredentialDTO = SSHCredentialSpecDTO & {
  userName: string
  password: string
}

export interface SecretDTOV2 {
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
  name: string
  identifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  description?: string
  spec: SecretSpecDTO
}

export type SecretFileSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
}

export interface SecretResponseWrapper {
  secret: SecretDTOV2
  createdAt?: number
  updatedAt?: number
  draft?: boolean
}

export interface SecretSpecDTO {
  errorMessageForInvalidYaml?: string
}

export type SecretTextSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
  valueType: 'Inline' | 'Reference'
  value?: string
}

export interface TGTGenerationSpecDTO {
  [key: string]: any
}

export type TGTKeyTabFilePathSpecDTO = TGTGenerationSpecDTO & {
  keyPath?: string
}

export type TGTPasswordSpecDTO = TGTGenerationSpecDTO & {
  password?: string
}

export interface SecretRequestWrapper {
  secret: SecretDTOV2
}

export interface PageSecretResponseWrapper {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: SecretResponseWrapper[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageSecretResponseWrapper {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageSecretResponseWrapper
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseSecretValidationResultDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretValidationResultDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretValidationResultDTO {
  success?: boolean
  message?: string
}

export type SSHKeyValidationMetadata = SecretValidationMetaData & {
  host: string
}

export interface SecretValidationMetaData {
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export interface ResponseOrganizationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OrganizationResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface OrganizationRequest {
  organization: Organization
}

export interface PageOrganizationResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: OrganizationResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageOrganizationResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageOrganizationResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseProjectResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ProjectResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ProjectRequest {
  project: Project
}

export interface PageProjectResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ProjectResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageProjectResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageProjectResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type EmailConfigDTO = NotificationSettingConfigDTO & {
  groupEmail: string
}

export type MicrosoftTeamsConfigDTO = NotificationSettingConfigDTO & {
  microsoftTeamsWebhookUrl: string
}

export interface NotificationSettingConfigDTO {
  type?: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS'
}

export type PagerDutyConfigDTO = NotificationSettingConfigDTO & {
  pagerDutyKey: string
}

export interface ResponseUserGroupDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserGroupDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type SlackConfigDTO = NotificationSettingConfigDTO & {
  slackWebhookUrl: string
}

export interface UserGroupDTO {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  name?: string
  users?: string[]
  notificationConfigs?: NotificationSettingConfigDTO[]
  description?: string
  tags?: {
    [key: string]: string
  }
  lastModifiedAt?: number
  version?: number
}

export interface PageUserGroupDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: UserGroupDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageUserGroupDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageUserGroupDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListUserGroupDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: UserGroupDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseServiceResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ServiceResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceResponseDTO {
  accountId?: string
  identifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  name?: string
  description?: string
  deleted?: boolean
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ServiceRequestDTO {
  identifier: string
  orgIdentifier: string
  projectIdentifier: string
  name?: string
  description?: string
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface PageServiceResponseDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: ServiceResponseDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageServiceResponseDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageServiceResponseDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageUserSearchDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: UserSearchDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageUserSearchDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageUserSearchDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ArtifactSummary {
  type?: string
}

export interface ArtifactsSummary {
  primary?: ArtifactSummary
  sidecars?: ArtifactSummary[]
}

export interface CDStageModuleInfo {
  serviceInfoList?: ServiceExecutionSummary
  infrastructureIdentifiers?: string
  nodeExecutionId?: string
}

export interface ResponseCDStageModuleInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: CDStageModuleInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceExecutionSummary {
  identifier?: string
  displayName?: string
  deploymentType?: string
  artifacts?: ArtifactsSummary
}

export interface CDPipelineModuleInfo {
  serviceIdentifiers?: string[]
  envIdentifiers?: string[]
  serviceDefinitionTypes?: string[]
  environmentTypes?: ('PreProduction' | 'Production')[]
}

export interface ResponseCDPipelineModuleInfo {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: CDPipelineModuleInfo
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ByteString {
  empty?: boolean
  validUtf8?: boolean
}

export type CDStageExecutionSummaryDTO = StageExecutionSummaryDTO & {
  planExecutionId?: string
  stageIdentifier?: string
  serviceInfo?: ServiceExecutionSummary
  stageName?: string
  serviceDefinitionType?: string
  executionStatus?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
  startedAt?: number
  endedAt?: number
  serviceIdentifier?: string
  envIdentifier?: string
  errorInfo?: ExecutionErrorInfo
}

export interface Descriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  nestedTypes?: Descriptor[]
  enumTypes?: EnumDescriptor[]
  fields?: FieldDescriptor[]
  extensions?: FieldDescriptor[]
  oneofs?: OneofDescriptor[]
  extendable?: boolean
  name?: string
  options?: MessageOptions
}

export interface EmbeddedUser {
  uuid?: string
  name?: string
  email?: string
}

export interface EnumDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  values?: EnumValueDescriptor[]
  name?: string
  options?: EnumOptions
}

export interface EnumOptions {
  unknownFields?: UnknownFieldSet
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserEnumOptions
  defaultInstanceForType?: EnumOptions
  allowAlias?: boolean
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface EnumValueDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  type?: EnumDescriptor
  name?: string
  number?: number
  options?: EnumValueOptions
}

export interface EnumValueOptions {
  unknownFields?: UnknownFieldSet
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserEnumValueOptions
  defaultInstanceForType?: EnumValueOptions
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface ExecutionErrorInfo {
  unknownFields?: UnknownFieldSet
  message?: string
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserExecutionErrorInfo
  defaultInstanceForType?: ExecutionErrorInfo
  messageBytes?: ByteString
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
}

export interface ExecutionGraph {
  rootNodeId?: string
  nodeMap?: {
    [key: string]: ExecutionNode
  }
  nodeAdjacencyListMap?: {
    [key: string]: ExecutionNodeAdjacencyList
  }
}

export interface ExecutionNode {
  uuid?: string
  name?: string
  startTs?: number
  endTs?: number
  stepType?: string
  status?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
  failureInfo?: FailureInfo
  executableResponsesMetadata?: {
    [key: string]: { [key: string]: any }
  }[]
  taskIdToProgressDataMap?: {
    [key: string]: ProgressData[]
  }
}

export interface ExecutionNodeAdjacencyList {
  children?: string[]
  nextIds?: string[]
}

export interface ExecutionTriggerInfo {
  triggeredBy?: EmbeddedUser
  triggerType?: 'MANUAL' | 'WEBHOOK'
}

export interface FailureInfo {
  unknownFields?: UnknownFieldSet
  errorMessage?: string
  errorMessageBytes?: ByteString
  failureTypesList?: (
    | 'UNKNOWN_FAILURE'
    | 'DELEGATE_PROVISIONING_FAILURE'
    | 'CONNECTIVITY_FAILURE'
    | 'AUTHENTICATION_FAILURE'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_FAILURE'
    | 'AUTHORIZATION_FAILURE'
    | 'TIMEOUT_FAILURE'
    | 'UNRECOGNIZED'
  )[]
  failureTypesCount?: number
  failureTypesValueList?: number[]
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserFailureInfo
  defaultInstanceForType?: FailureInfo
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
}

export interface FieldDescriptor {
  index?: number
  fullName?: string
  jsonName?: string
  file?: FileDescriptor
  extensionScope?: Descriptor
  type?:
    | 'DOUBLE'
    | 'FLOAT'
    | 'INT64'
    | 'UINT64'
    | 'INT32'
    | 'FIXED64'
    | 'FIXED32'
    | 'BOOL'
    | 'STRING'
    | 'GROUP'
    | 'MESSAGE'
    | 'BYTES'
    | 'UINT32'
    | 'ENUM'
    | 'SFIXED32'
    | 'SFIXED64'
    | 'SINT32'
    | 'SINT64'
  containingType?: Descriptor
  messageType?: Descriptor
  containingOneof?: OneofDescriptor
  enumType?: EnumDescriptor
  defaultValue?: { [key: string]: any }
  extension?: boolean
  liteJavaType?: 'INT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'BOOLEAN' | 'STRING' | 'BYTE_STRING' | 'ENUM' | 'MESSAGE'
  liteType?:
    | 'DOUBLE'
    | 'FLOAT'
    | 'INT64'
    | 'UINT64'
    | 'INT32'
    | 'FIXED64'
    | 'FIXED32'
    | 'BOOL'
    | 'STRING'
    | 'GROUP'
    | 'MESSAGE'
    | 'BYTES'
    | 'UINT32'
    | 'ENUM'
    | 'SFIXED32'
    | 'SFIXED64'
    | 'SINT32'
    | 'SINT64'
  packable?: boolean
  name?: string
  number?: number
  options?: FieldOptions
  required?: boolean
  optional?: boolean
  packed?: boolean
  mapField?: boolean
  repeated?: boolean
  javaType?: 'INT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'BOOLEAN' | 'STRING' | 'BYTE_STRING' | 'ENUM' | 'MESSAGE'
}

export interface FieldOptions {
  unknownFields?: UnknownFieldSet
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  packed?: boolean
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserFieldOptions
  defaultInstanceForType?: FieldOptions
  ctype?: 'STRING' | 'CORD' | 'STRING_PIECE'
  jstype?: 'JS_NORMAL' | 'JS_STRING' | 'JS_NUMBER'
  lazy?: boolean
  weak?: boolean
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface FileDescriptor {
  messageTypes?: Descriptor[]
  enumTypes?: EnumDescriptor[]
  services?: ServiceDescriptor[]
  extensions?: FieldDescriptor[]
  dependencies?: FileDescriptor[]
  publicDependencies?: FileDescriptor[]
  syntax?: 'UNKNOWN' | 'PROTO2' | 'PROTO3'
  name?: string
  package?: string
  file?: FileDescriptor
  options?: FileOptions
  fullName?: string
}

export interface FileOptions {
  unknownFields?: UnknownFieldSet
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  javaStringCheckUtf8?: boolean
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserFileOptions
  defaultInstanceForType?: FileOptions
  javaPackage?: string
  javaPackageBytes?: ByteString
  javaOuterClassname?: string
  javaOuterClassnameBytes?: ByteString
  javaMultipleFiles?: boolean
  javaGenerateEqualsAndHash?: boolean
  optimizeFor?: 'SPEED' | 'CODE_SIZE' | 'LITE_RUNTIME'
  goPackage?: string
  goPackageBytes?: ByteString
  ccGenericServices?: boolean
  javaGenericServices?: boolean
  pyGenericServices?: boolean
  phpGenericServices?: boolean
  ccEnableArenas?: boolean
  objcClassPrefix?: string
  objcClassPrefixBytes?: ByteString
  csharpNamespace?: string
  csharpNamespaceBytes?: ByteString
  swiftPrefix?: string
  swiftPrefixBytes?: ByteString
  phpClassPrefix?: string
  phpClassPrefixBytes?: ByteString
  phpNamespace?: string
  phpNamespaceBytes?: ByteString
  phpMetadataNamespace?: string
  phpMetadataNamespaceBytes?: ByteString
  rubyPackage?: string
  rubyPackageBytes?: ByteString
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface Message {
  parserForType?: ParserMessage
  serializedSize?: number
  initialized?: boolean
  defaultInstanceForType?: MessageLite
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  unknownFields?: UnknownFieldSet
}

export interface MessageLite {
  serializedSize?: number
  parserForType?: ParserMessageLite
  initialized?: boolean
  defaultInstanceForType?: MessageLite
}

export interface MessageOptions {
  unknownFields?: UnknownFieldSet
  noStandardDescriptorAccessor?: boolean
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  mapEntry?: boolean
  messageSetWireFormat?: boolean
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserMessageOptions
  defaultInstanceForType?: MessageOptions
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface MethodDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  service?: ServiceDescriptor
  inputType?: Descriptor
  outputType?: Descriptor
  name?: string
  options?: MethodOptions
  clientStreaming?: boolean
  serverStreaming?: boolean
}

export interface MethodOptions {
  unknownFields?: UnknownFieldSet
  idempotencyLevel?: 'IDEMPOTENCY_UNKNOWN' | 'NO_SIDE_EFFECTS' | 'IDEMPOTENT'
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserMethodOptions
  defaultInstanceForType?: MethodOptions
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface NGStageType {
  type?: string
}

export interface NamePart {
  unknownFields?: UnknownFieldSet
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserNamePart
  defaultInstanceForType?: NamePart
  namePart?: string
  namePartBytes?: ByteString
  isExtension?: boolean
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
}

export interface NamePartOrBuilder {
  namePart?: string
  namePartBytes?: ByteString
  isExtension?: boolean
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initialized?: boolean
}

export interface OneofDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  containingType?: Descriptor
  fieldCount?: number
  fields?: FieldDescriptor[]
  name?: string
  options?: OneofOptions
}

export interface OneofOptions {
  unknownFields?: UnknownFieldSet
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserOneofOptions
  defaultInstanceForType?: OneofOptions
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export type ParallelStageExecutionSummaryDTO = StageExecutionSummaryDTO & {
  stageExecutions?: StageExecutionSummaryDTO[]
}

export interface Parser {
  [key: string]: any
}

export interface ParserEnumOptions {
  [key: string]: any
}

export interface ParserEnumValueOptions {
  [key: string]: any
}

export interface ParserExecutionErrorInfo {
  [key: string]: any
}

export interface ParserFailureInfo {
  [key: string]: any
}

export interface ParserFieldOptions {
  [key: string]: any
}

export interface ParserFileOptions {
  [key: string]: any
}

export interface ParserMessage {
  [key: string]: any
}

export interface ParserMessageLite {
  [key: string]: any
}

export interface ParserMessageOptions {
  [key: string]: any
}

export interface ParserMethodOptions {
  [key: string]: any
}

export interface ParserNamePart {
  [key: string]: any
}

export interface ParserOneofOptions {
  [key: string]: any
}

export interface ParserServiceOptions {
  [key: string]: any
}

export interface ParserUninterpretedOption {
  [key: string]: any
}

export interface PipelineExecutionDetail {
  pipelineExecution?: PipelineExecutionSummaryDTO
  stageGraph?: ExecutionGraph
  stageRollbackGraph?: ExecutionGraph
}

export interface PipelineExecutionSummaryDTO {
  pipelineIdentifier?: string
  pipelineName?: string
  deploymentId?: string
  planExecutionId?: string
  executionStatus?:
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
  inputSetYaml?: string
  startedAt?: number
  endedAt?: number
  tags?: {
    [key: string]: string
  }
  stageExecutionSummaryElements?: StageExecutionSummaryDTO[]
  errorMsg?: string
  stageIdentifiers?: string[]
  serviceIdentifiers?: string[]
  envIdentifiers?: string[]
  serviceDefinitionTypes?: string[]
  stageTypes?: NGStageType[]
  errorInfo?: ExecutionErrorInfo
  triggerInfo?: ExecutionTriggerInfo
  successfulStagesCount?: number
  runningStagesCount?: number
  failedStagesCount?: number
  totalStagesCount?: number
}

export interface ProgressData {
  [key: string]: any
}

export interface ResponsePipelineExecutionDetail {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionDetail
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceDescriptor {
  index?: number
  fullName?: string
  file?: FileDescriptor
  methods?: MethodDescriptor[]
  name?: string
  options?: ServiceOptions
}

export interface ServiceOptions {
  unknownFields?: UnknownFieldSet
  deprecated?: boolean
  uninterpretedOptionList?: UninterpretedOption[]
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[]
  uninterpretedOptionCount?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserServiceOptions
  defaultInstanceForType?: ServiceOptions
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  allFieldsRaw?: {
    [key: string]: { [key: string]: any }
  }
}

export interface StageExecutionSummaryDTO {
  [key: string]: any
}

export interface UninterpretedOption {
  unknownFields?: UnknownFieldSet
  nameList?: NamePart[]
  nameOrBuilderList?: NamePartOrBuilder[]
  identifierValue?: string
  identifierValueBytes?: ByteString
  positiveIntValue?: number
  negativeIntValue?: number
  aggregateValue?: string
  aggregateValueBytes?: ByteString
  nameCount?: number
  stringValue?: ByteString
  doubleValue?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: ParserUninterpretedOption
  defaultInstanceForType?: UninterpretedOption
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
}

export interface UninterpretedOptionOrBuilder {
  nameList?: NamePart[]
  nameOrBuilderList?: NamePartOrBuilder[]
  identifierValue?: string
  identifierValueBytes?: ByteString
  positiveIntValue?: number
  negativeIntValue?: number
  aggregateValue?: string
  aggregateValueBytes?: ByteString
  nameCount?: number
  stringValue?: ByteString
  doubleValue?: number
  allFields?: {
    [key: string]: { [key: string]: any }
  }
  initializationErrorString?: string
  descriptorForType?: Descriptor
  unknownFields?: UnknownFieldSet
  defaultInstanceForType?: Message
  initialized?: boolean
}

export interface UnknownFieldSet {
  serializedSizeAsMessageSet?: number
  initialized?: boolean
  serializedSize?: number
  parserForType?: Parser
  defaultInstanceForType?: UnknownFieldSet
}

export interface ResponseListExecutionStatus {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: (
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
  )[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseMapExecutionNodeTypeString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: {
    [key: string]: string
  }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponsePipelineExecutionInterrupt {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineExecutionInterrupt
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PipelineExecutionInterrupt {
  id?: string
  type?: 'Abort' | 'Pause' | 'Resume'
  planExecutionId?: string
}

export interface PagePipelineExecutionSummaryDTO {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: PipelineExecutionSummaryDTO[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePagePipelineExecutionSummaryDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PagePipelineExecutionSummaryDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraIssueType {
  id?: string
  name?: string
  description?: string
  jiraStatusList?: JiraStatus[]
  subTask?: boolean
}

export interface JiraProject {
  id?: string
  key?: string
  name?: string
  issuetypes?: JiraIssueType[]
}

export interface JiraProjectResponse {
  jiraProjects?: JiraProject[]
}

export interface JiraStatus {
  id?: string
  name?: string
  untranslatedName?: string
  description?: string
  statusCategory?: JiraStatusCategory
}

export interface JiraStatusCategory {
  id?: string
  key?: string
  name?: string
}

export interface ResponseJiraProjectResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraProjectResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CreateJiraTicketRequest {
  project: string
  summary: string
  description: string
  issueType: string
  priority?: string
  labels?: string[]
  customFields?: {
    [key: string]: JiraCustomFieldValue
  }
  issueId?: string
  updateIssueIds?: string[]
  status?: string
  comment?: string
  createmetaExpandParam?: string
  activityId?: string
  approvalId?: string
  approvalField?: string
  approvalValue?: string
  rejectionField?: string
  rejectionValue?: string
}

export interface JiraCustomFieldValue {
  fieldType?: string
  fieldValue?: string
}

export interface UpdateJiraTicketRequest {
  updateIssueIds: string[]
  project: string
  summary?: string
  description?: string
  issueType?: string
  priority?: string
  labels?: string[]
  customFields?: {
    [key: string]: JiraCustomFieldValue
  }
  status?: string
  comment?: string
  createmetaExpandParam?: string
  activityId?: string
  approvalId?: string
  approvalField?: string
  approvalValue?: string
  rejectionField?: string
  rejectionValue?: string
}

export interface JiraIssue {
  executionStatus?: string
  issueUrl?: string
  issueKey?: string
  currentStatus?: string
  errorMessage?: string
  description?: string
}

export interface ResponseJiraIssue {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraIssue
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraProjectStatusesResponse {
  jiraIssueTypeList?: JiraIssueType[]
}

export interface ResponseJiraProjectStatusesResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraProjectStatusesResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraField {
  key?: string
  name?: string
  required?: boolean
  schema?: {
    [key: string]: { [key: string]: any }
  }
  allowedValues?: { [key: string]: any }[]
  custom?: boolean
}

export interface JiraFieldResponse {
  jiraFields?: JiraField[]
}

export interface ResponseJiraFieldResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraFieldResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraApproval {
  status?: string
  approved?: boolean
}

export interface JiraApprovalResponse {
  jiraApproval?: JiraApproval
}

export interface ResponseJiraApprovalResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraApprovalResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JiraGetCreateMetadata {
  expand?: string
  projects?: JiraProject[]
}

export interface JiraGetCreateMetadataResponse {
  jiraGetCreateMetadata?: JiraGetCreateMetadata
}

export interface ResponseJiraGetCreateMetadataResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JiraGetCreateMetadataResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface AmbianceDTO {
  setupAbstractions?: {
    [key: string]: string
  }
  levels?: LevelDTO[]
  planExecutionId?: string
}

export interface ArtifactOutcome {
  primaryArtifact?: boolean
  artifactType?: string
  type?: string
  identifier: string
  artifactSummary?: ArtifactSummary
}

export type ArtifactsOutcome = Outcome & {
  primary?: ArtifactOutcome
  sidecars?: {
    [key: string]: ArtifactOutcome
  }
}

export interface AzureAppDeploymentData {
  instanceId?: string
  instanceType?: string
  instanceName?: string
  resourceGroup?: string
  subscriptionId?: string
  appName?: string
  deploySlot?: string
  deploySlotId?: string
  appServicePlanId?: string
  hostName?: string
  instanceIp?: string
  instanceState?: string
}

export interface AzureVMInstanceData {
  instanceId?: string
  publicDnsName?: string
  privateDnsName?: string
  privateIpAddress?: string
}

export type BarrierOutcome = Outcome & {
  message?: string
  identifier?: string
}

export interface CapacityReservationSpecificationResponse {
  capacityReservationPreference?: string
  capacityReservationTarget?: CapacityReservationTargetResponse
}

export interface CapacityReservationTargetResponse {
  capacityReservationId?: string
  capacityReservationResourceGroupArn?: string
}

export interface CpuOptions {
  coreCount?: number
  threadsPerCore?: number
}

export type DockerArtifactOutcome = Outcome & {
  connectorRef?: string
  imagePath?: string
  tag?: string
  tagRegex?: string
  identifier: string
  artifactType?: string
  primaryArtifact?: boolean
  artifactSummary?: ArtifactSummary
}

export type DummySectionOutcome = Outcome & {
  map?: {
    [key: string]: string
  }
}

export interface Duration {
  seconds?: number
  units?: TemporalUnit[]
  zero?: boolean
  negative?: boolean
  nano?: number
}

export interface EbsInstanceBlockDevice {
  attachTime?: string
  deleteOnTermination?: boolean
  status?: string
  volumeId?: string
}

export interface EcsContainerDetails {
  taskId?: string
  taskArn?: string
  dockerId?: string
  completeDockerId?: string
  containerId?: string
  containerInstanceId?: string
  containerInstanceArn?: string
  ecsServiceName?: string
}

export interface EdgeList {
  edges?: string[]
  nextIds?: string[]
}

export interface ElasticGpuAssociation {
  elasticGpuId?: string
  elasticGpuAssociationId?: string
  elasticGpuAssociationState?: string
  elasticGpuAssociationTime?: string
}

export interface ElasticInferenceAcceleratorAssociation {
  elasticInferenceAcceleratorArn?: string
  elasticInferenceAcceleratorAssociationId?: string
  elasticInferenceAcceleratorAssociationState?: string
  elasticInferenceAcceleratorAssociationTime?: string
}

export type EnvironmentOutcome = Outcome & {
  name?: string
  identifier?: string
  description?: string
  environmentType?: 'PreProduction' | 'Production'
  tags?: NGTag[]
}

export interface GitFile {
  filePath?: string
  fileContent?: string
}

export interface GraphVertexDTO {
  uuid?: string
  ambiance?: AmbianceDTO
  planNodeId?: string
  identifier?: string
  name?: string
  startTs?: number
  endTs?: number
  initialWaitDuration?: Duration
  lastUpdatedAt?: number
  stepType?: string
  status?:
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'UNRECOGNIZED'
  failureInfo?: FailureInfo
  stepParameters?: {
    [key: string]: { [key: string]: any }
  }
  mode?:
    | 'UNKNOWN'
    | 'SYNC'
    | 'ASYNC'
    | 'TASK_CHAIN'
    | 'TASK'
    | 'CHILD_CHAIN'
    | 'CHILDREN'
    | 'CHILD'
    | 'SKIP'
    | 'UNRECOGNIZED'
  executableResponsesMetadata?: {
    [key: string]: { [key: string]: any }
  }[]
  interruptHistories?: InterruptEffect[]
  outcomes?: Outcome[]
  retryIds?: string[]
  progressDataMap?: {
    [key: string]: ProgressData[]
  }
  skipType?: 'NOOP' | 'SKIP_TREE' | 'SKIP_NODE' | 'UNRECOGNIZED'
}

export interface GroupIdentifier {
  groupName?: string
  groupId?: string
}

export interface HibernationOptions {
  configured?: boolean
}

export interface HostElement {
  uuid?: string
  hostName?: string
  ip?: string
  instanceId?: string
  publicDns?: string
  properties?: {
    [key: string]: { [key: string]: any }
  }
  ec2Instance?: Instance
  pcfElement?: PcfInstanceElement
  azureVMInstance?: AzureVMInstanceData
  webAppInstance?: AzureAppDeploymentData
  name?: string
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
}

export interface IamInstanceProfile {
  arn?: string
  id?: string
}

export interface Instance {
  amiLaunchIndex?: number
  imageId?: string
  instanceId?: string
  instanceType?: string
  kernelId?: string
  keyName?: string
  launchTime?: string
  monitoring?: Monitoring
  placement?: Placement
  platform?: string
  privateDnsName?: string
  privateIpAddress?: string
  productCodes?: ProductCode[]
  publicDnsName?: string
  publicIpAddress?: string
  ramdiskId?: string
  state?: InstanceState
  stateTransitionReason?: string
  subnetId?: string
  vpcId?: string
  architecture?: string
  blockDeviceMappings?: InstanceBlockDeviceMapping[]
  clientToken?: string
  ebsOptimized?: boolean
  enaSupport?: boolean
  hypervisor?: string
  iamInstanceProfile?: IamInstanceProfile
  instanceLifecycle?: string
  elasticGpuAssociations?: ElasticGpuAssociation[]
  elasticInferenceAcceleratorAssociations?: ElasticInferenceAcceleratorAssociation[]
  networkInterfaces?: InstanceNetworkInterface[]
  outpostArn?: string
  rootDeviceName?: string
  rootDeviceType?: string
  securityGroups?: GroupIdentifier[]
  sourceDestCheck?: boolean
  spotInstanceRequestId?: string
  sriovNetSupport?: string
  stateReason?: StateReason
  tags?: Tag[]
  virtualizationType?: string
  cpuOptions?: CpuOptions
  capacityReservationId?: string
  capacityReservationSpecification?: CapacityReservationSpecificationResponse
  hibernationOptions?: HibernationOptions
  licenses?: LicenseConfiguration[]
  metadataOptions?: InstanceMetadataOptionsResponse
}

export interface InstanceBlockDeviceMapping {
  deviceName?: string
  ebs?: EbsInstanceBlockDevice
}

export interface InstanceElement {
  uuid?: string
  displayName?: string
  hostName?: string
  dockerId?: string
  host?: HostElement
  serviceTemplateElement?: ServiceTemplateElement
  podName?: string
  workloadName?: string
  ecsContainerDetails?: EcsContainerDetails
  newInstance?: boolean
  name?: string
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
}

export type InstanceFetchStateExecutionData = Outcome & {
  activityId?: string
  hostObjectArrayPath?: string
  instanceFetchScript?: string
  hostAttributes?: {
    [key: string]: string
  }
  scriptOutput?: string
  newInstanceStatusSummaries?: InstanceStatusSummary[]
  tags?: string[]
  stateName?: string
  stateType?: string
  startTs?: number
  endTs?: number
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  errorMsg?: string
  waitInterval?: number
  element?: ContextElement
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  delegateMetaInfo?: DelegateMetaInfo
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
}

export interface InstanceIpv6Address {
  ipv6Address?: string
}

export interface InstanceMetadataOptionsResponse {
  state?: string
  httpTokens?: string
  httpPutResponseHopLimit?: number
  httpEndpoint?: string
}

export interface InstanceNetworkInterface {
  association?: InstanceNetworkInterfaceAssociation
  attachment?: InstanceNetworkInterfaceAttachment
  description?: string
  groups?: GroupIdentifier[]
  ipv6Addresses?: InstanceIpv6Address[]
  macAddress?: string
  networkInterfaceId?: string
  ownerId?: string
  privateDnsName?: string
  privateIpAddress?: string
  privateIpAddresses?: InstancePrivateIpAddress[]
  sourceDestCheck?: boolean
  status?: string
  subnetId?: string
  vpcId?: string
  interfaceType?: string
}

export interface InstanceNetworkInterfaceAssociation {
  ipOwnerId?: string
  publicDnsName?: string
  publicIp?: string
}

export interface InstanceNetworkInterfaceAttachment {
  attachTime?: string
  attachmentId?: string
  deleteOnTermination?: boolean
  deviceIndex?: number
  status?: string
}

export interface InstancePrivateIpAddress {
  association?: InstanceNetworkInterfaceAssociation
  primary?: boolean
  privateDnsName?: string
  privateIpAddress?: string
}

export interface InstanceState {
  code?: number
  name?: string
}

export interface InstanceStatusSummary {
  instanceElement?: InstanceElement
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
}

export interface InterruptEffect {
  interruptId: string
  tookEffectAt: number
  interruptType:
    | 'ABORT'
    | 'ABORT_ALL'
    | 'PAUSE'
    | 'PAUSE_FOR_INPUTS'
    | 'PAUSE_ALL'
    | 'RESUME'
    | 'RESUME_ALL'
    | 'RETRY'
    | 'IGNORE'
    | 'MARK_FAILED'
    | 'MARK_SUCCESS'
    | 'ROLLBACK'
    | 'NEXT_STEP'
    | 'END_EXECUTION'
    | 'ROLLBACK_DONE'
    | 'MARK_EXPIRED'
    | 'CONTINUE_WITH_DEFAULTS'
    | 'CONTINUE_PIPELINE_STAGE'
}

export type K8sBlueGreenOutcome = Outcome & {
  releaseNumber?: number
  releaseName?: string
  primaryServiceName?: string
  stageServiceName?: string
  stageColor?: string
  primaryColor?: string
}

export type K8sDirectInfraMapping = Outcome & {
  uuid?: string
  accountId?: string
  k8sConnector?: string
  namespace?: string
  serviceIdentifier?: string
}

export type K8sDirectInfrastructureOutcome = Outcome & {
  connectorRef?: string
  namespace?: string
  releaseName?: string
  kind?: string
}

export type K8sRollingOutcome = Outcome & {
  releaseName?: string
  releaseNumber?: number
}

export interface LevelDTO {
  setupId?: string
  runtimeId?: string
  identifier?: string
  stepType?: string
  group?: string
}

export interface LicenseConfiguration {
  licenseConfigurationArn?: string
}

export interface ManifestDataDetails {
  identifier?: string
  gitFiles?: GitFile[]
}

export type ManifestFetchOutcome = Outcome & {
  manifestDataDetailsForSpec?: ManifestDataDetails[]
  manifestDataDetailsForOverrides?: ManifestDataDetails[]
}

export type ManifestOutcome = Outcome & {
  manifestAttributes?: ManifestAttributes[]
}

export interface Monitoring {
  state?: string
}

export interface NGTag {
  key: string
  value: string
}

export interface OrchestrationAdjacencyListDTO {
  graphVertexMap?: {
    [key: string]: GraphVertexDTO
  }
  adjacencyMap?: {
    [key: string]: EdgeList
  }
}

export interface OrchestrationGraphDTO {
  planExecutionId?: string
  startTs?: number
  endTs?: number
  status?:
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'UNRECOGNIZED'
  rootNodeIds?: string[]
  adjacencyList?: OrchestrationAdjacencyListDTO
}

export interface Outcome {
  type?: string
}

export interface PcfInstanceElement {
  uuid?: string
  applicationId?: string
  instanceIndex?: string
  displayName?: string
  upsize?: boolean
  newInstance?: boolean
  name?: string
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
}

export interface Placement {
  availabilityZone?: string
  affinity?: string
  groupName?: string
  partitionNumber?: number
  hostId?: string
  tenancy?: string
  spreadDomain?: string
  hostResourceGroupArn?: string
}

export interface ProductCode {
  productCodeId?: string
  productCodeType?: string
}

export type ResourceRestraintOutcome = Outcome & {
  name?: string
  capacity?: number
  resourceUnit?: string
  usage?: number
  alreadyAcquiredPermits?: number
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
  level?: 'INFO' | 'ERROR'
  message?: string
  exception?: Throwable
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseOrchestrationGraphDTO {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: OrchestrationGraphDTO
  responseMessages?: ResponseMessage[]
}

export interface ServiceElement {
  uuid?: string
  name?: string
  description?: string
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
}

export type ServiceOutcome = Outcome & {
  identifier?: string
  displayName?: string
  description?: string
  deploymentType?: string
  artifacts?: ArtifactsOutcome
  manifests?: ManifestAttributes[]
}

export interface ServiceTemplateElement {
  uuid?: string
  name?: string
  serviceElement?: ServiceElement
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
}

export interface StackTraceElement {
  methodName?: string
  fileName?: string
  lineNumber?: number
  className?: string
  nativeMethod?: boolean
}

export interface StateReason {
  code?: string
  message?: string
}

export interface Tag {
  key?: string
  value?: string
}

export interface TemporalUnit {
  dateBased?: boolean
  durationEstimated?: boolean
  duration?: Duration
  timeBased?: boolean
}

export interface Throwable {
  cause?: Throwable
  stackTrace?: StackTraceElement[]
  message?: string
  localizedMessage?: string
  suppressed?: Throwable[]
}

export type WaitStateExecutionData = Outcome & {
  stateName?: string
  stateType?: string
  startTs?: number
  endTs?: number
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  errorMsg?: string
  waitInterval?: number
  element?: ContextElement
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  delegateMetaInfo?: DelegateMetaInfo
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  duration?: number
  wakeupTs?: number
  resumeId?: string
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
}

export interface StreamingOutput {
  [key: string]: any
}

export interface RestResponsePlanExecution {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: PlanExecution
  responseMessages?: ResponseMessage[]
}

export interface InputSetError {
  fieldName?: string
  message?: string
  identifierOfErrorSource?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export interface InputSetErrorWrapper {
  errorPipelineYaml?: string
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export interface InputSetResponse {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  inputSetYaml?: string
  name?: string
  description?: string
  tags?: {
    [key: string]: string
  }
  inputSetErrorWrapper?: InputSetErrorWrapper
  version?: number
  errorResponse?: boolean
}

export interface ResponseInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface OverlayInputSetResponse {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  identifier?: string
  name?: string
  description?: string
  inputSetReferences?: string[]
  overlayInputSetYaml?: string
  tags?: {
    [key: string]: string
  }
  invalidInputSetReferences?: {
    [key: string]: string
  }
  version?: number
  errorResponse?: boolean
}

export interface ResponseOverlayInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OverlayInputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetConfig {
  identifier: string
  name?: string
  description?: string
  pipeline: NgPipeline
  tags?: {
    [key: string]: string
  }
}

export interface OverlayInputSetConfig {
  identifier?: string
  name?: string
  description?: string
  inputSetReferences?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface InputSetSummaryResponse {
  identifier?: string
  name?: string
  pipelineIdentifier?: string
  description?: string
  inputSetType?: 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface PageInputSetSummaryResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: InputSetSummaryResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageInputSetSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageInputSetSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface InputSetTemplateResponse {
  inputSetTemplateYaml?: string
}

export interface ResponseInputSetTemplateResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: InputSetTemplateResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface MergeInputSetResponse {
  pipelineYaml?: string
  inputSetErrorWrapper?: InputSetErrorWrapper
  errorResponse?: boolean
}

export interface ResponseMergeInputSetResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: MergeInputSetResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPipelineResponse {
  ngPipeline?: NgPipeline
  executionsPlaceHolder?: string[]
  yamlPipeline?: string
  version?: number
}

export interface ResponseNGPipelineResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGPipelineSummaryResponse {
  name?: string
  identifier?: string
  description?: string
  numOfStages?: number
  numOfErrors?: number
  deployments?: number[]
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ResponseNGPipelineSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPipelineSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageNGPipelineSummaryResponse {
  totalElements?: number
  totalPages?: number
  size?: number
  content?: NGPipelineSummaryResponse[]
  number?: number
  sort?: Sort
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  first?: boolean
  empty?: boolean
}

export interface ResponsePageNGPipelineSummaryResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageNGPipelineSummaryResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type DeploymentStageConfig = StageInfoConfig & {
  uuid?: string
  variables?: NGVariable[]
  service?: ServiceConfig
  infrastructure?: PipelineInfrastructure
  execution?: ExecutionElementConfig
  skipCondition?: string
}

export interface ExecutionElementConfig {
  uuid?: string
  steps?: ExecutionWrapperConfig[]
  rollbackSteps?: ExecutionWrapperConfig[]
}

export interface ExecutionWrapperConfig {
  step?: StepElementConfig
  parallel?: ParallelStepElementConfig
  stepGroup?: StepGroupElementConfig
}

export interface ParallelStageElementConfig {
  sections: StageElementWrapperConfig[]
}

export interface ParallelStepElementConfig {
  sections: ExecutionWrapperConfig[]
}

export interface PipelineConfig {
  pipeline?: PipelineInfoConfig
}

export interface PipelineInfoConfig {
  uuid?: string
  name: string
  identifier: string
  description?: string
  tags?: {
    [key: string]: string
  }
  variables?: NGVariable[]
  ciCodebase?: CodeBase
  stages?: StageElementWrapperConfig[]
}

export interface ResponsePipelineConfig {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PipelineConfig
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface StageElementConfig {
  uuid?: string
  identifier: string
  name?: string
  description?: string
  failureStrategies: FailureStrategyConfig[]
  type?: string
  spec?: StageInfoConfig
}

export interface StageElementWrapperConfig {
  stage?: StageElementConfig
  parallel?: ParallelStageElementConfig
}

export interface StageInfoConfig {
  [key: string]: any
}

export interface StepElementConfig {
  uuid?: string
  identifier?: string
  name?: string
  failureStrategies?: FailureStrategyConfig[]
  type?: string
  spec?: StepSpecType
  skipCondition?: string
}

export interface StepGroupElementConfig {
  uuid?: string
  identifier: string
  name?: string
  failureStrategies?: FailureStrategyConfig[]
  steps: ExecutionWrapperConfig[]
  rollbackSteps?: ExecutionWrapperConfig[]
}

export interface NGTriggerResponse {
  name?: string
  identifier?: string
  description?: string
  type?: 'Webhook' | 'NewArtifact' | 'Scheduled'
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  targetIdentifier?: string
  yaml?: string
  version?: number
}

export interface ResponseNGTriggerResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGTriggerResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface NGTriggerConfig {
  name?: string
  identifier: string
  description?: string
  target?: NGTriggerTarget
  source?: NGTriggerSource
  tags?: {
    [key: string]: string
  }
  enabled?: boolean
}

export interface NGTriggerSource {
  type?: 'Webhook' | 'NewArtifact' | 'Scheduled'
  spec?: NGTriggerSpec
}

export interface NGTriggerSpec {
  [key: string]: any
}

export interface NGTriggerTarget {
  targetIdentifier?: string
  type?: 'Pipeline'
  spec?: TargetSpec
}

export interface TargetSpec {
  [key: string]: any
}

export interface WebhookPayloadCondition {
  key?: string
  operator?: string
  value?: string
}

export type WebhookTriggerConfig = NGTriggerSpec & {
  type?: string
  spec?: WebhookTriggerSpec
}

export interface WebhookTriggerSpec {
  repoUrl?: string
  event?: 'Pull Request' | 'Push' | 'Issue' | 'Delete' | 'Merge Request' | 'Repository'
  actions?: (
    | 'created'
    | 'closed'
    | 'edited'
    | 'edited'
    | 'opened'
    | 'reopened'
    | 'labeled'
    | 'unlabeled'
    | 'deleted'
    | 'synchronized'
    | 'synced'
    | 'merged'
    | 'sync'
    | 'open'
    | 'close'
    | 'reopen'
    | 'merge'
    | 'update'
    | 'pull request created'
    | 'pull request updated'
    | 'pull request merged'
    | 'pull request declined'
  )[]
  payloadConditions?: WebhookPayloadCondition[]
  pathFilters?: string[]
}

export interface LastTriggerExecutionDetails {
  lastExecutionTime?: number
  lastExecutionSuccessful?: boolean
  lastExecutionStatus?: string
  planExecutionId?: string
  message?: string
}

export interface NGTriggerDetailsResponse {
  name?: string
  identifier?: string
  description?: string
  type?: 'Webhook' | 'NewArtifact' | 'Scheduled'
  lastTriggerExecutionDetails?: LastTriggerExecutionDetails
  webhookDetails?: WebhookDetails
  tags?: {
    [key: string]: string
  }
  executions?: number[]
  yaml?: string
  enabled?: boolean
}

export interface PageNGTriggerDetailsResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: NGTriggerDetailsResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageNGTriggerDetailsResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageNGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface WebhookDetails {
  webhookSecret?: string
  webhookSourceRepo?: string
}

export interface ResponseNGTriggerDetailsResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface PageNGTriggerResponse {
  totalPages?: number
  totalItems?: number
  pageItemCount?: number
  pageSize?: number
  content?: NGTriggerResponse[]
  pageIndex?: number
  empty?: boolean
}

export interface ResponsePageNGTriggerResponse {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageNGTriggerResponse
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseMapWebhookSourceRepoListWebhookEvent {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: {
    [key: string]: ('Pull Request' | 'Push' | 'Issue' | 'Delete' | 'Merge Request' | 'Repository')[]
  }
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseListWebhookAction {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: (
    | 'created'
    | 'closed'
    | 'edited'
    | 'edited'
    | 'opened'
    | 'reopened'
    | 'labeled'
    | 'unlabeled'
    | 'deleted'
    | 'synchronized'
    | 'synced'
    | 'merged'
    | 'sync'
    | 'open'
    | 'close'
    | 'reopen'
    | 'merge'
    | 'update'
    | 'pull request created'
    | 'pull request updated'
    | 'pull request merged'
    | 'pull request declined'
  )[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface JsonNode {
  array?: boolean
  null?: boolean
  object?: boolean
  valueNode?: boolean
  containerNode?: boolean
  missingNode?: boolean
  nodeType?: 'ARRAY' | 'BINARY' | 'BOOLEAN' | 'MISSING' | 'NULL' | 'NUMBER' | 'OBJECT' | 'POJO' | 'STRING'
  pojo?: boolean
  number?: boolean
  integralNumber?: boolean
  floatingPointNumber?: boolean
  short?: boolean
  int?: boolean
  long?: boolean
  float?: boolean
  double?: boolean
  bigDecimal?: boolean
  bigInteger?: boolean
  textual?: boolean
  boolean?: boolean
  binary?: boolean
}

export interface ResponseJsonNode {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: JsonNode
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseYamlSnippets {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: YamlSnippets
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface YamlSnippetMetaData {
  name?: string
  description?: string
  version?: string
  identifier?: string
  tags?: string[]
  iconTag?: string
}

export interface YamlSnippets {
  yamlSnippets?: YamlSnippetMetaData[]
}

export type SecretFileDTORequestBody = void

export type DockerRequestDTORequestBody = DockerRequestDTO

export type GitSyncConfigDTORequestBody = GitSyncConfigDTO

export type OrganizationRequestRequestBody = OrganizationRequest

export type EnvironmentRequestDTORequestBody = EnvironmentRequestDTO

export type MergeInputSetRequestRequestBody = MergeInputSetRequest

export type ProjectRequestRequestBody = ProjectRequest

export type SecretTextDTORequestBody = void

export type NGTriggerConfigRequestBody = NGTriggerConfig

export type OverlayInputSetConfigRequestBody = OverlayInputSetConfig

export type NgPipelineRequestBody = NgPipeline

export type ConnectorListFilterRequestBody = ConnectorListFilter

export type ConnectorRequestBody = Connector

export type SecretTextDTO2RequestBody = SecretTextDTO

export type SecretRequestWrapperRequestBody = SecretRequestWrapper

export type SecretRequestWrapper2RequestBody = void

export type ServiceRequestDTORequestBody = ServiceRequestDTO

export type InputSetConfigRequestBody = InputSetConfig

export interface GetStepsQueryParams {
  serviceDefinitionType: 'Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf'
}

export type GetStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>, 'path'>

/**
 * get steps for given service definition type
 */
export const GetSteps = (props: GetStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>
    path="/pipelines/configuration/steps"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepsProps = Omit<
  UseGetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  'path'
>

/**
 * get steps for given service definition type
 */
export const useGetSteps = (props: UseGetStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(`/pipelines/configuration/steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get steps for given service definition type
 */
export const getStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/steps`,
    props,
    signal
  )

export type GetExecutionStrategyListProps = Omit<
  GetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const GetExecutionStrategyList = (props: GetExecutionStrategyListProps) => (
  <Get<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>
    path="/pipelines/configuration/strategies"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyListProps = Omit<
  UseGetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const useGetExecutionStrategyList = (props: UseGetExecutionStrategyListProps) =>
  useGet<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    `/pipelines/configuration/strategies`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Execution Strategy list
 */
export const getExecutionStrategyListPromise = (
  props: GetUsingFetchProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies`,
    props,
    signal
  )

export interface GetExecutionStrategyYamlQueryParams {
  serviceDefinitionType: 'Ssh' | 'Kubernetes' | 'Ecs' | 'Helm' | 'Pcf'
  strategyType: 'Basic' | 'Canary' | 'BlueGreen' | 'Rolling'
}

export type GetExecutionStrategyYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const GetExecutionStrategyYaml = (props: GetExecutionStrategyYamlProps) => (
  <Get<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>
    path="/pipelines/configuration/strategies/yaml-snippets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const useGetExecutionStrategyYaml = (props: UseGetExecutionStrategyYamlProps) =>
  useGet<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    `/pipelines/configuration/strategies/yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const getExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/yaml-snippets`,
    props,
    signal
  )

export type GetServiceDefinitionTypesProps = Omit<
  GetProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const GetServiceDefinitionTypes = (props: GetServiceDefinitionTypesProps) => (
  <Get<ResponseListServiceDefinitionType, Failure | Error, void, void>
    path="/pipelines/configuration/serviceDefinitionTypes"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDefinitionTypesProps = Omit<
  UseGetProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const useGetServiceDefinitionTypes = (props: UseGetServiceDefinitionTypesProps) =>
  useGet<ResponseListServiceDefinitionType, Failure | Error, void, void>(
    `/pipelines/configuration/serviceDefinitionTypes`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Git list of service definition types
 */
export const getServiceDefinitionTypesPromise = (
  props: GetUsingFetchProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceDefinitionType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/serviceDefinitionTypes`,
    props,
    signal
  )

export interface ValidatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
}

export type ValidatePipelineProps = Omit<
  GetProps<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>,
  'path'
>

/**
 * Validate a Pipeline
 */
export const ValidatePipeline = (props: ValidatePipelineProps) => (
  <Get<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>
    path="/pipelines/execute/validate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidatePipelineProps = Omit<
  UseGetProps<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>,
  'path'
>

/**
 * Validate a Pipeline
 */
export const useValidatePipeline = (props: UseValidatePipelineProps) =>
  useGet<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>(
    `/pipelines/execute/validate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate a Pipeline
 */
export const validatePipelinePromise = (
  props: GetUsingFetchProps<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGPipelineValidationInfo, Failure | Error, ValidatePipelineQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/execute/validate`,
    props,
    signal
  )

export interface PostPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetYamlPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const PostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path="/pipelines/execute/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const usePostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetYamlPathParams) => `/pipelines/execute/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const postPipelineExecuteWithInputSetYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    NgPipelineRequestBody,
    PostPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('ng/api'), `/pipelines/execute/${identifier}`, props, signal)

export interface PostPipelineExecuteWithInputSetListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  useFQNIfError?: boolean
}

export interface PostPipelineExecuteWithInputSetListPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetListProps = Omit<
  MutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const PostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetListProps) => (
  <Mutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >
    verb="POST"
    path="/pipelines/execute/${identifier}/inputSetList"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetListProps = Omit<
  UseMutateProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const usePostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetListProps) =>
  useMutate<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetListPathParams) =>
      `/pipelines/execute/${paramsInPath.identifier}/inputSetList`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with input set references list
 */
export const postPipelineExecuteWithInputSetListPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGPipelineExecutionResponse,
    Failure | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >('POST', getConfig('ng/api'), `/pipelines/execute/${identifier}/inputSetList`, props, signal)

export interface GetConnectorFilterQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetConnectorFilterPathParams {
  identifier: string
}

export type GetConnectorFilterProps = Omit<
  GetProps<ResponseConnectorListFilter, Failure | Error, GetConnectorFilterQueryParams, GetConnectorFilterPathParams>,
  'path'
> &
  GetConnectorFilterPathParams

/**
 * Get Connector Filter
 */
export const GetConnectorFilter = ({ identifier, ...props }: GetConnectorFilterProps) => (
  <Get<ResponseConnectorListFilter, Failure | Error, GetConnectorFilterQueryParams, GetConnectorFilterPathParams>
    path="/connectorFilters/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorFilterProps = Omit<
  UseGetProps<
    ResponseConnectorListFilter,
    Failure | Error,
    GetConnectorFilterQueryParams,
    GetConnectorFilterPathParams
  >,
  'path'
> &
  GetConnectorFilterPathParams

/**
 * Get Connector Filter
 */
export const useGetConnectorFilter = ({ identifier, ...props }: UseGetConnectorFilterProps) =>
  useGet<ResponseConnectorListFilter, Failure | Error, GetConnectorFilterQueryParams, GetConnectorFilterPathParams>(
    (paramsInPath: GetConnectorFilterPathParams) => `/connectorFilters/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Connector Filter
 */
export const getConnectorFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseConnectorListFilter,
    Failure | Error,
    GetConnectorFilterQueryParams,
    GetConnectorFilterPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseConnectorListFilter,
    Failure | Error,
    GetConnectorFilterQueryParams,
    GetConnectorFilterPathParams
  >(getConfig('ng/api'), `/connectorFilters/${identifier}`, props, signal)

export interface DeleteConnectorFilterQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteConnectorFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteConnectorFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector filter
 */
export const DeleteConnectorFilter = (props: DeleteConnectorFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteConnectorFilterQueryParams, string, void>
    verb="DELETE"
    path="/connectorFilters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteConnectorFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteConnectorFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector filter
 */
export const useDeleteConnectorFilter = (props: UseDeleteConnectorFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteConnectorFilterQueryParams, string, void>(
    'DELETE',
    `/connectorFilters`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a connector filter
 */
export const deleteConnectorFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteConnectorFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteConnectorFilterQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/connectorFilters`,
    props,
    signal
  )

export interface GetConnectorFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetConnectorFilterListProps = Omit<
  GetProps<ResponsePageConnectorListFilter, Failure | Error, GetConnectorFilterListQueryParams, void>,
  'path'
>

/**
 * Get Connector Filter
 */
export const GetConnectorFilterList = (props: GetConnectorFilterListProps) => (
  <Get<ResponsePageConnectorListFilter, Failure | Error, GetConnectorFilterListQueryParams, void>
    path="/connectorFilters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorFilterListProps = Omit<
  UseGetProps<ResponsePageConnectorListFilter, Failure | Error, GetConnectorFilterListQueryParams, void>,
  'path'
>

/**
 * Get Connector Filter
 */
export const useGetConnectorFilterList = (props: UseGetConnectorFilterListProps) =>
  useGet<ResponsePageConnectorListFilter, Failure | Error, GetConnectorFilterListQueryParams, void>(
    `/connectorFilters`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Connector Filter
 */
export const getConnectorFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageConnectorListFilter, Failure | Error, GetConnectorFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageConnectorListFilter, Failure | Error, GetConnectorFilterListQueryParams, void>(
    getConfig('ng/api'),
    `/connectorFilters`,
    props,
    signal
  )

export interface PostConnectorFilterQueryParams {
  accountIdentifier?: string
}

export type PostConnectorFilterProps = Omit<
  MutateProps<
    ResponseConnectorListFilter,
    Failure | Error,
    PostConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Connector Filter
 */
export const PostConnectorFilter = (props: PostConnectorFilterProps) => (
  <Mutate<
    ResponseConnectorListFilter,
    Failure | Error,
    PostConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >
    verb="POST"
    path="/connectorFilters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostConnectorFilterProps = Omit<
  UseMutateProps<
    ResponseConnectorListFilter,
    Failure | Error,
    PostConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Connector Filter
 */
export const usePostConnectorFilter = (props: UsePostConnectorFilterProps) =>
  useMutate<
    ResponseConnectorListFilter,
    Failure | Error,
    PostConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >('POST', `/connectorFilters`, { base: getConfig('ng/api'), ...props })

/**
 * Creates a Connector Filter
 */
export const postConnectorFilterPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorListFilter,
    Failure | Error,
    PostConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorListFilter,
    Failure | Error,
    PostConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >('POST', getConfig('ng/api'), `/connectorFilters`, props, signal)

export interface UpdateConnectorFilterQueryParams {
  accountIdentifier?: string
}

export type UpdateConnectorFilterProps = Omit<
  MutateProps<
    ResponseConnectorListFilter,
    Failure | Error,
    UpdateConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a Connector Filter
 */
export const UpdateConnectorFilter = (props: UpdateConnectorFilterProps) => (
  <Mutate<
    ResponseConnectorListFilter,
    Failure | Error,
    UpdateConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >
    verb="PUT"
    path="/connectorFilters"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateConnectorFilterProps = Omit<
  UseMutateProps<
    ResponseConnectorListFilter,
    Failure | Error,
    UpdateConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a Connector Filter
 */
export const useUpdateConnectorFilter = (props: UseUpdateConnectorFilterProps) =>
  useMutate<
    ResponseConnectorListFilter,
    Failure | Error,
    UpdateConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >('PUT', `/connectorFilters`, { base: getConfig('ng/api'), ...props })

/**
 * Updates a Connector Filter
 */
export const updateConnectorFilterPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorListFilter,
    Failure | Error,
    UpdateConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorListFilter,
    Failure | Error,
    UpdateConnectorFilterQueryParams,
    ConnectorListFilterRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/connectorFilters`, props, signal)

export interface GetConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetConnectorPathParams {
  identifier: string
}

export type GetConnectorProps = Omit<
  GetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const GetConnector = ({ identifier, ...props }: GetConnectorProps) => (
  <Get<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>
    path="/connectors/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorProps = Omit<
  UseGetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const useGetConnector = ({ identifier, ...props }: UseGetConnectorProps) =>
  useGet<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    (paramsInPath: GetConnectorPathParams) => `/connectors/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Connector
 */
export const getConnectorPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    getConfig('ng/api'),
    `/connectors/${identifier}`,
    props,
    signal
  )

export interface DeleteConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteConnectorProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const DeleteConnector = (props: DeleteConnectorProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>
    verb="DELETE"
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteConnectorProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const useDeleteConnector = (props: UseDeleteConnectorProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>('DELETE', `/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a connector by identifier
 */
export const deleteConnectorPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CONNECTOR'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
}

export type GetConnectorListProps = Omit<
  GetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const GetConnectorList = (props: GetConnectorListProps) => (
  <Get<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListProps = Omit<
  UseGetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const useGetConnectorList = (props: UseGetConnectorListProps) =>
  useGet<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(`/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Connector list
 */
export const getConnectorListPromise = (
  props: GetUsingFetchProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface CreateConnectorQueryParams {
  accountIdentifier?: string
}

export type CreateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const CreateConnector = (props: CreateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>
    verb="POST"
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const useCreateConnector = (props: UseCreateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates a Connector
 */
export const createConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface UpdateConnectorQueryParams {
  accountIdentifier?: string
}

export type UpdateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const UpdateConnector = (props: UpdateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>
    verb="PUT"
    path="/connectors"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const useUpdateConnector = (props: UseUpdateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Updates a Connector
 */
export const updateConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorListV2QueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
}

export type GetConnectorListV2Props = Omit<
  MutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const GetConnectorListV2 = (props: GetConnectorListV2Props) => (
  <Mutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorListFilterRequestBody,
    void
  >
    verb="POST"
    path="/connectors/listV2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListV2Props = Omit<
  UseMutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const useGetConnectorListV2 = (props: UseGetConnectorListV2Props) =>
  useMutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorListFilterRequestBody,
    void
  >('POST', `/connectors/listV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Connector list
 */
export const getConnectorListV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorListFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorListFilterRequestBody,
    void
  >('POST', getConfig('ng/api'), `/connectors/listV2`, props, signal)

export interface GetConnectorCatalogueQueryParams {
  accountIdentifier?: string
}

export type GetConnectorCatalogueProps = Omit<
  GetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const GetConnectorCatalogue = (props: GetConnectorCatalogueProps) => (
  <Get<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>
    path="/connectors/catalogue"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorCatalogueProps = Omit<
  UseGetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const useGetConnectorCatalogue = (props: UseGetConnectorCatalogueProps) =>
  useGet<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    `/connectors/catalogue`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Connector Catalogue
 */
export const getConnectorCataloguePromise = (
  props: GetUsingFetchProps<
    ResponseConnectorCatalogueResponse,
    Failure | Error,
    GetConnectorCatalogueQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/catalogue`,
    props,
    signal
  )

export interface GetConnectorStatusQueryParams {
  accountIdentifier?: string
}

export type GetConnectorStatusProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get the connectivity status of the Connector
 */
export const GetConnectorStatus = (props: GetConnectorStatusProps) => (
  <Mutate<ResponseConnectorValidationResult, Failure | Error, GetConnectorStatusQueryParams, ConnectorRequestBody, void>
    verb="POST"
    path="/connectors/validate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorStatusProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get the connectivity status of the Connector
 */
export const useGetConnectorStatus = (props: UseGetConnectorStatusProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >('POST', `/connectors/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Get the connectivity status of the Connector
 */
export const getConnectorStatusPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetConnectorStatusQueryParams,
    ConnectorRequestBody,
    void
  >('POST', getConfig('ng/api'), `/connectors/validate`, props, signal)

export interface GetTestGitRepoConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoURL?: string
}

export interface GetTestGitRepoConnectionResultPathParams {
  identifier: string
}

export type GetTestGitRepoConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestGitRepoConnectionResult = ({ identifier, ...props }: GetTestGitRepoConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >
    verb="POST"
    path="/connectors/testGitRepoConnection/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestGitRepoConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestGitRepoConnectionResult = ({ identifier, ...props }: UseGetTestGitRepoConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestGitRepoConnectionResultPathParams) =>
      `/connectors/testGitRepoConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestGitRepoConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testGitRepoConnection/${identifier}`, props, signal)

export interface ValidateTheIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateTheIdentifierIsUniqueProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateTheIdentifierIsUnique = (props: ValidateTheIdentifierIsUniqueProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>
    path="/connectors/validateUniqueIdentifier"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateTheIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateTheIdentifierIsUnique = (props: UseValidateTheIdentifierIsUniqueProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    `/connectors/validateUniqueIdentifier`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateTheIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/validateUniqueIdentifier`,
    props,
    signal
  )

export interface GetTestConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetTestConnectionResultPathParams {
  identifier: string
}

export type GetTestConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestConnectionResult = ({ identifier, ...props }: GetTestConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >
    verb="POST"
    path="/connectors/testConnection/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestConnectionResult = ({ identifier, ...props }: UseGetTestConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestConnectionResultPathParams) => `/connectors/testConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testConnection/${identifier}`, props, signal)

export interface GetConnectorStatisticsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  scope?: 'account' | 'org' | 'project'
}

export type GetConnectorStatisticsProps = Omit<
  GetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const GetConnectorStatistics = (props: GetConnectorStatisticsProps) => (
  <Get<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>
    path="/connectors/stats"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorStatisticsProps = Omit<
  UseGetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const useGetConnectorStatistics = (props: UseGetConnectorStatisticsProps) =>
  useGet<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(`/connectors/stats`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Connectors statistics
 */
export const getConnectorStatisticsPromise = (
  props: GetUsingFetchProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/stats`,
    props,
    signal
  )

export interface ListGitSyncEntitiesByProductQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
  size?: number
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
}

export type ListGitSyncEntitiesByProductProps = Omit<
  GetProps<ResponseGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>,
  'path'
>

/**
 * List Git Sync Entity by product
 */
export const ListGitSyncEntitiesByProduct = (props: ListGitSyncEntitiesByProductProps) => (
  <Get<ResponseGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>
    path="/git-sync-entities"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesByProductProps = Omit<
  UseGetProps<ResponseGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>,
  'path'
>

/**
 * List Git Sync Entity by product
 */
export const useListGitSyncEntitiesByProduct = (props: UseListGitSyncEntitiesByProductProps) =>
  useGet<ResponseGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>(`/git-sync-entities`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List Git Sync Entity by product
 */
export const listGitSyncEntitiesByProductPromise = (
  props: GetUsingFetchProps<ResponseGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitSyncProductDTO, unknown, ListGitSyncEntitiesByProductQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-entities`,
    props,
    signal
  )

export interface ListGitSyncEntitiesByTypeQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
  page?: number
  size?: number
  moduleType?: string
}

export interface ListGitSyncEntitiesByTypePathParams {
  entityType: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets'
}

export type ListGitSyncEntitiesByTypeProps = Omit<
  GetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const ListGitSyncEntitiesByType = ({ entityType, ...props }: ListGitSyncEntitiesByTypeProps) => (
  <Get<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >
    path="/git-sync-entities/entities/${entityType}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesByTypeProps = Omit<
  UseGetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const useListGitSyncEntitiesByType = ({ entityType, ...props }: UseListGitSyncEntitiesByTypeProps) =>
  useGet<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >((paramsInPath: ListGitSyncEntitiesByTypePathParams) => `/git-sync-entities/entities/${paramsInPath.entityType}`, {
    base: getConfig('ng/api'),
    pathParams: { entityType },
    ...props
  })

/**
 * Get Git Sync Entity By Type
 */
export const listGitSyncEntitiesByTypePromise = (
  {
    entityType,
    ...props
  }: GetUsingFetchProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  > & { entityType: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets' },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >(getConfig('ng/api'), `/git-sync-entities/entities/${entityType}`, props, signal)

export interface PutGitSyncDefaultQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncDefaultPathParams {
  identifier: string
  folderIdentifier: string
}

export type PutGitSyncDefaultProps = Omit<
  MutateProps<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const PutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: PutGitSyncDefaultProps) => (
  <Mutate<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>
    verb="PUT"
    path="/git-sync/${identifier}/folder/${folderIdentifier}/default"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncDefaultProps = Omit<
  UseMutateProps<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const usePutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: UsePutGitSyncDefaultProps) =>
  useMutate<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    (paramsInPath: PutGitSyncDefaultPathParams) =>
      `/git-sync/${paramsInPath.identifier}/folder/${paramsInPath.folderIdentifier}/default`,
    { base: getConfig('ng/api'), pathParams: { identifier, folderIdentifier }, ...props }
  )

/**
 * Update Git Sync default by id
 */
export const putGitSyncDefaultPromise = (
  {
    identifier,
    folderIdentifier,
    ...props
  }: MutateUsingFetchProps<
    GitSyncConfigDTO[],
    unknown,
    PutGitSyncDefaultQueryParams,
    void,
    PutGitSyncDefaultPathParams
  > & { identifier: string; folderIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync/${identifier}/folder/${folderIdentifier}/default`,
    props,
    signal
  )

export interface PutGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncPathParams {
  identifier: string
}

export type PutGitSyncProps = Omit<
  MutateProps<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>,
  'path' | 'verb'
> &
  PutGitSyncPathParams

/**
 * Update Git Sync by id
 */
export const PutGitSync = ({ identifier, ...props }: PutGitSyncProps) => (
  <Mutate<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>
    verb="PUT"
    path="/git-sync/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncProps = Omit<
  UseMutateProps<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>,
  'path' | 'verb'
> &
  PutGitSyncPathParams

/**
 * Update Git Sync by id
 */
export const usePutGitSync = ({ identifier, ...props }: UsePutGitSyncProps) =>
  useMutate<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>(
    'PUT',
    (paramsInPath: PutGitSyncPathParams) => `/git-sync/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update Git Sync by id
 */
export const putGitSyncPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    GitSyncConfigDTO,
    unknown,
    PutGitSyncQueryParams,
    GitSyncConfigDTORequestBody,
    PutGitSyncPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync/${identifier}`,
    props,
    signal
  )

export interface ListGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export type ListGitSyncProps = Omit<GetProps<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const ListGitSync = (props: ListGitSyncProps) => (
  <Get<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>
    path="/git-sync"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncProps = Omit<UseGetProps<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const useListGitSync = (props: UseListGitSyncProps) =>
  useGet<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>(`/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List Git Sync
 */
export const listGitSyncPromise = (
  props: GetUsingFetchProps<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface PostGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export type PostGitSyncProps = Omit<
  MutateProps<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const PostGitSync = (props: PostGitSyncProps) => (
  <Mutate<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>
    verb="POST"
    path="/git-sync"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostGitSyncProps = Omit<
  UseMutateProps<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const usePostGitSync = (props: UsePostGitSyncProps) =>
  useMutate<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>('POST', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Git Sync
 */
export const postGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface ListActivitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  status?: 'SUCCESS' | 'FAILED'
}

export type ListActivitiesProps = Omit<GetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>, 'path'>

/**
 * Get Activities where this resource was used
 */
export const ListActivities = (props: ListActivitiesProps) => (
  <Get<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>
    path="/activityHistory"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListActivitiesProps = Omit<
  UseGetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  'path'
>

/**
 * Get Activities where this resource was used
 */
export const useListActivities = (props: UseListActivitiesProps) =>
  useGet<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(`/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities where this resource was used
 */
export const listActivitiesPromise = (
  props: GetUsingFetchProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export type PostActivityProps = Omit<MutateProps<ResponseActivity, unknown, void, Activity, void>, 'path' | 'verb'>

/**
 * Saves the activity
 */
export const PostActivity = (props: PostActivityProps) => (
  <Mutate<ResponseActivity, unknown, void, Activity, void>
    verb="POST"
    path="/activityHistory"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostActivityProps = Omit<
  UseMutateProps<ResponseActivity, unknown, void, Activity, void>,
  'path' | 'verb'
>

/**
 * Saves the activity
 */
export const usePostActivity = (props: UsePostActivityProps) =>
  useMutate<ResponseActivity, unknown, void, Activity, void>('POST', `/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Saves the activity
 */
export const postActivityPromise = (
  props: MutateUsingFetchProps<ResponseActivity, unknown, void, Activity, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseActivity, unknown, void, Activity, void>(
    'POST',
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export interface GetConnectivitySummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
}

export type GetConnectivitySummaryProps = Omit<
  GetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const GetConnectivitySummary = (props: GetConnectivitySummaryProps) => (
  <Get<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>
    path="/activityHistory/connectivityCheckSummary"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectivitySummaryProps = Omit<
  UseGetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const useGetConnectivitySummary = (props: UseGetConnectivitySummaryProps) =>
  useGet<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    `/activityHistory/connectivityCheckSummary`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ConnectivityCheck Summary
 */
export const getConnectivitySummaryPromise = (
  props: GetUsingFetchProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/connectivityCheckSummary`,
    props,
    signal
  )

export interface GetActivitiesSummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  timeGroupType: 'DAY' | 'HOUR'
}

export type GetActivitiesSummaryProps = Omit<
  GetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const GetActivitiesSummary = (props: GetActivitiesSummaryProps) => (
  <Get<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>
    path="/activityHistory/summary"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActivitiesSummaryProps = Omit<
  UseGetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const useGetActivitiesSummary = (props: UseGetActivitiesSummaryProps) =>
  useGet<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(`/activityHistory/summary`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities Summary
 */
export const getActivitiesSummaryPromise = (
  props: GetUsingFetchProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/summary`,
    props,
    signal
  )

export interface GetLastSuccessfulBuildForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForDockerProps = Omit<
  MutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const GetLastSuccessfulBuildForDocker = (props: GetLastSuccessfulBuildForDockerProps) => (
  <Mutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >
    verb="POST"
    path="/artifacts/docker/getLastSuccessfulBuild"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const useGetLastSuccessfulBuildForDocker = (props: UseGetLastSuccessfulBuildForDockerProps) =>
  useMutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker last successful build
 */
export const getLastSuccessfulBuildForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLastSuccessfulBuild`, props, signal)

export interface ValidateArtifactImageForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactImageForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const ValidateArtifactImageForDocker = (props: ValidateArtifactImageForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>
    path="/artifacts/docker/validateArtifactSource"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const useValidateArtifactImageForDocker = (props: UseValidateArtifactImageForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker image
 */
export const validateArtifactImageForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactSource`,
    props,
    signal
  )

export interface GetLabelsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLabelsForDockerProps = Omit<
  MutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const GetLabelsForDocker = (props: GetLabelsForDockerProps) => (
  <Mutate<ResponseDockerResponseDTO, Failure | Error, GetLabelsForDockerQueryParams, DockerRequestDTORequestBody, void>
    verb="POST"
    path="/artifacts/docker/getLabels"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLabelsForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const useGetLabelsForDocker = (props: UseGetLabelsForDockerProps) =>
  useMutate<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLabels`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker labels
 */
export const getLabelsForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLabels`, props, signal)

export interface GetBuildDetailsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetBuildDetailsForDockerProps = Omit<
  GetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const GetBuildDetailsForDocker = (props: GetBuildDetailsForDockerProps) => (
  <Get<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>
    path="/artifacts/docker/getBuildDetails"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForDockerProps = Omit<
  UseGetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const useGetBuildDetailsForDocker = (props: UseGetBuildDetailsForDockerProps) =>
  useGet<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    `/artifacts/docker/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker build details
 */
export const getBuildDetailsForDockerPromise = (
  props: GetUsingFetchProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/getBuildDetails`,
    props,
    signal
  )

export interface ValidateArtifactServerForDockerQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactServerForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const ValidateArtifactServerForDocker = (props: ValidateArtifactServerForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>
    path="/artifacts/docker/validateArtifactServer"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const useValidateArtifactServerForDocker = (props: UseValidateArtifactServerForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact server
 */
export const validateArtifactServerForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactServer`,
    props,
    signal
  )

export interface SyncTaskD2QueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SyncTaskD2Props = Omit<
  MutateProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync task using Delegate 2.0 framework
 */
export const SyncTaskD2 = (props: SyncTaskD2Props) => (
  <Mutate<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>
    verb="POST"
    path="/delegate2-tasks/sync"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncTaskD2Props = Omit<
  UseMutateProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync task using Delegate 2.0 framework
 */
export const useSyncTaskD2 = (props: UseSyncTaskD2Props) =>
  useMutate<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>('POST', `/delegate2-tasks/sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync task using Delegate 2.0 framework
 */
export const syncTaskD2Promise = (
  props: MutateUsingFetchProps<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<DelegateResponseData, unknown, SyncTaskD2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate2-tasks/sync`,
    props,
    signal
  )

export interface AsyncTaskD2QueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type AsyncTaskD2Props = Omit<MutateProps<string, unknown, AsyncTaskD2QueryParams, void, void>, 'path' | 'verb'>

/**
 * Create a delegate tasks
 */
export const AsyncTaskD2 = (props: AsyncTaskD2Props) => (
  <Mutate<string, unknown, AsyncTaskD2QueryParams, void, void>
    verb="POST"
    path="/delegate2-tasks/async"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAsyncTaskD2Props = Omit<
  UseMutateProps<string, unknown, AsyncTaskD2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a delegate tasks
 */
export const useAsyncTaskD2 = (props: UseAsyncTaskD2Props) =>
  useMutate<string, unknown, AsyncTaskD2QueryParams, void, void>('POST', `/delegate2-tasks/async`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a delegate tasks
 */
export const asyncTaskD2Promise = (
  props: MutateUsingFetchProps<string, unknown, AsyncTaskD2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<string, unknown, AsyncTaskD2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate2-tasks/async`,
    props,
    signal
  )

export interface ListAllEntityUsageQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  referredEntityFQN?: string
  searchTerm?: string
}

export type ListAllEntityUsageProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const ListAllEntityUsage = (props: ListAllEntityUsageProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageQueryParams, void>
    path="/entitySetupUsage/internal"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAllEntityUsageProps = Omit<
  UseGetProps<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const useListAllEntityUsage = (props: UseListAllEntityUsageProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageQueryParams, void>(`/entitySetupUsage/internal`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Entities referring this resource
 */
export const listAllEntityUsagePromise = (
  props: GetUsingFetchProps<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageQueryParams, void>(
    getConfig('ng/api'),
    `/entitySetupUsage/internal`,
    props,
    signal
  )

export type PostEntitySetupUsageProps = Omit<
  MutateProps<ResponseEntitySetupUsageDTO, unknown, void, EntitySetupUsageDTO, void>,
  'path' | 'verb'
>

/**
 * Saves the entity reference
 */
export const PostEntitySetupUsage = (props: PostEntitySetupUsageProps) => (
  <Mutate<ResponseEntitySetupUsageDTO, unknown, void, EntitySetupUsageDTO, void>
    verb="POST"
    path="/entitySetupUsage/internal"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostEntitySetupUsageProps = Omit<
  UseMutateProps<ResponseEntitySetupUsageDTO, unknown, void, EntitySetupUsageDTO, void>,
  'path' | 'verb'
>

/**
 * Saves the entity reference
 */
export const usePostEntitySetupUsage = (props: UsePostEntitySetupUsageProps) =>
  useMutate<ResponseEntitySetupUsageDTO, unknown, void, EntitySetupUsageDTO, void>(
    'POST',
    `/entitySetupUsage/internal`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Saves the entity reference
 */
export const postEntitySetupUsagePromise = (
  props: MutateUsingFetchProps<ResponseEntitySetupUsageDTO, unknown, void, EntitySetupUsageDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseEntitySetupUsageDTO, unknown, void, EntitySetupUsageDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/entitySetupUsage/internal`,
    props,
    signal
  )

export interface DeleteEntitySetupUsageQueryParams {
  accountIdentifier?: string
  referredEntityFQN?: string
  referredByEntityFQN?: string
}

export type DeleteEntitySetupUsageProps = Omit<
  MutateProps<ResponseBoolean, unknown, DeleteEntitySetupUsageQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Deletes the entity reference record
 */
export const DeleteEntitySetupUsage = (props: DeleteEntitySetupUsageProps) => (
  <Mutate<ResponseBoolean, unknown, DeleteEntitySetupUsageQueryParams, void, void>
    verb="DELETE"
    path="/entitySetupUsage/internal"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEntitySetupUsageProps = Omit<
  UseMutateProps<ResponseBoolean, unknown, DeleteEntitySetupUsageQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Deletes the entity reference record
 */
export const useDeleteEntitySetupUsage = (props: UseDeleteEntitySetupUsageProps) =>
  useMutate<ResponseBoolean, unknown, DeleteEntitySetupUsageQueryParams, void, void>(
    'DELETE',
    `/entitySetupUsage/internal`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes the entity reference record
 */
export const deleteEntitySetupUsagePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, unknown, DeleteEntitySetupUsageQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, unknown, DeleteEntitySetupUsageQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/entitySetupUsage/internal`,
    props,
    signal
  )

export interface ListReferredByEntitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  searchTerm?: string
}

export type ListReferredByEntitiesProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const ListReferredByEntities = (props: ListReferredByEntitiesProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>
    path="/entitySetupUsage"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListReferredByEntitiesProps = Omit<
  UseGetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const useListReferredByEntities = (props: UseListReferredByEntitiesProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(`/entitySetupUsage`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Entities referring this resource
 */
export const listReferredByEntitiesPromise = (
  props: GetUsingFetchProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(
    getConfig('ng/api'),
    `/entitySetupUsage`,
    props,
    signal
  )

export interface DeleteAllReferredByEntityRecordsQueryParams {
  accountIdentifier?: string
  referredByEntityFQN?: string
}

export type DeleteAllReferredByEntityRecordsProps = Omit<
  MutateProps<ResponseBoolean, unknown, DeleteAllReferredByEntityRecordsQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Deletes the entity reference records for referredByEntity
 */
export const DeleteAllReferredByEntityRecords = (props: DeleteAllReferredByEntityRecordsProps) => (
  <Mutate<ResponseBoolean, unknown, DeleteAllReferredByEntityRecordsQueryParams, void, void>
    verb="DELETE"
    path="/entitySetupUsage/internal/deleteAllReferredByRecords"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteAllReferredByEntityRecordsProps = Omit<
  UseMutateProps<ResponseBoolean, unknown, DeleteAllReferredByEntityRecordsQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Deletes the entity reference records for referredByEntity
 */
export const useDeleteAllReferredByEntityRecords = (props: UseDeleteAllReferredByEntityRecordsProps) =>
  useMutate<ResponseBoolean, unknown, DeleteAllReferredByEntityRecordsQueryParams, void, void>(
    'DELETE',
    `/entitySetupUsage/internal/deleteAllReferredByRecords`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes the entity reference records for referredByEntity
 */
export const deleteAllReferredByEntityRecordsPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, unknown, DeleteAllReferredByEntityRecordsQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, unknown, DeleteAllReferredByEntityRecordsQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/entitySetupUsage/internal/deleteAllReferredByRecords`,
    props,
    signal
  )

export interface IsEntityReferencedQueryParams {
  accountIdentifier?: string
  referredEntityFQN?: string
}

export type IsEntityReferencedProps = Omit<
  GetProps<ResponseBoolean, unknown, IsEntityReferencedQueryParams, void>,
  'path'
>

/**
 * Returns true if the entity is referenced by other resource
 */
export const IsEntityReferenced = (props: IsEntityReferencedProps) => (
  <Get<ResponseBoolean, unknown, IsEntityReferencedQueryParams, void>
    path="/entitySetupUsage/internal/isEntityReferenced"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsEntityReferencedProps = Omit<
  UseGetProps<ResponseBoolean, unknown, IsEntityReferencedQueryParams, void>,
  'path'
>

/**
 * Returns true if the entity is referenced by other resource
 */
export const useIsEntityReferenced = (props: UseIsEntityReferencedProps) =>
  useGet<ResponseBoolean, unknown, IsEntityReferencedQueryParams, void>(
    `/entitySetupUsage/internal/isEntityReferenced`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Returns true if the entity is referenced by other resource
 */
export const isEntityReferencedPromise = (
  props: GetUsingFetchProps<ResponseBoolean, unknown, IsEntityReferencedQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, unknown, IsEntityReferencedQueryParams, void>(
    getConfig('ng/api'),
    `/entitySetupUsage/internal/isEntityReferenced`,
    props,
    signal
  )

export interface GetEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetEnvironmentPathParams {
  environmentIdentifier: string
}

export type GetEnvironmentProps = Omit<
  GetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironment = ({ environmentIdentifier, ...props }: GetEnvironmentProps) => (
  <Get<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>
    path="/environments/${environmentIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentProps = Omit<
  UseGetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironment = ({ environmentIdentifier, ...props }: UseGetEnvironmentProps) =>
  useGet<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    (paramsInPath: GetEnvironmentPathParams) => `/environments/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentPromise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    getConfig('ng/api'),
    `/environments/${environmentIdentifier}`,
    props,
    signal
  )

export interface DeleteEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteEnvironmentProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironment = (props: DeleteEnvironmentProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>
    verb="DELETE"
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironment = (props: UseDeleteEnvironmentProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>('DELETE', `/environments`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface GetEnvironmentListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  sort?: string[]
}

export type GetEnvironmentListForProjectProps = Omit<
  GetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const GetEnvironmentListForProject = (props: GetEnvironmentListForProjectProps) => (
  <Get<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListForProjectProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const useGetEnvironmentListForProject = (props: UseGetEnvironmentListForProjectProps) =>
  useGet<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    `/environments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets environment list for a project
 */
export const getEnvironmentListForProjectPromise = (
  props: GetUsingFetchProps<
    ResponsePageEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentListForProjectQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface CreateEnvironmentQueryParams {
  accountId?: string
}

export type CreateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironment = (props: CreateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironment = (props: UseCreateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environments`, props, signal)

export interface UpdateEnvironmentQueryParams {
  accountId?: string
}

export type UpdateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironment = (props: UpdateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path="/environments"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironment = (props: UseUpdateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments`, props, signal)

export interface UpsertEnvironmentQueryParams {
  accountId?: string
}

export type UpsertEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironment = (props: UpsertEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path="/environments/upsert"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironment = (props: UseUpsertEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments/upsert`, props, signal)

export interface UpdateInviteQueryParams {
  accountIdentifier?: string
}

export interface UpdateInvitePathParams {
  inviteId: string
}

export type UpdateInviteProps = Omit<
  MutateProps<ResponseOptionalInviteDTO, Failure | Error, UpdateInviteQueryParams, InviteDTO, UpdateInvitePathParams>,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const UpdateInvite = ({ inviteId, ...props }: UpdateInviteProps) => (
  <Mutate<ResponseOptionalInviteDTO, Failure | Error, UpdateInviteQueryParams, InviteDTO, UpdateInvitePathParams>
    verb="PUT"
    path="/invites/${inviteId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInviteProps = Omit<
  UseMutateProps<
    ResponseOptionalInviteDTO,
    Failure | Error,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  >,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const useUpdateInvite = ({ inviteId, ...props }: UseUpdateInviteProps) =>
  useMutate<ResponseOptionalInviteDTO, Failure | Error, UpdateInviteQueryParams, InviteDTO, UpdateInvitePathParams>(
    'PUT',
    (paramsInPath: UpdateInvitePathParams) => `/invites/${paramsInPath.inviteId}`,
    { base: getConfig('ng/api'), pathParams: { inviteId }, ...props }
  )

/**
 * Resend invite mail
 */
export const updateInvitePromise = (
  {
    inviteId,
    ...props
  }: MutateUsingFetchProps<
    ResponseOptionalInviteDTO,
    Failure | Error,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  > & { inviteId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOptionalInviteDTO,
    Failure | Error,
    UpdateInviteQueryParams,
    InviteDTO,
    UpdateInvitePathParams
  >('PUT', getConfig('ng/api'), `/invites/${inviteId}`, props, signal)

export interface DeleteInviteQueryParams {
  accountIdentifier?: string
}

export type DeleteInviteProps = Omit<
  MutateProps<ResponseOptionalInviteDTO, Failure | Error, DeleteInviteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const DeleteInvite = (props: DeleteInviteProps) => (
  <Mutate<ResponseOptionalInviteDTO, Failure | Error, DeleteInviteQueryParams, string, void>
    verb="DELETE"
    path="/invites"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInviteProps = Omit<
  UseMutateProps<ResponseOptionalInviteDTO, Failure | Error, DeleteInviteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const useDeleteInvite = (props: UseDeleteInviteProps) =>
  useMutate<ResponseOptionalInviteDTO, Failure | Error, DeleteInviteQueryParams, string, void>('DELETE', `/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a invite for the specified project/organization
 */
export const deleteInvitePromise = (
  props: MutateUsingFetchProps<ResponseOptionalInviteDTO, Failure | Error, DeleteInviteQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOptionalInviteDTO, Failure | Error, DeleteInviteQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface VerifyInviteQueryParams {
  token: string
  accountIdentifier?: string
}

export type VerifyInviteProps = Omit<GetProps<void, Failure | Error, VerifyInviteQueryParams, void>, 'path'>

/**
 * Verify user invite
 */
export const VerifyInvite = (props: VerifyInviteProps) => (
  <Get<void, Failure | Error, VerifyInviteQueryParams, void>
    path="/invites/verify"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseVerifyInviteProps = Omit<UseGetProps<void, Failure | Error, VerifyInviteQueryParams, void>, 'path'>

/**
 * Verify user invite
 */
export const useVerifyInvite = (props: UseVerifyInviteProps) =>
  useGet<void, Failure | Error, VerifyInviteQueryParams, void>(`/invites/verify`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Verify user invite
 */
export const verifyInvitePromise = (
  props: GetUsingFetchProps<void, Failure | Error, VerifyInviteQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, Failure | Error, VerifyInviteQueryParams, void>(
    getConfig('ng/api'),
    `/invites/verify`,
    props,
    signal
  )

export interface GetInvitesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetInvitesProps = Omit<
  GetProps<ResponsePageInviteDTO, Failure | Error, GetInvitesQueryParams, void>,
  'path'
>

/**
 * Get all invites for the queried project/organization
 */
export const GetInvites = (props: GetInvitesProps) => (
  <Get<ResponsePageInviteDTO, Failure | Error, GetInvitesQueryParams, void>
    path="/invites"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInvitesProps = Omit<
  UseGetProps<ResponsePageInviteDTO, Failure | Error, GetInvitesQueryParams, void>,
  'path'
>

/**
 * Get all invites for the queried project/organization
 */
export const useGetInvites = (props: UseGetInvitesProps) =>
  useGet<ResponsePageInviteDTO, Failure | Error, GetInvitesQueryParams, void>(`/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all invites for the queried project/organization
 */
export const getInvitesPromise = (
  props: GetUsingFetchProps<ResponsePageInviteDTO, Failure | Error, GetInvitesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInviteDTO, Failure | Error, GetInvitesQueryParams, void>(
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface SendInviteQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier?: string
}

export type SendInviteProps = Omit<
  MutateProps<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInviteListDTO, void>,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project/organization
 */
export const SendInvite = (props: SendInviteProps) => (
  <Mutate<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInviteListDTO, void>
    verb="POST"
    path="/invites"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSendInviteProps = Omit<
  UseMutateProps<
    ResponseListInviteOperationResponse,
    Failure | Error,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project/organization
 */
export const useSendInvite = (props: UseSendInviteProps) =>
  useMutate<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInviteListDTO, void>(
    'POST',
    `/invites`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Add a new invite for the specified project/organization
 */
export const sendInvitePromise = (
  props: MutateUsingFetchProps<
    ResponseListInviteOperationResponse,
    Failure | Error,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListInviteOperationResponse,
    Failure | Error,
    SendInviteQueryParams,
    CreateInviteListDTO,
    void
  >('POST', getConfig('ng/api'), `/invites`, props, signal)

export interface GetRolesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier?: string
}

export type GetRolesProps = Omit<
  GetProps<ResponseOptionalListRoleDTO, Failure | Error, GetRolesQueryParams, void>,
  'path'
>

/**
 * Get all roles for the queried project
 */
export const GetRoles = (props: GetRolesProps) => (
  <Get<ResponseOptionalListRoleDTO, Failure | Error, GetRolesQueryParams, void>
    path="/roles"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRolesProps = Omit<
  UseGetProps<ResponseOptionalListRoleDTO, Failure | Error, GetRolesQueryParams, void>,
  'path'
>

/**
 * Get all roles for the queried project
 */
export const useGetRoles = (props: UseGetRolesProps) =>
  useGet<ResponseOptionalListRoleDTO, Failure | Error, GetRolesQueryParams, void>(`/roles`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all roles for the queried project
 */
export const getRolesPromise = (
  props: GetUsingFetchProps<ResponseOptionalListRoleDTO, Failure | Error, GetRolesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOptionalListRoleDTO, Failure | Error, GetRolesQueryParams, void>(
    getConfig('ng/api'),
    `/roles`,
    props,
    signal
  )

export interface GetProjectAggregateDTOQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectAggregateDTOPathParams {
  identifier: string
}

export type GetProjectAggregateDTOProps = Omit<
  GetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const GetProjectAggregateDTO = ({ identifier, ...props }: GetProjectAggregateDTOProps) => (
  <Get<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >
    path="/aggregate/projects/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOProps = Omit<
  UseGetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const useGetProjectAggregateDTO = ({ identifier, ...props }: UseGetProjectAggregateDTOProps) =>
  useGet<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >((paramsInPath: GetProjectAggregateDTOPathParams) => `/aggregate/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const getProjectAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/projects/${identifier}`, props, signal)

export interface GetOrganizationAggregateDTOQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationAggregateDTOPathParams {
  identifier: string
}

export type GetOrganizationAggregateDTOProps = Omit<
  GetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const GetOrganizationAggregateDTO = ({ identifier, ...props }: GetOrganizationAggregateDTOProps) => (
  <Get<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >
    path="/aggregate/organizations/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOProps = Omit<
  UseGetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const useGetOrganizationAggregateDTO = ({ identifier, ...props }: UseGetOrganizationAggregateDTOProps) =>
  useGet<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >((paramsInPath: GetOrganizationAggregateDTOPathParams) => `/aggregate/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const getOrganizationAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/organizations/${identifier}`, props, signal)

export interface GetOrganizationAggregateDTOListQueryParams {
  accountIdentifier: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetOrganizationAggregateDTOListProps = Omit<
  GetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const GetOrganizationAggregateDTOList = (props: GetOrganizationAggregateDTOListProps) => (
  <Get<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>
    path="/aggregate/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const useGetOrganizationAggregateDTOList = (props: UseGetOrganizationAggregateDTOListProps) =>
  useGet<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>(
    `/aggregate/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get OrganizationAggregateDTO list
 */
export const getOrganizationAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >(getConfig('ng/api'), `/aggregate/organizations`, props, signal)

export interface GetProjectAggregateDTOListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetProjectAggregateDTOListProps = Omit<
  GetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const GetProjectAggregateDTOList = (props: GetProjectAggregateDTOListProps) => (
  <Get<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>
    path="/aggregate/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const useGetProjectAggregateDTOList = (props: UseGetProjectAggregateDTOListProps) =>
  useGet<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    `/aggregate/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ProjectAggregateDTO list
 */
export const getProjectAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/projects`,
    props,
    signal
  )

export interface PutSecretFilePathParams {
  identifier: string
}

export type PutSecretFileProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>,
  'path' | 'verb'
> &
  PutSecretFilePathParams

/**
 * Update a secret file
 */
export const PutSecretFile = ({ identifier, ...props }: PutSecretFileProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>
    verb="PUT"
    path="/secrets/files/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>,
  'path' | 'verb'
> &
  PutSecretFilePathParams

/**
 * Update a secret file
 */
export const usePutSecretFile = ({ identifier, ...props }: UsePutSecretFileProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>(
    'PUT',
    (paramsInPath: PutSecretFilePathParams) => `/secrets/files/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret file
 */
export const putSecretFilePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, void, PutSecretFilePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/files/${identifier}`,
    props,
    signal
  )

export interface PutSecretFileViaYamlPathParams {
  identifier: string
}

export type PutSecretFileViaYamlProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretFileViaYamlPathParams

/**
 * Update a secret file via yaml
 */
export const PutSecretFileViaYaml = ({ identifier, ...props }: PutSecretFileViaYamlProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>
    verb="PUT"
    path="/secrets/files/${identifier}/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileViaYamlProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretFileViaYamlPathParams

/**
 * Update a secret file via yaml
 */
export const usePutSecretFileViaYaml = ({ identifier, ...props }: UsePutSecretFileViaYamlProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>(
    'PUT',
    (paramsInPath: PutSecretFileViaYamlPathParams) => `/secrets/files/${paramsInPath.identifier}/yaml`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret file via yaml
 */
export const putSecretFileViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    void,
    SecretFileDTORequestBody,
    PutSecretFileViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, SecretFileDTORequestBody, PutSecretFileViaYamlPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/files/${identifier}/yaml`,
    props,
    signal
  )

export type PostSecretFileViaYamlProps = Omit<
  MutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret file via yaml
 */
export const PostSecretFileViaYaml = (props: PostSecretFileViaYamlProps) => (
  <Mutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>
    verb="POST"
    path="/secrets/files/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileViaYamlProps = Omit<
  UseMutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret file via yaml
 */
export const usePostSecretFileViaYaml = (props: UsePostSecretFileViaYamlProps) =>
  useMutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>(
    'POST',
    `/secrets/files/yaml`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret file via yaml
 */
export const postSecretFileViaYamlPromise = (
  props: MutateUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseEncryptedDataDTO, Failure | Error, void, SecretFileDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets/files/yaml`,
    props,
    signal
  )

export interface GetMetadataQueryParams {
  accountIdentifier: string
}

export type GetMetadataProps = Omit<
  MutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const GetMetadata = (props: GetMetadataProps) => (
  <Mutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >
    verb="POST"
    path="/secret-managers/meta-data"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMetadataProps = Omit<
  UseMutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const useGetMetadata = (props: UseGetMetadataProps) =>
  useMutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', `/secret-managers/meta-data`, { base: getConfig('ng/api'), ...props })

/**
 * Get metadata of secret manager
 */
export const getMetadataPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/secret-managers/meta-data`, props, signal)

export interface GetSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretPathParams {
  identifier: string
}

export type GetSecretProps = Omit<
  GetProps<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>,
  'path'
> &
  GetSecretPathParams

/**
 * Gets secret
 */
export const GetSecret = ({ identifier, ...props }: GetSecretProps) => (
  <Get<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>
    path="/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretProps = Omit<
  UseGetProps<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>,
  'path'
> &
  GetSecretPathParams

/**
 * Gets secret
 */
export const useGetSecret = ({ identifier, ...props }: UseGetSecretProps) =>
  useGet<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>(
    (paramsInPath: GetSecretPathParams) => `/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEncryptedDataDTO, Failure | Error, GetSecretQueryParams, GetSecretPathParams>(
    getConfig('ng/api'),
    `/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretTextPathParams {
  identifier: string
}

export type PutSecretTextProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>,
  'path' | 'verb'
> &
  PutSecretTextPathParams

/**
 * Update a secret text
 */
export const PutSecretText = ({ identifier, ...props }: PutSecretTextProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>
    verb="PUT"
    path="/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretTextProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>,
  'path' | 'verb'
> &
  PutSecretTextPathParams

/**
 * Update a secret text
 */
export const usePutSecretText = ({ identifier, ...props }: UsePutSecretTextProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>(
    'PUT',
    (paramsInPath: PutSecretTextPathParams) => `/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret text
 */
export const putSecretTextPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    void,
    SecretTextDTO2RequestBody,
    PutSecretTextPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, SecretTextDTO2RequestBody, PutSecretTextPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/${identifier}`,
    props,
    signal
  )

export interface DeleteSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const DeleteSecret = (props: DeleteSecretProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>
    verb="DELETE"
    path="/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const useDeleteSecret = (props: UseDeleteSecretProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>('DELETE', `/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a secret text
 */
export const deleteSecretPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSecretQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export interface ListSecretsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
}

export type ListSecretsProps = Omit<
  GetProps<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const ListSecrets = (props: ListSecretsProps) => (
  <Get<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>
    path="/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsProps = Omit<
  UseGetProps<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const useListSecrets = (props: UseListSecretsProps) =>
  useGet<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>(`/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get secrets for an account
 */
export const listSecretsPromise = (
  props: GetUsingFetchProps<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEncryptedDataDTO, Failure | Error, ListSecretsQueryParams, void>(
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export type PostSecretTextProps = Omit<
  MutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const PostSecretText = (props: PostSecretTextProps) => (
  <Mutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>
    verb="POST"
    path="/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretTextProps = Omit<
  UseMutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const usePostSecretText = (props: UsePostSecretTextProps) =>
  useMutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>('POST', `/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a secret text
 */
export const postSecretTextPromise = (
  props: MutateUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTO2RequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets`,
    props,
    signal
  )

export interface PutSecretTextViaYamlPathParams {
  identifier: string
}

export type PutSecretTextViaYamlProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretTextViaYamlPathParams

/**
 * Update a secret text via yaml
 */
export const PutSecretTextViaYaml = ({ identifier, ...props }: PutSecretTextViaYamlProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>
    verb="PUT"
    path="/secrets/${identifier}/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretTextViaYamlProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>,
  'path' | 'verb'
> &
  PutSecretTextViaYamlPathParams

/**
 * Update a secret text via yaml
 */
export const usePutSecretTextViaYaml = ({ identifier, ...props }: UsePutSecretTextViaYamlProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>(
    'PUT',
    (paramsInPath: PutSecretTextViaYamlPathParams) => `/secrets/${paramsInPath.identifier}/yaml`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update a secret text via yaml
 */
export const putSecretTextViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    void,
    SecretTextDTORequestBody,
    PutSecretTextViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, SecretTextDTORequestBody, PutSecretTextViaYamlPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/secrets/${identifier}/yaml`,
    props,
    signal
  )

export type PostSecretTextViaYamlProps = Omit<
  MutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text via yaml
 */
export const PostSecretTextViaYaml = (props: PostSecretTextViaYamlProps) => (
  <Mutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>
    verb="POST"
    path="/secrets/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretTextViaYamlProps = Omit<
  UseMutateProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text via yaml
 */
export const usePostSecretTextViaYaml = (props: UsePostSecretTextViaYamlProps) =>
  useMutate<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>('POST', `/secrets/yaml`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a secret text via yaml
 */
export const postSecretTextViaYamlPromise = (
  props: MutateUsingFetchProps<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseEncryptedDataDTO, Failure | Error, void, SecretTextDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/secrets/yaml`,
    props,
    signal
  )

export interface GetSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretV2PathParams {
  identifier: string
}

export type GetSecretV2Props = Omit<
  GetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const GetSecretV2 = ({ identifier, ...props }: GetSecretV2Props) => (
  <Get<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>
    path="/v2/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretV2Props = Omit<
  UseGetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const useGetSecretV2 = ({ identifier, ...props }: UseGetSecretV2Props) =>
  useGet<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    (paramsInPath: GetSecretV2PathParams) => `/v2/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretV2Promise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    GetSecretV2QueryParams,
    GetSecretV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    getConfig('ng/api'),
    `/v2/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretQueryParams {
  accountIdentifier: string
}

export interface PutSecretPathParams {
  identifier: string
}

export type PutSecretProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const PutSecret = ({ identifier, ...props }: PutSecretProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >
    verb="PUT"
    path="/v2/secrets/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const usePutSecret = ({ identifier, ...props }: UsePutSecretProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', (paramsInPath: PutSecretPathParams) => `/v2/secrets/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret
 */
export const putSecretPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}`, props, signal)

export interface DeleteSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const DeleteSecretV2 = (props: DeleteSecretV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>
    verb="DELETE"
    path="/v2/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const useDeleteSecretV2 = (props: UseDeleteSecretV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>('DELETE', `/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete secret
 */
export const deleteSecretV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface ListSecretsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
}

export type ListSecretsV2Props = Omit<
  GetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const ListSecretsV2 = (props: ListSecretsV2Props) => (
  <Get<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>
    path="/v2/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsV2Props = Omit<
  UseGetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const useListSecretsV2 = (props: UseListSecretsV2Props) =>
  useGet<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(`/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get secrets
 */
export const listSecretsV2Promise = (
  props: GetUsingFetchProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface PostSecretQueryParams {
  accountIdentifier: string
}

export type PostSecretProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const PostSecret = (props: PostSecretProps) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapperRequestBody, void>
    verb="POST"
    path="/v2/secrets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const usePostSecret = (props: UsePostSecretProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', `/v2/secrets`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret
 */
export const postSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets`, props, signal)

export interface PutSecretViaYamlQueryParams {
  accountIdentifier: string
}

export interface PutSecretViaYamlPathParams {
  identifier: string
}

export type PutSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const PutSecretViaYaml = ({ identifier, ...props }: PutSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >
    verb="PUT"
    path="/v2/secrets/${identifier}/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const usePutSecretViaYaml = ({ identifier, ...props }: UsePutSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', (paramsInPath: PutSecretViaYamlPathParams) => `/v2/secrets/${paramsInPath.identifier}/yaml`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret via yaml
 */
export const putSecretViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}/yaml`, props, signal)

export interface PutSecretFileV2QueryParams {
  accountIdentifier: string
}

export interface PutSecretFileV2PathParams {
  identifier: string
}

export type PutSecretFileV2Props = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const PutSecretFileV2 = ({ identifier, ...props }: PutSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PutSecretFileV2QueryParams, void, PutSecretFileV2PathParams>
    verb="PUT"
    path="/v2/secrets/files/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileV2Props = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const usePutSecretFileV2 = ({ identifier, ...props }: UsePutSecretFileV2Props) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', (paramsInPath: PutSecretFileV2PathParams) => `/v2/secrets/files/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret file
 */
export const putSecretFileV2Promise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/files/${identifier}`, props, signal)

export interface PostSecretFileV2QueryParams {
  accountIdentifier: string
}

export type PostSecretFileV2Props = Omit<
  MutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const PostSecretFileV2 = (props: PostSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>
    verb="POST"
    path="/v2/secrets/files"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileV2Props = Omit<
  UseMutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const usePostSecretFileV2 = (props: UsePostSecretFileV2Props) =>
  useMutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    `/v2/secrets/files`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret file
 */
export const postSecretFileV2Promise = (
  props: MutateUsingFetchProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/v2/secrets/files`,
    props,
    signal
  )

export interface ValidateSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateSecretProps = Omit<
  MutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const ValidateSecret = (props: ValidateSecretProps) => (
  <Mutate<ResponseSecretValidationResultDTO, Failure | Error, ValidateSecretQueryParams, SecretValidationMetaData, void>
    verb="POST"
    path="/v2/secrets/validate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretProps = Omit<
  UseMutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const useValidateSecret = (props: UseValidateSecretProps) =>
  useMutate<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', `/v2/secrets/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Validate a secret
 */
export const validateSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/validate`, props, signal)

export interface PostSecretViaYamlQueryParams {
  accountIdentifier: string
}

export type PostSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const PostSecretViaYaml = (props: PostSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >
    verb="POST"
    path="/v2/secrets/yaml"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const usePostSecretViaYaml = (props: UsePostSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', `/v2/secrets/yaml`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret via yaml
 */
export const postSecretViaYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/yaml`, props, signal)

export interface GetOrganizationQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationPathParams {
  identifier: string
}

export type GetOrganizationProps = Omit<
  GetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const GetOrganization = ({ identifier, ...props }: GetOrganizationProps) => (
  <Get<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>
    path="/organizations/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationProps = Omit<
  UseGetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const useGetOrganization = ({ identifier, ...props }: UseGetOrganizationProps) =>
  useGet<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    (paramsInPath: GetOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get an Organization by identifier
 */
export const getOrganizationPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    GetOrganizationQueryParams,
    GetOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    getConfig('ng/api'),
    `/organizations/${identifier}`,
    props,
    signal
  )

export interface PutOrganizationQueryParams {
  accountIdentifier: string
}

export interface PutOrganizationPathParams {
  identifier: string
}

export type PutOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by identifier
 */
export const PutOrganization = ({ identifier, ...props }: PutOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >
    verb="PUT"
    path="/organizations/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by identifier
 */
export const usePutOrganization = ({ identifier, ...props }: UsePutOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', (paramsInPath: PutOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update an Organization by identifier
 */
export const putOrganizationPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', getConfig('ng/api'), `/organizations/${identifier}`, props, signal)

export interface DeleteOrganizationQueryParams {
  accountIdentifier: string
}

export type DeleteOrganizationProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const DeleteOrganization = (props: DeleteOrganizationProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>
    verb="DELETE"
    path="/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteOrganizationProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const useDeleteOrganization = (props: UseDeleteOrganizationProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>('DELETE', `/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete an Organization by identifier
 */
export const deleteOrganizationPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface GetOrganizationListQueryParams {
  accountIdentifier: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetOrganizationListProps = Omit<
  GetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const GetOrganizationList = (props: GetOrganizationListProps) => (
  <Get<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>
    path="/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationListProps = Omit<
  UseGetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const useGetOrganizationList = (props: UseGetOrganizationListProps) =>
  useGet<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(`/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Organization list
 */
export const getOrganizationListPromise = (
  props: GetUsingFetchProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface PostOrganizationQueryParams {
  accountIdentifier: string
}

export type PostOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const PostOrganization = (props: PostOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >
    verb="POST"
    path="/organizations"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const usePostOrganization = (props: UsePostOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', `/organizations`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Organization
 */
export const postOrganizationPromise = (
  props: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/organizations`, props, signal)

export interface GetProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectPathParams {
  identifier: string
}

export type GetProjectProps = Omit<
  GetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const GetProject = ({ identifier, ...props }: GetProjectProps) => (
  <Get<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>
    path="/projects/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectProps = Omit<
  UseGetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const useGetProject = ({ identifier, ...props }: UseGetProjectProps) =>
  useGet<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    (paramsInPath: GetProjectPathParams) => `/projects/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets a Project by identifier
 */
export const getProjectPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    getConfig('ng/api'),
    `/projects/${identifier}`,
    props,
    signal
  )

export interface PutProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface PutProjectPathParams {
  identifier: string
}

export type PutProjectProps = Omit<
  MutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const PutProject = ({ identifier, ...props }: PutProjectProps) => (
  <Mutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >
    verb="PUT"
    path="/projects/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutProjectProps = Omit<
  UseMutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const usePutProject = ({ identifier, ...props }: UsePutProjectProps) =>
  useMutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', (paramsInPath: PutProjectPathParams) => `/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a project by identifier
 */
export const putProjectPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', getConfig('ng/api'), `/projects/${identifier}`, props, signal)

export interface DeleteProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type DeleteProjectProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a project by identifier
 */
export const DeleteProject = (props: DeleteProjectProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>
    verb="DELETE"
    path="/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteProjectProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a project by identifier
 */
export const useDeleteProject = (props: UseDeleteProjectProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>('DELETE', `/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a project by identifier
 */
export const deleteProjectPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetProjectListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  moduleType?: 'CD' | 'CI' | 'CORE' | 'CV' | 'CF' | 'CE'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetProjectListProps = Omit<
  GetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const GetProjectList = (props: GetProjectListProps) => (
  <Get<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>
    path="/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectListProps = Omit<
  UseGetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const useGetProjectList = (props: UseGetProjectListProps) =>
  useGet<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(`/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Project list
 */
export const getProjectListPromise = (
  props: GetUsingFetchProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface PostProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type PostProjectProps = Omit<
  MutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const PostProject = (props: PostProjectProps) => (
  <Mutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>
    verb="POST"
    path="/projects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostProjectProps = Omit<
  UseMutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const usePostProject = (props: UsePostProjectProps) =>
  useMutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    `/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Project
 */
export const postProjectPromise = (
  props: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PostProjectQueryParams,
    ProjectRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetUserGroupListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUserGroupListProps = Omit<
  GetProps<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const GetUserGroupList = (props: GetUserGroupListProps) => (
  <Get<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>
    path="/user-groups"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupListProps = Omit<
  UseGetProps<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const useGetUserGroupList = (props: UseGetUserGroupListProps) =>
  useGet<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>(`/user-groups`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get User Group List
 */
export const getUserGroupListPromise = (
  props: GetUsingFetchProps<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserGroupDTO, Failure | Error, GetUserGroupListQueryParams, void>(
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export interface PostUserGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostUserGroupProps = Omit<
  MutateProps<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTO, void>,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const PostUserGroup = (props: PostUserGroupProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTO, void>
    verb="POST"
    path="/user-groups"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostUserGroupProps = Omit<
  UseMutateProps<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTO, void>,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const usePostUserGroup = (props: UsePostUserGroupProps) =>
  useMutate<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTO, void>(
    'POST',
    `/user-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a User Group
 */
export const postUserGroupPromise = (
  props: MutateUsingFetchProps<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserGroupDTO, Failure | Error, PostUserGroupQueryParams, UserGroupDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export type GetBatchUserGroupListProps = Omit<
  MutateProps<ResponseListUserGroupDTO, Failure | Error, void, string[], void>,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const GetBatchUserGroupList = (props: GetBatchUserGroupListProps) => (
  <Mutate<ResponseListUserGroupDTO, Failure | Error, void, string[], void>
    verb="POST"
    path="/user-groups/batch"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBatchUserGroupListProps = Omit<
  UseMutateProps<ResponseListUserGroupDTO, Failure | Error, void, string[], void>,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const useGetBatchUserGroupList = (props: UseGetBatchUserGroupListProps) =>
  useMutate<ResponseListUserGroupDTO, Failure | Error, void, string[], void>('POST', `/user-groups/batch`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Batch User Group List
 */
export const getBatchUserGroupListPromise = (
  props: MutateUsingFetchProps<ResponseListUserGroupDTO, Failure | Error, void, string[], void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListUserGroupDTO, Failure | Error, void, string[], void>(
    'POST',
    getConfig('ng/api'),
    `/user-groups/batch`,
    props,
    signal
  )

export interface SchemafileQueryParams {
  filename?: string
}

export type SchemafileProps = Omit<GetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const Schemafile = (props: SchemafileProps) => (
  <Get<void, void, SchemafileQueryParams, void> path="/yamlschema/schemafile" base={getConfig('ng/api')} {...props} />
)

export type UseSchemafileProps = Omit<UseGetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const useSchemafile = (props: UseSchemafileProps) =>
  useGet<void, void, SchemafileQueryParams, void>(`/yamlschema/schemafile`, { base: getConfig('ng/api'), ...props })

/**
 * Get Schema for the given entity type
 */
export const schemafilePromise = (
  props: GetUsingFetchProps<void, void, SchemafileQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, SchemafileQueryParams, void>(getConfig('ng/api'), `/yamlschema/schemafile`, props, signal)

export interface GetServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetServicePathParams {
  serviceIdentifier: string
}

export type GetServiceProps = Omit<
  GetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const GetService = ({ serviceIdentifier, ...props }: GetServiceProps) => (
  <Get<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>
    path="/services/${serviceIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceProps = Omit<
  UseGetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const useGetService = ({ serviceIdentifier, ...props }: UseGetServiceProps) =>
  useGet<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    (paramsInPath: GetServicePathParams) => `/services/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServicePromise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams> & {
    serviceIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    getConfig('ng/api'),
    `/services/${serviceIdentifier}`,
    props,
    signal
  )

export interface DeleteServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteService = (props: DeleteServiceProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>
    verb="DELETE"
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteService = (props: UseDeleteServiceProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>('DELETE', `/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServicePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface GetServiceListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  sort?: string[]
}

export type GetServiceListForProjectProps = Omit<
  GetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const GetServiceListForProject = (props: GetServiceListForProjectProps) => (
  <Get<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListForProjectProps = Omit<
  UseGetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const useGetServiceListForProject = (props: UseGetServiceListForProjectProps) =>
  useGet<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(`/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Service list for a project
 */
export const getServiceListForProjectPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface CreateServiceQueryParams {
  accountId?: string
}

export type CreateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateService = (props: CreateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="POST"
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateService = (props: UseCreateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'POST',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Service
 */
export const createServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/services`, props, signal)

export interface UpdateServiceQueryParams {
  accountId?: string
}

export type UpdateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateService = (props: UpdateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path="/services"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateService = (props: UseUpdateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a service by identifier
 */
export const updateServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services`, props, signal)

export interface UpsertServiceQueryParams {
  accountId?: string
}

export type UpsertServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertService = (props: UpsertServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path="/services/upsert"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertService = (props: UseUpsertServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services/upsert`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Upsert a service by identifier
 */
export const upsertServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services/upsert`, props, signal)

export interface CreateServicesQueryParams {
  accountId?: string
}

export type CreateServicesProps = Omit<
  MutateProps<ResponsePageServiceResponseDTO, Failure | Error, CreateServicesQueryParams, ServiceRequestDTO[], void>,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const CreateServices = (props: CreateServicesProps) => (
  <Mutate<ResponsePageServiceResponseDTO, Failure | Error, CreateServicesQueryParams, ServiceRequestDTO[], void>
    verb="POST"
    path="/services/batch"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServicesProps = Omit<
  UseMutateProps<ResponsePageServiceResponseDTO, Failure | Error, CreateServicesQueryParams, ServiceRequestDTO[], void>,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const useCreateServices = (props: UseCreateServicesProps) =>
  useMutate<ResponsePageServiceResponseDTO, Failure | Error, CreateServicesQueryParams, ServiceRequestDTO[], void>(
    'POST',
    `/services/batch`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create Services
 */
export const createServicesPromise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTO[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTO[],
    void
  >('POST', getConfig('ng/api'), `/services/batch`, props, signal)

export interface GetUsersQueryParams {
  accountIdentifier: string
  searchString?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUsersProps = Omit<
  GetProps<ResponsePageUserSearchDTO, Failure | Error, GetUsersQueryParams, void>,
  'path'
>

/**
 * Get users for an account
 */
export const GetUsers = (props: GetUsersProps) => (
  <Get<ResponsePageUserSearchDTO, Failure | Error, GetUsersQueryParams, void>
    path="/users"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersProps = Omit<
  UseGetProps<ResponsePageUserSearchDTO, Failure | Error, GetUsersQueryParams, void>,
  'path'
>

/**
 * Get users for an account
 */
export const useGetUsers = (props: UseGetUsersProps) =>
  useGet<ResponsePageUserSearchDTO, Failure | Error, GetUsersQueryParams, void>(`/users`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get users for an account
 */
export const getUsersPromise = (
  props: GetUsingFetchProps<ResponsePageUserSearchDTO, Failure | Error, GetUsersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserSearchDTO, Failure | Error, GetUsersQueryParams, void>(
    getConfig('ng/api'),
    `/users`,
    props,
    signal
  )

export type GetDummyCDStageModuleInfoProps = Omit<
  GetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDStageModuleInfo = (props: GetDummyCDStageModuleInfoProps) => (
  <Get<ResponseCDStageModuleInfo, Failure | Error, void, void>
    path="/executions/dummyCDStageModuleInfo"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDStageModuleInfoProps = Omit<
  UseGetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDStageModuleInfo = (props: UseGetDummyCDStageModuleInfoProps) =>
  useGet<ResponseCDStageModuleInfo, Failure | Error, void, void>(`/executions/dummyCDStageModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDStageModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDStageModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDStageModuleInfo`,
    props,
    signal
  )

export type GetDummyCDPipelineModuleInfoProps = Omit<
  GetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDPipelineModuleInfo = (props: GetDummyCDPipelineModuleInfoProps) => (
  <Get<ResponseCDPipelineModuleInfo, Failure | Error, void, void>
    path="/executions/dummyCDPipelineModuleInfo"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDPipelineModuleInfoProps = Omit<
  UseGetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDPipelineModuleInfo = (props: UseGetDummyCDPipelineModuleInfoProps) =>
  useGet<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(`/executions/dummyCDPipelineModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDPipelineModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDPipelineModuleInfo`,
    props,
    signal
  )

export interface GetPipelineExecutionDetailQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageIdentifier?: string
}

export interface GetPipelineExecutionDetailPathParams {
  planExecutionId: string
}

export type GetPipelineExecutionDetailProps = Omit<
  GetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >,
  'path'
> &
  GetPipelineExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const GetPipelineExecutionDetail = ({ planExecutionId, ...props }: GetPipelineExecutionDetailProps) => (
  <Get<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >
    path="/executions/${planExecutionId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineExecutionDetailProps = Omit<
  UseGetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >,
  'path'
> &
  GetPipelineExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const useGetPipelineExecutionDetail = ({ planExecutionId, ...props }: UseGetPipelineExecutionDetailProps) =>
  useGet<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >((paramsInPath: GetPipelineExecutionDetailPathParams) => `/executions/${paramsInPath.planExecutionId}`, {
    base: getConfig('ng/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Gets Execution Detail
 */
export const getPipelineExecutionDetailPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetPipelineExecutionDetailQueryParams,
    GetPipelineExecutionDetailPathParams
  >(getConfig('ng/api'), `/executions/${planExecutionId}`, props, signal)

export type GetExecutionStatusesProps = Omit<GetProps<ResponseListExecutionStatus, Failure | Error, void, void>, 'path'>

/**
 * Gets Execution Status list
 */
export const GetExecutionStatuses = (props: GetExecutionStatusesProps) => (
  <Get<ResponseListExecutionStatus, Failure | Error, void, void>
    path="/executions/executionStatus"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStatusesProps = Omit<
  UseGetProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Status list
 */
export const useGetExecutionStatuses = (props: UseGetExecutionStatusesProps) =>
  useGet<ResponseListExecutionStatus, Failure | Error, void, void>(`/executions/executionStatus`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Execution Status list
 */
export const getExecutionStatusesPromise = (
  props: GetUsingFetchProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListExecutionStatus, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/executionStatus`,
    props,
    signal
  )

export interface GetStepTypesToYamlTypeMappingQueryParams {
  executionNodeType?:
    | 'SERVICE'
    | 'MANIFEST_FETCH'
    | 'PIPELINE_SETUP'
    | 'INFRASTRUCTURE_SECTION'
    | 'INFRASTRUCTURE'
    | 'DEPLOYMENT_STAGE_STEP'
    | 'K8S_ROLLING'
    | 'K8S_ROLLBACK_ROLLING'
    | 'K8S_BLUE_GREEN'
    | 'K8S_APPLY'
    | 'ROLLBACK_SECTION'
    | 'GENERIC_SECTION'
    | 'HTTP'
}

export type GetStepTypesToYamlTypeMappingProps = Omit<
  GetProps<ResponseMapExecutionNodeTypeString, Failure | Error, GetStepTypesToYamlTypeMappingQueryParams, void>,
  'path'
>

/**
 * Gets Step Types to Yaml Type Mapping
 */
export const GetStepTypesToYamlTypeMapping = (props: GetStepTypesToYamlTypeMappingProps) => (
  <Get<ResponseMapExecutionNodeTypeString, Failure | Error, GetStepTypesToYamlTypeMappingQueryParams, void>
    path="/executions/step-types"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepTypesToYamlTypeMappingProps = Omit<
  UseGetProps<ResponseMapExecutionNodeTypeString, Failure | Error, GetStepTypesToYamlTypeMappingQueryParams, void>,
  'path'
>

/**
 * Gets Step Types to Yaml Type Mapping
 */
export const useGetStepTypesToYamlTypeMapping = (props: UseGetStepTypesToYamlTypeMappingProps) =>
  useGet<ResponseMapExecutionNodeTypeString, Failure | Error, GetStepTypesToYamlTypeMappingQueryParams, void>(
    `/executions/step-types`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Step Types to Yaml Type Mapping
 */
export const getStepTypesToYamlTypeMappingPromise = (
  props: GetUsingFetchProps<
    ResponseMapExecutionNodeTypeString,
    Failure | Error,
    GetStepTypesToYamlTypeMappingQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapExecutionNodeTypeString, Failure | Error, GetStepTypesToYamlTypeMappingQueryParams, void>(
    getConfig('ng/api'),
    `/executions/step-types`,
    props,
    signal
  )

export interface HandleInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType: 'Abort' | 'Pause' | 'Resume'
}

export interface HandleInterruptPathParams {
  planExecutionId: string
}

export type HandleInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const HandleInterrupt = ({ planExecutionId, ...props }: HandleInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >
    verb="PUT"
    path="/executions/interrupt/${planExecutionId}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHandleInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * pause, resume or stop the pipeline executions
 */
export const useHandleInterrupt = ({ planExecutionId, ...props }: UseHandleInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', (paramsInPath: HandleInterruptPathParams) => `/executions/interrupt/${paramsInPath.planExecutionId}`, {
    base: getConfig('ng/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * pause, resume or stop the pipeline executions
 */
export const handleInterruptPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', getConfig('ng/api'), `/executions/interrupt/${planExecutionId}`, props, signal)

export interface GetListOfExecutionsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
  serviceIdentifiers?: string[]
  envIdentifiers?: string[]
  pipelineIdentifiers?: string[]
  executionStatuses?: (
    | 'Running'
    | 'Failed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Queued'
    | 'Paused'
    | 'Waiting'
    | 'Success'
    | 'Suspended'
  )[]
  startTime?: number
  endTime?: number
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetListOfExecutionsProps = Omit<
  GetProps<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>,
  'path'
>

/**
 * Gets Executions list
 */
export const GetListOfExecutions = (props: GetListOfExecutionsProps) => (
  <Get<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>
    path="/executions"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfExecutionsProps = Omit<
  UseGetProps<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>,
  'path'
>

/**
 * Gets Executions list
 */
export const useGetListOfExecutions = (props: UseGetListOfExecutionsProps) =>
  useGet<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>(
    `/executions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Executions list
 */
export const getListOfExecutionsPromise = (
  props: GetUsingFetchProps<
    ResponsePagePipelineExecutionSummaryDTO,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePagePipelineExecutionSummaryDTO, Failure | Error, GetListOfExecutionsQueryParams, void>(
    getConfig('ng/api'),
    `/executions`,
    props,
    signal
  )

export interface GetJiraProjectsQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetJiraProjectsProps = Omit<
  GetProps<ResponseJiraProjectResponse, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const GetJiraProjects = (props: GetJiraProjectsProps) => (
  <Get<ResponseJiraProjectResponse, Failure | Error, GetJiraProjectsQueryParams, void>
    path="/jira/getProjects"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraProjectsProps = Omit<
  UseGetProps<ResponseJiraProjectResponse, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const useGetJiraProjects = (props: UseGetJiraProjectsProps) =>
  useGet<ResponseJiraProjectResponse, Failure | Error, GetJiraProjectsQueryParams, void>(`/jira/getProjects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira projects
 */
export const getJiraProjectsPromise = (
  props: GetUsingFetchProps<ResponseJiraProjectResponse, Failure | Error, GetJiraProjectsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraProjectResponse, Failure | Error, GetJiraProjectsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/getProjects`,
    props,
    signal
  )

export interface ValidateJiraCredentialsQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateJiraCredentialsProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const ValidateJiraCredentials = (props: ValidateJiraCredentialsProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>
    path="/jira/validate"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateJiraCredentialsProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const useValidateJiraCredentials = (props: UseValidateJiraCredentialsProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(`/jira/validate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Validate jira credentials
 */
export const validateJiraCredentialsPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/validate`,
    props,
    signal
  )

export interface CreateJiraTicketQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateJiraTicketProps = Omit<
  MutateProps<ResponseString, Failure | Error, CreateJiraTicketQueryParams, CreateJiraTicketRequest, void>,
  'path' | 'verb'
>

/**
 * Create jira ticket
 */
export const CreateJiraTicket = (props: CreateJiraTicketProps) => (
  <Mutate<ResponseString, Failure | Error, CreateJiraTicketQueryParams, CreateJiraTicketRequest, void>
    verb="POST"
    path="/jira/createTicket"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateJiraTicketProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, CreateJiraTicketQueryParams, CreateJiraTicketRequest, void>,
  'path' | 'verb'
>

/**
 * Create jira ticket
 */
export const useCreateJiraTicket = (props: UseCreateJiraTicketProps) =>
  useMutate<ResponseString, Failure | Error, CreateJiraTicketQueryParams, CreateJiraTicketRequest, void>(
    'POST',
    `/jira/createTicket`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create jira ticket
 */
export const createJiraTicketPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    CreateJiraTicketQueryParams,
    CreateJiraTicketRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, CreateJiraTicketQueryParams, CreateJiraTicketRequest, void>(
    'POST',
    getConfig('ng/api'),
    `/jira/createTicket`,
    props,
    signal
  )

export interface UpdateJiraTicketQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type UpdateJiraTicketProps = Omit<
  MutateProps<ResponseString, Failure | Error, UpdateJiraTicketQueryParams, UpdateJiraTicketRequest, void>,
  'path' | 'verb'
>

/**
 * Update jira ticket
 */
export const UpdateJiraTicket = (props: UpdateJiraTicketProps) => (
  <Mutate<ResponseString, Failure | Error, UpdateJiraTicketQueryParams, UpdateJiraTicketRequest, void>
    verb="POST"
    path="/jira/updateTicket"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateJiraTicketProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, UpdateJiraTicketQueryParams, UpdateJiraTicketRequest, void>,
  'path' | 'verb'
>

/**
 * Update jira ticket
 */
export const useUpdateJiraTicket = (props: UseUpdateJiraTicketProps) =>
  useMutate<ResponseString, Failure | Error, UpdateJiraTicketQueryParams, UpdateJiraTicketRequest, void>(
    'POST',
    `/jira/updateTicket`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update jira ticket
 */
export const updateJiraTicketPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    UpdateJiraTicketQueryParams,
    UpdateJiraTicketRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, UpdateJiraTicketQueryParams, UpdateJiraTicketRequest, void>(
    'POST',
    getConfig('ng/api'),
    `/jira/updateTicket`,
    props,
    signal
  )

export interface FetchJiraIssueQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  jiraIssueId?: string
}

export type FetchJiraIssueProps = Omit<
  GetProps<ResponseJiraIssue, Failure | Error, FetchJiraIssueQueryParams, void>,
  'path'
>

/**
 * Fetch jira issue
 */
export const FetchJiraIssue = (props: FetchJiraIssueProps) => (
  <Get<ResponseJiraIssue, Failure | Error, FetchJiraIssueQueryParams, void>
    path="/jira/fetchIssue"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseFetchJiraIssueProps = Omit<
  UseGetProps<ResponseJiraIssue, Failure | Error, FetchJiraIssueQueryParams, void>,
  'path'
>

/**
 * Fetch jira issue
 */
export const useFetchJiraIssue = (props: UseFetchJiraIssueProps) =>
  useGet<ResponseJiraIssue, Failure | Error, FetchJiraIssueQueryParams, void>(`/jira/fetchIssue`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Fetch jira issue
 */
export const fetchJiraIssuePromise = (
  props: GetUsingFetchProps<ResponseJiraIssue, Failure | Error, FetchJiraIssueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraIssue, Failure | Error, FetchJiraIssueQueryParams, void>(
    getConfig('ng/api'),
    `/jira/fetchIssue`,
    props,
    signal
  )

export interface GetJiraProjectStatusesQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
}

export type GetJiraProjectStatusesProps = Omit<
  GetProps<ResponseJiraProjectStatusesResponse, Failure | Error, GetJiraProjectStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira project statuses
 */
export const GetJiraProjectStatuses = (props: GetJiraProjectStatusesProps) => (
  <Get<ResponseJiraProjectStatusesResponse, Failure | Error, GetJiraProjectStatusesQueryParams, void>
    path="/jira/getProjectStatuses"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraProjectStatusesProps = Omit<
  UseGetProps<ResponseJiraProjectStatusesResponse, Failure | Error, GetJiraProjectStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira project statuses
 */
export const useGetJiraProjectStatuses = (props: UseGetJiraProjectStatusesProps) =>
  useGet<ResponseJiraProjectStatusesResponse, Failure | Error, GetJiraProjectStatusesQueryParams, void>(
    `/jira/getProjectStatuses`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira project statuses
 */
export const getJiraProjectStatusesPromise = (
  props: GetUsingFetchProps<
    ResponseJiraProjectStatusesResponse,
    Failure | Error,
    GetJiraProjectStatusesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraProjectStatusesResponse, Failure | Error, GetJiraProjectStatusesQueryParams, void>(
    getConfig('ng/api'),
    `/jira/getProjectStatuses`,
    props,
    signal
  )

export interface GetJiraFieldsOptionsQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
}

export type GetJiraFieldsOptionsProps = Omit<
  GetProps<ResponseJiraFieldResponse, Failure | Error, GetJiraFieldsOptionsQueryParams, void>,
  'path'
>

/**
 * Get jira fields options
 */
export const GetJiraFieldsOptions = (props: GetJiraFieldsOptionsProps) => (
  <Get<ResponseJiraFieldResponse, Failure | Error, GetJiraFieldsOptionsQueryParams, void>
    path="/jira/getFieldsOptions"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraFieldsOptionsProps = Omit<
  UseGetProps<ResponseJiraFieldResponse, Failure | Error, GetJiraFieldsOptionsQueryParams, void>,
  'path'
>

/**
 * Get jira fields options
 */
export const useGetJiraFieldsOptions = (props: UseGetJiraFieldsOptionsProps) =>
  useGet<ResponseJiraFieldResponse, Failure | Error, GetJiraFieldsOptionsQueryParams, void>(`/jira/getFieldsOptions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira fields options
 */
export const getJiraFieldsOptionsPromise = (
  props: GetUsingFetchProps<ResponseJiraFieldResponse, Failure | Error, GetJiraFieldsOptionsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraFieldResponse, Failure | Error, GetJiraFieldsOptionsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/getFieldsOptions`,
    props,
    signal
  )

export interface CheckJiraApprovalQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  issueId?: string
  approvalField?: string
  approvalFieldValue?: string
  rejectionField?: string
  rejectionFieldValue?: string
}

export type CheckJiraApprovalProps = Omit<
  GetProps<ResponseJiraApprovalResponse, Failure | Error, CheckJiraApprovalQueryParams, void>,
  'path'
>

/**
 * Check jira approval
 */
export const CheckJiraApproval = (props: CheckJiraApprovalProps) => (
  <Get<ResponseJiraApprovalResponse, Failure | Error, CheckJiraApprovalQueryParams, void>
    path="/jira/checkApproval"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckJiraApprovalProps = Omit<
  UseGetProps<ResponseJiraApprovalResponse, Failure | Error, CheckJiraApprovalQueryParams, void>,
  'path'
>

/**
 * Check jira approval
 */
export const useCheckJiraApproval = (props: UseCheckJiraApprovalProps) =>
  useGet<ResponseJiraApprovalResponse, Failure | Error, CheckJiraApprovalQueryParams, void>(`/jira/checkApproval`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Check jira approval
 */
export const checkJiraApprovalPromise = (
  props: GetUsingFetchProps<ResponseJiraApprovalResponse, Failure | Error, CheckJiraApprovalQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraApprovalResponse, Failure | Error, CheckJiraApprovalQueryParams, void>(
    getConfig('ng/api'),
    `/jira/checkApproval`,
    props,
    signal
  )

export interface GetJiraCreateMetadataQueryParams {
  connectorRef?: string
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
  createExpandParam?: string
}

export type GetJiraCreateMetadataProps = Omit<
  GetProps<ResponseJiraGetCreateMetadataResponse, Failure | Error, GetJiraCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira create metadata options
 */
export const GetJiraCreateMetadata = (props: GetJiraCreateMetadataProps) => (
  <Get<ResponseJiraGetCreateMetadataResponse, Failure | Error, GetJiraCreateMetadataQueryParams, void>
    path="/jira/getCreateMetadata"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraCreateMetadataProps = Omit<
  UseGetProps<ResponseJiraGetCreateMetadataResponse, Failure | Error, GetJiraCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira create metadata options
 */
export const useGetJiraCreateMetadata = (props: UseGetJiraCreateMetadataProps) =>
  useGet<ResponseJiraGetCreateMetadataResponse, Failure | Error, GetJiraCreateMetadataQueryParams, void>(
    `/jira/getCreateMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira create metadata options
 */
export const getJiraCreateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseJiraGetCreateMetadataResponse,
    Failure | Error,
    GetJiraCreateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraGetCreateMetadataResponse, Failure | Error, GetJiraCreateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/jira/getCreateMetadata`,
    props,
    signal
  )

export interface GetGraphOrchestrationQueryParams {
  planExecutionId?: string
}

export type GetGraphOrchestrationProps = Omit<
  GetProps<RestResponseOrchestrationGraphDTO, unknown, GetGraphOrchestrationQueryParams, void>,
  'path'
>

/**
 * generate orchestration graph for plan execution
 */
export const GetGraphOrchestration = (props: GetGraphOrchestrationProps) => (
  <Get<RestResponseOrchestrationGraphDTO, unknown, GetGraphOrchestrationQueryParams, void>
    path="/orchestration/get-graph-orchestration"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGraphOrchestrationProps = Omit<
  UseGetProps<RestResponseOrchestrationGraphDTO, unknown, GetGraphOrchestrationQueryParams, void>,
  'path'
>

/**
 * generate orchestration graph for plan execution
 */
export const useGetGraphOrchestration = (props: UseGetGraphOrchestrationProps) =>
  useGet<RestResponseOrchestrationGraphDTO, unknown, GetGraphOrchestrationQueryParams, void>(
    `/orchestration/get-graph-orchestration`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * generate orchestration graph for plan execution
 */
export const getGraphOrchestrationPromise = (
  props: GetUsingFetchProps<RestResponseOrchestrationGraphDTO, unknown, GetGraphOrchestrationQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseOrchestrationGraphDTO, unknown, GetGraphOrchestrationQueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/get-graph-orchestration`,
    props,
    signal
  )

export interface GetGraphVisualizationQueryParams {
  planExecutionId?: string
}

export type GetGraphVisualizationProps = Omit<GetProps<void, unknown, GetGraphVisualizationQueryParams, void>, 'path'>

/**
 * generate graph execution visualization
 */
export const GetGraphVisualization = (props: GetGraphVisualizationProps) => (
  <Get<void, unknown, GetGraphVisualizationQueryParams, void>
    path="/orchestration/get-graph-visualization"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGraphVisualizationProps = Omit<
  UseGetProps<void, unknown, GetGraphVisualizationQueryParams, void>,
  'path'
>

/**
 * generate graph execution visualization
 */
export const useGetGraphVisualization = (props: UseGetGraphVisualizationProps) =>
  useGet<void, unknown, GetGraphVisualizationQueryParams, void>(`/orchestration/get-graph-visualization`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * generate graph execution visualization
 */
export const getGraphVisualizationPromise = (
  props: GetUsingFetchProps<void, unknown, GetGraphVisualizationQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, unknown, GetGraphVisualizationQueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/get-graph-visualization`,
    props,
    signal
  )

export interface HttpV2QueryParams {
  accountId: string
  appId: string
}

export type HttpV2Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>, 'path'>

/**
 * Triggers a task v2 Plan
 */
export const HttpV2 = (props: HttpV2Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>
    path="/orchestration/http-v2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpV2Props = Omit<UseGetProps<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>, 'path'>

/**
 * Triggers a task v2 Plan
 */
export const useHttpV2 = (props: UseHttpV2Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>(`/orchestration/http-v2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task v2 Plan
 */
export const httpV2Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-v2`,
    props,
    signal
  )

export interface HttpV3QueryParams {
  accountId: string
  appId: string
}

export type HttpV3Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>, 'path'>

/**
 * Triggers a task v3 Plan
 */
export const HttpV3 = (props: HttpV3Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>
    path="/orchestration/http-v3"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpV3Props = Omit<UseGetProps<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>, 'path'>

/**
 * Triggers a task v3 Plan
 */
export const useHttpV3 = (props: UseHttpV3Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>(`/orchestration/http-v3`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task v3 Plan
 */
export const httpV3Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpV3QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-v3`,
    props,
    signal
  )

export interface HttpChainV2QueryParams {
  accountId: string
  appId: string
}

export type HttpChainV2Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>, 'path'>

/**
 * Triggers a task chain v2 Plan
 */
export const HttpChainV2 = (props: HttpChainV2Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>
    path="/orchestration/http-chain-v2"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpChainV2Props = Omit<
  UseGetProps<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>,
  'path'
>

/**
 * Triggers a task chain v2 Plan
 */
export const useHttpChainV2 = (props: UseHttpChainV2Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>(`/orchestration/http-chain-v2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task chain v2 Plan
 */
export const httpChainV2Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpChainV2QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-chain-v2`,
    props,
    signal
  )

export interface HttpChainV3QueryParams {
  accountId: string
  appId: string
}

export type HttpChainV3Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>, 'path'>

/**
 * Triggers a task chain v3 Plan
 */
export const HttpChainV3 = (props: HttpChainV3Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>
    path="/orchestration/http-chain-v3"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHttpChainV3Props = Omit<
  UseGetProps<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>,
  'path'
>

/**
 * Triggers a task chain v3 Plan
 */
export const useHttpChainV3 = (props: UseHttpChainV3Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>(`/orchestration/http-chain-v3`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Triggers a task chain v3 Plan
 */
export const httpChainV3Promise = (
  props: GetUsingFetchProps<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePlanExecution, unknown, HttpChainV3QueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/http-chain-v3`,
    props,
    signal
  )

export interface GetGraphQueryParams {
  planExecutionId?: string
}

export type GetGraphProps = Omit<
  GetProps<RestResponseOrchestrationGraphDTO, unknown, GetGraphQueryParams, void>,
  'path'
>

/**
 * generate graph for plan execution
 */
export const GetGraph = (props: GetGraphProps) => (
  <Get<RestResponseOrchestrationGraphDTO, unknown, GetGraphQueryParams, void>
    path="/orchestration/get-graph"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGraphProps = Omit<
  UseGetProps<RestResponseOrchestrationGraphDTO, unknown, GetGraphQueryParams, void>,
  'path'
>

/**
 * generate graph for plan execution
 */
export const useGetGraph = (props: UseGetGraphProps) =>
  useGet<RestResponseOrchestrationGraphDTO, unknown, GetGraphQueryParams, void>(`/orchestration/get-graph`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * generate graph for plan execution
 */
export const getGraphPromise = (
  props: GetUsingFetchProps<RestResponseOrchestrationGraphDTO, unknown, GetGraphQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseOrchestrationGraphDTO, unknown, GetGraphQueryParams, void>(
    getConfig('ng/api'),
    `/orchestration/get-graph`,
    props,
    signal
  )

export interface GetInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetInputSetForPipelineProps = Omit<
  GetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const GetInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetInputSetForPipelineProps) => (
  <Get<ResponseInputSetResponse, Failure | Error, GetInputSetForPipelineQueryParams, GetInputSetForPipelinePathParams>
    path="/inputSets/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const useGetInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseGetInputSetForPipelineProps) =>
  useGet<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >((paramsInPath: GetInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Gets an InputSet by identifier
 */
export const getInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >(getConfig('ng/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface UpdateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const UpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UpdateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >
    verb="PUT"
    path="/inputSets/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const useUpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseUpdateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', (paramsInPath: UpdateInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Update an InputSet by identifier
 */
export const updateInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', getConfig('ng/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface DeleteInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type DeleteInputSetForPipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const DeleteInputSetForPipeline = (props: DeleteInputSetForPipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>
    verb="DELETE"
    path="/inputSets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInputSetForPipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an inputSet by identifier
 */
export const useDeleteInputSetForPipeline = (props: UseDeleteInputSetForPipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    `/inputSets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete an inputSet by identifier
 */
export const deleteInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/inputSets`,
    props,
    signal
  )

export interface GetOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  deleted?: boolean
}

export interface GetOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetOverlayInputSetForPipelineProps = Omit<
  GetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const GetOverlayInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetOverlayInputSetForPipelineProps) => (
  <Get<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >
    path="/inputSets/overlay/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOverlayInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const useGetOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseGetOverlayInputSetForPipelineProps) =>
  useGet<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(
    (paramsInPath: GetOverlayInputSetForPipelinePathParams) => `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Gets an Overlay InputSet by identifier
 */
export const getOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(getConfig('ng/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface UpdateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface UpdateOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const UpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UpdateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >
    verb="PUT"
    path="/inputSets/overlay/${inputSetIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const useUpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseUpdateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >(
    'PUT',
    (paramsInPath: UpdateOverlayInputSetForPipelinePathParams) =>
      `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Update an Overlay InputSet by identifier
 */
export const updateOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    UpdateOverlayInputSetForPipelinePathParams
  >('PUT', getConfig('ng/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface GetInputSetsListForPipelineQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  inputSetType?: 'ALL' | 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  searchTerm?: string
  sortOrders?: string[]
}

export type GetInputSetsListForPipelineProps = Omit<
  GetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const GetInputSetsListForPipeline = (props: GetInputSetsListForPipelineProps) => (
  <Get<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>
    path="/inputSets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInputSetsListForPipelineProps = Omit<
  UseGetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const useGetInputSetsListForPipeline = (props: UseGetInputSetsListForPipelineProps) =>
  useGet<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    `/inputSets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets InputSets list for a pipeline
 */
export const getInputSetsListForPipelinePromise = (
  props: GetUsingFetchProps<
    ResponsePageInputSetSummaryResponse,
    Failure | Error,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    getConfig('ng/api'),
    `/inputSets`,
    props,
    signal
  )

export interface CreateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const CreateInputSetForPipeline = (props: CreateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >
    verb="POST"
    path="/inputSets"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const useCreateInputSetForPipeline = (props: UseCreateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >('POST', `/inputSets`, { base: getConfig('ng/api'), ...props })

/**
 * Create an InputSet For Pipeline
 */
export const createInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    InputSetConfigRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets`, props, signal)

export interface CreateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type CreateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const CreateOverlayInputSetForPipeline = (props: CreateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >
    verb="POST"
    path="/inputSets/overlay"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const useCreateOverlayInputSetForPipeline = (props: UseCreateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >('POST', `/inputSets/overlay`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Overlay InputSet For Pipeline
 */
export const createOverlayInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    OverlayInputSetConfigRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets/overlay`, props, signal)

export interface GetTemplateFromPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type GetTemplateFromPipelineProps = Omit<
  GetProps<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const GetTemplateFromPipeline = (props: GetTemplateFromPipelineProps) => (
  <Get<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>
    path="/inputSets/template"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTemplateFromPipelineProps = Omit<
  UseGetProps<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>,
  'path'
>

/**
 * Get template from a pipeline yaml
 */
export const useGetTemplateFromPipeline = (props: UseGetTemplateFromPipelineProps) =>
  useGet<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>(
    `/inputSets/template`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get template from a pipeline yaml
 */
export const getTemplateFromPipelinePromise = (
  props: GetUsingFetchProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInputSetTemplateResponse, Failure | Error, GetTemplateFromPipelineQueryParams, void>(
    getConfig('ng/api'),
    `/inputSets/template`,
    props,
    signal
  )

export interface GetMergeInputSetFromPipelineTemplateWithListInputQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  useFQNIfError?: boolean
}

export type GetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const GetMergeInputSetFromPipelineTemplateWithListInput = (
  props: GetMergeInputSetFromPipelineTemplateWithListInputProps
) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >
    verb="POST"
    path="/inputSets/merge"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const useGetMergeInputSetFromPipelineTemplateWithListInput = (
  props: UseGetMergeInputSetFromPipelineTemplateWithListInputProps
) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', `/inputSets/merge`, { base: getConfig('ng/api'), ...props })

/**
 * Merges given input sets list on pipeline and return input set template format of applied pipeline
 */
export const getMergeInputSetFromPipelineTemplateWithListInputPromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/inputSets/merge`, props, signal)

export interface GetPipelineListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetPipelineListProps = Omit<
  GetProps<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const GetPipelineList = (props: GetPipelineListProps) => (
  <Get<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>
    path="/pipelines"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineListProps = Omit<
  UseGetProps<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const useGetPipelineList = (props: UseGetPipelineListProps) =>
  useGet<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>(`/pipelines`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Pipeline list
 */
export const getPipelineListPromise = (
  props: GetUsingFetchProps<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGPipelineSummaryResponse, Failure | Error, GetPipelineListQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export interface PostPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type PostPipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const PostPipeline = (props: PostPipelineProps) => (
  <Mutate<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>
    verb="POST"
    path="/pipelines"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostPipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const usePostPipeline = (props: UsePostPipelineProps) =>
  useMutate<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>(
    'POST',
    `/pipelines`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Pipeline
 */
export const postPipelinePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, PostPipelineQueryParams, NgPipelineRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export interface GetPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetPipelinePathParams {
  pipelineIdentifier: string
}

export type GetPipelineProps = Omit<
  GetProps<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipeline = ({ pipelineIdentifier, ...props }: GetPipelineProps) => (
  <Get<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>
    path="/pipelines/${pipelineIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineProps = Omit<
  UseGetProps<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipeline = ({ pipelineIdentifier, ...props }: UseGetPipelineProps) =>
  useGet<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    (paramsInPath: GetPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Gets a pipeline by identifier
 */
export const getPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams> & {
    pipelineIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGPipelineResponse, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    getConfig('ng/api'),
    `/pipelines/${pipelineIdentifier}`,
    props,
    signal
  )

export interface PutPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface PutPipelinePathParams {
  pipelineIdentifier: string
}

export type PutPipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const PutPipeline = ({ pipelineIdentifier, ...props }: PutPipelineProps) => (
  <Mutate<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>
    verb="PUT"
    path="/pipelines/${pipelineIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutPipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const usePutPipeline = ({ pipelineIdentifier, ...props }: UsePutPipelineProps) =>
  useMutate<ResponseString, Failure | Error, PutPipelineQueryParams, NgPipelineRequestBody, PutPipelinePathParams>(
    'PUT',
    (paramsInPath: PutPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Update a Pipeline
 */
export const putPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    NgPipelineRequestBody,
    PutPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    NgPipelineRequestBody,
    PutPipelinePathParams
  >('PUT', getConfig('ng/api'), `/pipelines/${pipelineIdentifier}`, props, signal)

export interface SoftDeletePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type SoftDeletePipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const SoftDeletePipeline = (props: SoftDeletePipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>
    verb="DELETE"
    path="/pipelines"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSoftDeletePipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const useSoftDeletePipeline = (props: UseSoftDeletePipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>('DELETE', `/pipelines`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a pipeline
 */
export const softDeletePipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/pipelines`,
    props,
    signal
  )

export interface GetPipelineSummaryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetPipelineSummaryPathParams {
  pipelineIdentifier: string
}

export type GetPipelineSummaryProps = Omit<
  GetProps<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipelineSummary = ({ pipelineIdentifier, ...props }: GetPipelineSummaryProps) => (
  <Get<ResponseNGPipelineSummaryResponse, Failure | Error, GetPipelineSummaryQueryParams, GetPipelineSummaryPathParams>
    path="/pipelines/summary/${pipelineIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineSummaryProps = Omit<
  UseGetProps<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipelineSummary = ({ pipelineIdentifier, ...props }: UseGetPipelineSummaryProps) =>
  useGet<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >((paramsInPath: GetPipelineSummaryPathParams) => `/pipelines/summary/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Gets a pipeline by identifier
 */
export const getPipelineSummaryPromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNGPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >(getConfig('ng/api'), `/pipelines/summary/${pipelineIdentifier}`, props, signal)

export type DummyApiForSwaggerSchemaCheckProps = Omit<
  GetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const DummyApiForSwaggerSchemaCheck = (props: DummyApiForSwaggerSchemaCheckProps) => (
  <Get<ResponsePipelineConfig, Failure | Error, void, void>
    path="/pipelines/dummyApiForSwaggerSchemaCheck"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyApiForSwaggerSchemaCheckProps = Omit<
  UseGetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const useDummyApiForSwaggerSchemaCheck = (props: UseDummyApiForSwaggerSchemaCheckProps) =>
  useGet<ResponsePipelineConfig, Failure | Error, void, void>(`/pipelines/dummyApiForSwaggerSchemaCheck`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api for checking pms schema
 */
export const dummyApiForSwaggerSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponsePipelineConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePipelineConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/dummyApiForSwaggerSchemaCheck`,
    props,
    signal
  )

export interface GetTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerPathParams {
  triggerIdentifier: string
}

export type GetTriggerProps = Omit<
  GetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const GetTrigger = ({ triggerIdentifier, ...props }: GetTriggerProps) => (
  <Get<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>
    path="/triggers/${triggerIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTriggerProps = Omit<
  UseGetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const useGetTrigger = ({ triggerIdentifier, ...props }: UseGetTriggerProps) =>
  useGet<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    (paramsInPath: GetTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Gets a trigger by identifier
 */
export const getTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams> & {
    triggerIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    getConfig('ng/api'),
    `/triggers/${triggerIdentifier}`,
    props,
    signal
  )

export interface UpdateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface UpdateTriggerPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerProps = Omit<
  MutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const UpdateTrigger = ({ triggerIdentifier, ...props }: UpdateTriggerProps) => (
  <Mutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >
    verb="PUT"
    path="/triggers/${triggerIdentifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const useUpdateTrigger = ({ triggerIdentifier, ...props }: UseUpdateTriggerProps) =>
  useMutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >('PUT', (paramsInPath: UpdateTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { triggerIdentifier },
    ...props
  })

/**
 * Update a trigger by identifier
 */
export const updateTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    UpdateTriggerPathParams
  >('PUT', getConfig('ng/api'), `/triggers/${triggerIdentifier}`, props, signal)

export interface DeleteTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export type DeleteTriggerProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const DeleteTrigger = (props: DeleteTriggerProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>
    verb="DELETE"
    path="/triggers"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteTriggerProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const useDeleteTrigger = (props: UseDeleteTriggerProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>('DELETE', `/triggers`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a trigger by identifier
 */
export const deleteTriggerPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/triggers`,
    props,
    signal
  )

export interface GetTriggerListForTargetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetTriggerListForTargetProps = Omit<
  GetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for target
 */
export const GetTriggerListForTarget = (props: GetTriggerListForTargetProps) => (
  <Get<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>
    path="/triggers"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTriggerListForTargetProps = Omit<
  UseGetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for target
 */
export const useGetTriggerListForTarget = (props: UseGetTriggerListForTargetProps) =>
  useGet<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(`/triggers`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Triggers list for target
 */
export const getTriggerListForTargetPromise = (
  props: GetUsingFetchProps<
    ResponsePageNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerListForTargetQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(
    getConfig('ng/api'),
    `/triggers`,
    props,
    signal
  )

export interface CreateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type CreateTriggerProps = Omit<
  MutateProps<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const CreateTrigger = (props: CreateTriggerProps) => (
  <Mutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigRequestBody, void>
    verb="POST"
    path="/triggers"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const useCreateTrigger = (props: UseCreateTriggerProps) =>
  useMutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, NGTriggerConfigRequestBody, void>(
    'POST',
    `/triggers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create Trigger
 */
export const createTriggerPromise = (
  props: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    NGTriggerConfigRequestBody,
    void
  >('POST', getConfig('ng/api'), `/triggers`, props, signal)

export interface UpdateTriggerStatusQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  status: boolean
}

export interface UpdateTriggerStatusPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerStatusProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const UpdateTriggerStatus = ({ triggerIdentifier, ...props }: UpdateTriggerStatusProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>
    verb="PUT"
    path="/triggers/${triggerIdentifier}/status"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateTriggerStatusProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const useUpdateTriggerStatus = ({ triggerIdentifier, ...props }: UseUpdateTriggerStatusProps) =>
  useMutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>(
    'PUT',
    (paramsInPath: UpdateTriggerStatusPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/status`,
    { base: getConfig('ng/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Update a trigger's status by identifier
 */
export const updateTriggerStatusPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  >('PUT', getConfig('ng/api'), `/triggers/${triggerIdentifier}/status`, props, signal)

export interface GetTriggerDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerDetailsPathParams {
  triggerIdentifier: string
}

export type GetTriggerDetailsProps = Omit<
  GetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Gets Triggers list for target
 */
export const GetTriggerDetails = ({ triggerIdentifier, ...props }: GetTriggerDetailsProps) => (
  <Get<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>
    path="/triggers/${triggerIdentifier}/details"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTriggerDetailsProps = Omit<
  UseGetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Gets Triggers list for target
 */
export const useGetTriggerDetails = ({ triggerIdentifier, ...props }: UseGetTriggerDetailsProps) =>
  useGet<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>(
    (paramsInPath: GetTriggerDetailsPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/details`,
    { base: getConfig('ng/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Gets Triggers list for target
 */
export const getTriggerDetailsPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >(getConfig('ng/api'), `/triggers/${triggerIdentifier}/details`, props, signal)

export interface GetTriggerListForRepoURLQueryParams {
  repoURL: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetTriggerListForRepoURLProps = Omit<
  GetProps<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for Repo URL
 */
export const GetTriggerListForRepoURL = (props: GetTriggerListForRepoURLProps) => (
  <Get<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>
    path="/triggers/triggersList"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTriggerListForRepoURLProps = Omit<
  UseGetProps<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>,
  'path'
>

/**
 * Gets Triggers list for Repo URL
 */
export const useGetTriggerListForRepoURL = (props: UseGetTriggerListForRepoURLProps) =>
  useGet<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>(
    `/triggers/triggersList`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Triggers list for Repo URL
 */
export const getTriggerListForRepoURLPromise = (
  props: GetUsingFetchProps<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGTriggerResponse, Failure | Error, GetTriggerListForRepoURLQueryParams, void>(
    getConfig('ng/api'),
    `/triggers/triggersList`,
    props,
    signal
  )

export type GetSourceRepoToEventProps = Omit<
  GetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetSourceRepoToEvent = (props: GetSourceRepoToEventProps) => (
  <Get<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>
    path="/webhook/sourceRepos"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSourceRepoToEventProps = Omit<
  UseGetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetSourceRepoToEvent = (props: UseGetSourceRepoToEventProps) =>
  useGet<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(`/webhook/sourceRepos`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getSourceRepoToEventPromise = (
  props: GetUsingFetchProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/webhook/sourceRepos`,
    props,
    signal
  )

export interface GetActionsListQueryParams {
  sourceRepo: 'GITHUB' | 'GITLAB' | 'BITBUCKET'
  event: string
}

export type GetActionsListProps = Omit<
  GetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const GetActionsList = (props: GetActionsListProps) => (
  <Get<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>
    path="/webhook/actions"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActionsListProps = Omit<
  UseGetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const useGetActionsList = (props: UseGetActionsListProps) =>
  useGet<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(`/webhook/actions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Actions for event type and source
 */
export const getActionsListPromise = (
  props: GetUsingFetchProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(
    getConfig('ng/api'),
    `/webhook/actions`,
    props,
    signal
  )

export interface WebhookEndpointQueryParams {
  accountIdentifier: string
}

export type WebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const WebhookEndpoint = (props: WebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>
    verb="POST"
    path="/webhook/trigger"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const useWebhookEndpoint = (props: UseWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>('POST', `/webhook/trigger`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * accept webhook event
 */
export const webhookEndpointPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>(
    'POST',
    getConfig('ng/api'),
    `/webhook/trigger`,
    props,
    signal
  )

export interface GetYamlSchemaQueryParams {
  entityType: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets'
}

export type GetYamlSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetYamlSchema = (props: GetYamlSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>
    path="/yaml-schema"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetYamlSchema = (props: UseGetYamlSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(`/yaml-schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-schema`,
    props,
    signal
  )

export interface GetYamlSchemaForSubtypeQueryParams {
  subtype:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Vault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'Awssecretsmanager'
    | 'Azurevault'
    | 'Cyberark'
    | 'CustomSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
}

export interface GetYamlSchemaForSubtypePathParams {
  entityType: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets'
}

export type GetYamlSchemaForSubtypeProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaForSubtypeQueryParams, GetYamlSchemaForSubtypePathParams>,
  'path'
> &
  GetYamlSchemaForSubtypePathParams

/**
 * Get Yaml Schema for subtype
 */
export const GetYamlSchemaForSubtype = ({ entityType, ...props }: GetYamlSchemaForSubtypeProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSchemaForSubtypeQueryParams, GetYamlSchemaForSubtypePathParams>
    path="/yaml-schema/${entityType}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSchemaForSubtypeProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaForSubtypeQueryParams, GetYamlSchemaForSubtypePathParams>,
  'path'
> &
  GetYamlSchemaForSubtypePathParams

/**
 * Get Yaml Schema for subtype
 */
export const useGetYamlSchemaForSubtype = ({ entityType, ...props }: UseGetYamlSchemaForSubtypeProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSchemaForSubtypeQueryParams, GetYamlSchemaForSubtypePathParams>(
    (paramsInPath: GetYamlSchemaForSubtypePathParams) => `/yaml-schema/${paramsInPath.entityType}`,
    { base: getConfig('ng/api'), pathParams: { entityType }, ...props }
  )

/**
 * Get Yaml Schema for subtype
 */
export const getYamlSchemaForSubtypePromise = (
  {
    entityType,
    ...props
  }: GetUsingFetchProps<
    ResponseJsonNode,
    Failure | Error,
    GetYamlSchemaForSubtypeQueryParams,
    GetYamlSchemaForSubtypePathParams
  > & { entityType: 'Projects' | 'Pipelines' | 'Connectors' | 'Secrets' | 'Service' | 'Environment' | 'InputSets' },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseJsonNode,
    Failure | Error,
    GetYamlSchemaForSubtypeQueryParams,
    GetYamlSchemaForSubtypePathParams
  >(getConfig('ng/api'), `/yaml-schema/${entityType}`, props, signal)

export interface GetYamlSnippetMetadataQueryParams {
  tags?: (
    | 'k8s'
    | 'git'
    | 'docker'
    | 'connector'
    | 'secretmanager'
    | 'secret'
    | 'secretText'
    | 'secretFile'
    | 'sshKey'
  )[]
}

export type GetYamlSnippetMetadataProps = Omit<
  GetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const GetYamlSnippetMetadata = (props: GetYamlSnippetMetadataProps) => (
  <Get<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>
    path="/yaml-snippet"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetMetadataProps = Omit<
  UseGetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const useGetYamlSnippetMetadata = (props: UseGetYamlSnippetMetadataProps) =>
  useGet<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(`/yaml-snippet`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Snippet Metadata
 */
export const getYamlSnippetMetadataPromise = (
  props: GetUsingFetchProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-snippet`,
    props,
    signal
  )

export interface GetYamlSnippetPathParams {
  identifier: string
}

export type GetYamlSnippetProps = Omit<
  GetProps<ResponseString, Failure | Error, void, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const GetYamlSnippet = ({ identifier, ...props }: GetYamlSnippetProps) => (
  <Get<ResponseString, Failure | Error, void, GetYamlSnippetPathParams>
    path="/yaml-snippet/${identifier}"
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetProps = Omit<
  UseGetProps<ResponseString, Failure | Error, void, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const useGetYamlSnippet = ({ identifier, ...props }: UseGetYamlSnippetProps) =>
  useGet<ResponseString, Failure | Error, void, GetYamlSnippetPathParams>(
    (paramsInPath: GetYamlSnippetPathParams) => `/yaml-snippet/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Yaml Snippet
 */
export const getYamlSnippetPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseString, Failure | Error, void, GetYamlSnippetPathParams> & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, void, GetYamlSnippetPathParams>(
    getConfig('ng/api'),
    `/yaml-snippet/${identifier}`,
    props,
    signal
  )
