/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>

export interface RestResponseConnectorValidationResult {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: ConnectorValidationResult
  responseMessages?: ResponseMessage[]
}

export interface ResponseDTOOptionalOrganizationDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OrganizationDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export interface ResponseDTONGPageResponseOrganizationDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseOrganizationDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ArtifactListConfig {
  primary?: ArtifactSpecWrapper
  sidecars?: SidecarArtifactWrapper[]
}

export interface StreamingOutput {
  [key: string]: any
}

export interface ResponseDTOListSecretManagerConfig {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretManagerConfig[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EncryptedDataDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface EncryptedDataDetail {
  encryptedData?: EncryptedRecordData
  encryptionConfig?: EncryptionConfig
  fieldName?: string
}

export interface ResponseDTOSecretManagerConfig {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: SecretManagerConfig
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface UpdateOrganizationDTO {
  name: string
  color: string
  description: string
  tags: string[]
}

export interface ServiceOverrides {
  name?: string
  description?: string
}

export type K8SDirectInfrastructure = Infrastructure & {
  connectorIdentifier?: string
  namespace?: string
  releaseName?: string
}

export interface EncryptedDataParams {
  name?: string
  value?: string
}

export interface SidecarArtifactWrapper {
  identifier: string
}

export interface ValidationError {
  field?: string
  error?: string
}

export interface PageProjectDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: ProjectDTO[]
  number?: number
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  first?: boolean
  sort?: Sort
  empty?: boolean
}

export interface UpdateProjectDTO {
  name: string
  description: string
  owners: string[]
  tags: string[]
  purposeList: string[]
}

export interface Tags {
  [key: string]: any
}

export type KubernetesServiceSpec = ServiceSpec & {}

export interface StageVariables {
  variables?: Variable[]
  previousStageIdentifier?: string
  overrides?: Variable[]
}

export type GcrArtifactConfig = ArtifactConfig & {
  connectorIdentifier?: string
  registryHostname?: string
  imagePath?: string
}

export interface ResponseData {
  [key: string]: any
}

export interface OptionalConnectorDTO {
  present?: boolean
}

export interface ManifestOverrideSets {
  identifier: string
  manifests?: ManifestConfigWrapper[]
}

export interface OrganizationDTO {
  id?: string
  accountIdentifier?: string
  identifier?: string
  name?: string
  color?: string
  description?: string
  tags?: string[]
}

export interface ResponseDTOCDPipelineDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: CDPipelineDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CreateOrganizationDTO {
  identifier: string
  name: string
  color: string
  description?: string
  tags: string[]
}

export interface Graph {
  cacheContextOrder?: number
  cacheKey?: string
  cacheParams?: string[]
  planExecutionId?: string
  startTs?: number
  endTs?: number
  status?:
    | 'RUNNING'
    | 'WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUCCEEDED'
  graphVertex?: GraphVertex
  lastUpdatedAt?: number
}

export interface InterruptEffect {
  interruptId: string
  tookEffectAt: number
  interruptType:
    | 'ABORT'
    | 'ABORT_ALL'
    | 'PAUSE'
    | 'PAUSE_ALL'
    | 'RESUME'
    | 'RESUME_ALL'
    | 'RETRY'
    | 'IGNORE'
    | 'MARK_FAILED'
    | 'MARK_SUCCESS'
    | 'ROLLBACK'
    | 'NEXT_STEP'
    | 'END_EXECUTION'
    | 'ROLLBACK_DONE'
    | 'MARK_EXPIRED'
}

export interface ExecutionElement {
  steps: ExecutionWrapper[]
  rollbackSteps?: ExecutionWrapper[]
}

export interface EncryptedRecordData {
  uuid?: string
  name?: string
  path?: string
  parameters?: EncryptedDataParams[]
  encryptionKey?: string
  encryptedValue?: string[]
  kmsId?: string
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  backupEncryptedValue?: string[]
  backupEncryptionKey?: string
  backupKmsId?: string
  backupEncryptionType?:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'CYBERARK'
    | 'VAULT'
    | 'CUSTOM'
  base64Encoded?: boolean
}

export interface StoreConfigWrapper {
  type?: string
  spec?: StoreConfig
}

export interface ProjectDTO {
  id?: string
  accountIdentifier?: string
  orgIdentifier?: string
  identifier?: string
  name?: string
  color?: string
  purposeList?: string[]
  description?: string
  owners?: string[]
  tags?: string[]
}

export interface GitSyncFolderConfigDTO {
  rootFolder?: string
  isDefault?: boolean
  identifier?: string
  enabled?: boolean
}

export interface InfraUseFromStage {
  stage: string
  overrides?: InfraOverrides
}

export interface ConnectorConfigDTO {
  [key: string]: any
}

export interface StageElementWrapper {
  [key: string]: any
}

export interface StackTraceElement {
  methodName?: string
  fileName?: string
  lineNumber?: number
  className?: string
  nativeMethod?: boolean
}

export interface PlanExecution {
  uuid?: string
  createdBy?: EmbeddedUser
  createdAt?: number
  setupAbstractions?: {
    [key: string]: string
  }
  validUntil?: string
  status?:
    | 'RUNNING'
    | 'WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUCCEEDED'
  startTs?: number
  endTs?: number
  lastUpdatedAt?: number
  version?: number
}

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: boolean
  responseMessages?: ResponseMessage[]
}

export interface ArtifactSpecWrapper {
  type?: string
  spec?: ArtifactConfig
}

export type SidecarArtifact = SidecarArtifactWrapper & {
  type?: string
  spec?: ArtifactConfig
}

export interface NGPageResponseProjectDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: ProjectDTO[]
  pageNumber?: number
  empty?: boolean
}

export interface Infrastructure {
  refType?: RefType
}

export interface ConnectorConfigSummaryDTO {
  [key: string]: any
}

export interface ResponseDTONGPageResponseProjectDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: NGPageResponseProjectDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ServiceDefinition {
  type?: string
  spec?: ServiceSpec
}

export interface NGPageResponseOrganizationDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: OrganizationDTO[]
  pageNumber?: number
  empty?: boolean
}

export interface ManifestAttributes {
  [key: string]: any
}

export interface ManifestConfigWrapper {
  identifier: string
}

export interface ResponseDTOPlanExecution {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PlanExecution
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface CreateProjectDTO {
  accountIdentifier: string
  identifier: string
  name: string
  color: string
  purposeList: string[]
  description?: string
  owners: string[]
  tags: string[]
}

export interface TemporalUnit {
  timeBased?: boolean
  duration?: Duration
  dateBased?: boolean
  durationEstimated?: boolean
}

export type K8sManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
}

export type ValuesManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
}

export type DockerHubArtifactConfig = ArtifactConfig & {
  connectorIdentifier?: string
  imagePath?: string
  tag?: string
  tagRegex?: string
}

export interface StepSpecType {
  [key: string]: any
}

export interface ConnectorFilter {
  accountId?: string
  projectId?: string
  orgId?: string
  type?: 'KUBERNETES_CLUSTER' | 'GIT'
  tag?: Tags[]
  lastActivity?: number
  name?: string
}

export interface Outcome {
  refType?: RefType
}

export interface Subgraph {
  mode?:
    | 'SYNC'
    | 'ASYNC'
    | 'SKIP'
    | 'TASK_CHAIN'
    | 'TASK_CHAIN_V2'
    | 'CHILDREN'
    | 'CHILD'
    | 'TASK'
    | 'CHILD_CHAIN'
    | 'TASK_V2'
  vertices?: GraphVertex[]
}

export interface ConnectorValidationResult {
  valid?: boolean
  errorMessage?: string
}

export interface Tag {
  key: string
  value: string
}

export interface ExecutionWrapper {
  [key: string]: any
}

export type StepElement = ExecutionWrapper & {
  identifier: string
  name?: string
  type?: string
  spec?: StepSpecType
}

export interface ConnectorSummaryDTO {
  identifier?: string
  name?: string
  description?: string
  accountId?: string
  orgId?: string
  projectId?: string
  accountName?: string
  orgName?: string
  projectName?: string
  type?: 'KUBERNETES_CLUSTER' | 'GIT'
  categories?: 'CLOUD_PROVIDER'[]
  connectorDetials?: ConnectorConfigSummaryDTO
  tags?: string[]
  createdAt?: number
  lastModifiedAt?: number
  version?: number
}

export interface ResponseDTOOptionalProjectDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ProjectDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface SecretManagerConfig {
  uuid: string
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  accountId?: string
  numOfEncryptedValue?: number
  encryptedBy?: string
  createdBy?: EmbeddedUser
  createdAt?: number
  lastUpdatedBy?: EmbeddedUser
  lastUpdatedAt: number
  nextTokenRenewIteration?: number
  templatizedFields?: string[]
  default?: boolean
  encryptionServiceUrl?: string
  validationCriteria?: string
  name?: string
}

export type K8sRollingRollbackStepInfo = StepSpecType & {
  timeout?: number
  stepDependencySpecs?: {
    [key: string]: StepDependencySpec
  }
}

export interface ServiceSpec {
  artifacts?: ArtifactListConfig
  manifests?: ManifestConfigWrapper[]
  manifestOverrideSets?: ManifestOverrideSets[]
  artifactOverrideSets?: ArtifactOverrideSets[]
}

export type ShellScriptStepInfo = StepSpecType & {
  executeOnDelegate?: boolean
  host?: string
  tags?: string[]
  connectionType?: 'SSH' | 'WINRM'
  sshKeyRef?: string
  connectionAttributes?: string
  commandPath?: string
  scriptType?: 'BASH' | 'POWERSHELL'
  scriptString?: string
  outputVars?: string
  sweepingOutputName?: string
  sweepingOutputScope?: string
}

export interface RestResponsePlanExecution {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: PlanExecution
  responseMessages?: ResponseMessage[]
}

export interface EncryptionConfig {
  uuid?: string
  accountId?: string
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  numOfEncryptedValue?: number
  encryptionServiceUrl?: string
  validationCriteria?: string
  globalKms?: boolean
  name?: string
  default?: boolean
}

export interface FailureDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'ENGINE_REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
  message?: string
  correlationId?: string
  validationErrors?: ValidationError[]
}

export interface ServiceUseFromStage {
  stage: string
  overrides?: ServiceOverrides
}

export interface RefType {
  type?: string
}

export interface Pageable {
  pageSize?: number
  offset?: number
  pageNumber?: number
  unpaged?: boolean
  paged?: boolean
  sort?: Sort
}

export type DeploymentStage = StageType & {
  service?: ServiceConfig
  infrastructure?: PipelineInfrastructure
  execution?: ExecutionElement
  stageVariables?: StageVariables
  skipCondition?: string
}

export interface Sort {
  sorted?: boolean
  unsorted?: boolean
  empty?: boolean
}

export interface PipelineInfrastructure {
  infrastructureDef?: InfrastructureDef
  useFromStage?: InfraUseFromStage
  environment?: EnvironmentYaml
  steps?: Step[]
  rollbackSteps?: Step[]
  refType?: RefType
}

export interface StepDependencySpec {
  [key: string]: any
}

export interface InfrastructureDef {
  type?: string
  spec?: Infrastructure
}

export interface EncryptedDataDTO {
  name?: string
  encryptionKey?: string
  encryptedValue?: string[]
  path?: string
  parameters?: EncryptedDataParams[]
  accountId?: string
  enabled?: boolean
  kmsId?: string
  encryptionType?: 'LOCAL' | 'KMS' | 'GCP_KMS' | 'AWS_SECRETS_MANAGER' | 'AZURE_VAULT' | 'CYBERARK' | 'VAULT' | 'CUSTOM'
  fileSize?: number
  backupEncryptedValue?: string[]
  backupEncryptionKey?: string
  backupKmsId?: string
  backupEncryptionType?:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'CYBERARK'
    | 'VAULT'
    | 'CUSTOM'
  scopedToAccount?: boolean
  base64Encoded?: boolean
  uuid?: string
  entityYamlPath?: string
  encryptedBy?: string
  type?:
    | 'HOST_CONNECTION_ATTRIBUTES'
    | 'BASTION_HOST_CONNECTION_ATTRIBUTES'
    | 'SMTP'
    | 'SFTP'
    | 'JENKINS'
    | 'BAMBOO'
    | 'STRING'
    | 'SPLUNK'
    | 'ELK'
    | 'LOGZ'
    | 'SUMO'
    | 'DATA_DOG'
    | 'APM_VERIFICATION'
    | 'BUG_SNAG'
    | 'LOG_VERIFICATION'
    | 'APP_DYNAMICS'
    | 'NEW_RELIC'
    | 'DYNA_TRACE'
    | 'INSTANA'
    | 'DATA_DOG_LOG'
    | 'CLOUD_WATCH'
    | 'SCALYR'
    | 'ELB'
    | 'SLACK'
    | 'AWS'
    | 'GCS'
    | 'GCP'
    | 'AZURE'
    | 'PCF'
    | 'DIRECT'
    | 'KUBERNETES_CLUSTER'
    | 'DOCKER'
    | 'ECR'
    | 'GCR'
    | 'ACR'
    | 'PHYSICAL_DATA_CENTER'
    | 'KUBERNETES'
    | 'NEXUS'
    | 'ARTIFACTORY'
    | 'SMB'
    | 'AMAZON_S3'
    | 'GIT'
    | 'SSH_SESSION_CONFIG'
    | 'SERVICE_VARIABLE'
    | 'CONFIG_FILE'
    | 'KMS'
    | 'GCP_KMS'
    | 'JIRA'
    | 'SERVICENOW'
    | 'SECRET_TEXT'
    | 'YAML_GIT_SYNC'
    | 'VAULT'
    | 'AWS_SECRETS_MANAGER'
    | 'CYBERARK'
    | 'WINRM_CONNECTION_ATTRIBUTES'
    | 'WINRM_SESSION_CONFIG'
    | 'PROMETHEUS'
    | 'INFRASTRUCTURE_MAPPING'
    | 'HTTP_HELM_REPO'
    | 'AMAZON_S3_HELM_REPO'
    | 'GCS_HELM_REPO'
    | 'SPOT_INST'
    | 'AZURE_ARTIFACTS_PAT'
    | 'CUSTOM'
    | 'CE_AWS'
    | 'CE_GCP'
    | 'AZURE_VAULT'
  lastUpdatedAt?: number
}

export type HttpStepInfo = StepSpecType & {
  url?: string
  method?: string
  header?: string
  body?: string
  assertion?: string
  socketTimeoutMillis?: number
}

export interface Duration {
  seconds?: number
  nano?: number
  zero?: boolean
  negative?: boolean
  units?: TemporalUnit[]
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'ENGINE_REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
  level?: 'INFO' | 'ERROR'
  message?: string
  exception?: Throwable
}

export interface ArtifactOverrideSets {
  identifier: string
  artifacts?: ArtifactListConfig
}

export type K8sRollingStepInfo = StepSpecType & {
  timeout?: number
  skipDryRun?: boolean
  stepDependencySpecs?: {
    [key: string]: StepDependencySpec
  }
}

export interface ResponseDTOString {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: string
  metaData?: { [key: string]: any }
  correlationId?: string
}

export type ManifestConfig = ManifestConfigWrapper & {
  type?: string
  spec?: ManifestAttributes
}

export interface ConnectorDTO {
  name?: string
  identifier?: string
  description?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifer?: string
  tags?: string[]
  type?: 'KUBERNETES_CLUSTER' | 'GIT'
  spec?: ConnectorConfigDTO
  createdAt?: number
  lastModifiedAt?: number
}

export type StageElement = StageElementWrapper & {
  identifier: string
  name?: string
  description?: string
  type?: string
  spec?: StageType
}

export interface Throwable {
  cause?: Throwable
  stackTrace?: StackTraceElement[]
  message?: string
  localizedMessage?: string
  suppressed?: Throwable[]
}

export interface StoreConfig {
  [key: string]: any
}

export interface RestResponseGraph {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: Graph
  responseMessages?: ResponseMessage[]
}

export interface StageOverridesConfig {
  useArtifactOverrideSets?: string[]
  artifacts?: ArtifactListConfig
  useManifestOverrideSets?: string[]
  manifests?: ManifestConfigWrapper[]
}

export interface ResponseDTOListEncryptedDataDetail {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EncryptedDataDetail[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOBoolean {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: boolean
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ConnectorRequestDTO {
  name?: string
  identifier?: string
  description?: string
  orgIdentifier?: string
  projectIdentifer?: string
  tags?: string[]
  type?: 'KUBERNETES_CLUSTER' | 'GIT'
  spec?: ConnectorConfigDTO
}

export interface Variable {
  name: string
  value: string
  type: string
}

export interface ErrorDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_KEY'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'INVALID_YAML_PAYLOAD'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'ENGINE_REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
  message?: string
  correlationId?: string
  detailedMessage?: string
}

export interface ResponseDTOPageProjectDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageProjectDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOProjectDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: ProjectDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ResponseDTOListEncryptedDataDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: EncryptedDataDTO[]
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface Step {
  [key: string]: any
}

export interface EmbeddedUser {
  uuid?: string
  name?: string
  email?: string
}

export interface GraphVertex {
  uuid?: string
  name?: string
  startTs?: number
  endTs?: number
  initialWaitDuration?: Duration
  lastUpdatedAt?: number
  stepType?: string
  status?:
    | 'RUNNING'
    | 'WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUCCEEDED'
  failureInfo?: FailureInfo
  interruptHistories?: InterruptEffect[]
  outcomes?: Outcome[]
  retryIds?: string[]
  subgraph?: Subgraph
  next?: GraphVertex
}

export type GitStore = StoreConfig & {
  connectorIdentifier?: string
  gitFetchType?: 'BRANCH' | 'COMMIT'
  branch?: string
  paths?: string[]
}

export interface ServiceConfig {
  useFromStage?: ServiceUseFromStage
  identifier: string
  name: string
  description?: string
  serviceDef?: ServiceDefinition
  stageOverrides?: StageOverridesConfig
}

export interface StageType {
  [key: string]: any
}

export interface CDPipelineDTO {
  name?: string
  description?: string
  stages?: StageElementWrapper[]
  identifier?: string
}

export interface FailureInfo {
  errorMessage?: string
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
  )[]
}

export interface ResponseDTOOrganizationDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: OrganizationDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface GitSyncConfigDTO {
  identifier?: string
  projectId?: string
  organizationId?: string
  accountId?: string
  gitConnectorId?: string
  repo?: string
  branch?: string
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[]
}

export interface ResponseDTOPageCDPipelineDTO {
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
  data?: PageCDPipelineDTO
  metaData?: { [key: string]: any }
  correlationId?: string
}

export interface ArtifactConfig {
  [key: string]: any
}

export interface InfraOverrides {
  environment?: EnvironmentYaml
  infrastructureDef?: InfrastructureDef
}

export interface PageCDPipelineDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: CDPipelineDTO[]
  number?: number
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  first?: boolean
  sort?: Sort
  empty?: boolean
}

export interface SecretTextDTO {
  name?: string
  value?: string
  path?: string
  parameters?: EncryptedDataParams[]
  kmsId?: string
  runtimeParameters?: {
    [key: string]: string
  }
  scopedToAccount?: boolean
}

export interface EnvironmentYaml {
  name?: string
  identifier?: string
  type?: 'PreProduction' | 'Production'
  tags?: Tag[]
  refType?: RefType
}

export interface PageConnectorSummaryDTO {
  totalPages?: number
  totalElements?: number
  size?: number
  content?: ConnectorSummaryDTO[]
  number?: number
  last?: boolean
  numberOfElements?: number
  pageable?: Pageable
  first?: boolean
  sort?: Sort
  empty?: boolean
}

export type SecretTextDTORequestBody = SecretTextDTO

export type ConnectorRequestDTORequestBody = ConnectorRequestDTO

export type GitSyncConfigDTORequestBody = GitSyncConfigDTO

export interface GetOrganizationListQueryParams {
  page?: number
  size?: number
  sort?: string[]
}

export interface GetOrganizationListPathParams {
  accountIdentifier: string
}

export type GetOrganizationListProps = Omit<
  GetProps<
    ResponseDTONGPageResponseOrganizationDTO,
    FailureDTO | ErrorDTO,
    GetOrganizationListQueryParams,
    GetOrganizationListPathParams
  >,
  'path'
> &
  GetOrganizationListPathParams

/**
 * Get Organization list
 */
export const GetOrganizationList = ({ accountIdentifier, ...props }: GetOrganizationListProps) => (
  <Get<
    ResponseDTONGPageResponseOrganizationDTO,
    FailureDTO | ErrorDTO,
    GetOrganizationListQueryParams,
    GetOrganizationListPathParams
  >
    path={`/accounts/${accountIdentifier}/organizations`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetOrganizationListProps = Omit<
  UseGetProps<ResponseDTONGPageResponseOrganizationDTO, GetOrganizationListQueryParams, GetOrganizationListPathParams>,
  'path'
> &
  GetOrganizationListPathParams

/**
 * Get Organization list
 */
export const useGetOrganizationList = ({ accountIdentifier, ...props }: UseGetOrganizationListProps) =>
  useGet<
    ResponseDTONGPageResponseOrganizationDTO,
    FailureDTO | ErrorDTO,
    GetOrganizationListQueryParams,
    GetOrganizationListPathParams
  >(({ accountIdentifier }: GetOrganizationListPathParams) => `/accounts/${accountIdentifier}/organizations`, {
    base: '/cd/api',
    pathParams: { accountIdentifier },
    ...props
  })

export interface PostOrganizationPathParams {
  accountIdentifier: string
}

export type PostOrganizationProps = Omit<
  MutateProps<
    ResponseDTOOrganizationDTO,
    FailureDTO | ErrorDTO,
    void,
    CreateOrganizationDTO,
    PostOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PostOrganizationPathParams

/**
 * Create an Organization
 */
export const PostOrganization = ({ accountIdentifier, ...props }: PostOrganizationProps) => (
  <Mutate<ResponseDTOOrganizationDTO, FailureDTO | ErrorDTO, void, CreateOrganizationDTO, PostOrganizationPathParams>
    verb="POST"
    path={`/accounts/${accountIdentifier}/organizations`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePostOrganizationProps = Omit<
  UseMutateProps<ResponseDTOOrganizationDTO, void, CreateOrganizationDTO, PostOrganizationPathParams>,
  'path' | 'verb'
> &
  PostOrganizationPathParams

/**
 * Create an Organization
 */
export const usePostOrganization = ({ accountIdentifier, ...props }: UsePostOrganizationProps) =>
  useMutate<ResponseDTOOrganizationDTO, FailureDTO | ErrorDTO, void, CreateOrganizationDTO, PostOrganizationPathParams>(
    'POST',
    ({ accountIdentifier }: PostOrganizationPathParams) => `/accounts/${accountIdentifier}/organizations`,
    { base: '/cd/api', pathParams: { accountIdentifier }, ...props }
  )

export interface GetOrganizationPathParams {
  accountIdentifier: string
  organizationIdentifier: string
}

export type GetOrganizationProps = Omit<
  GetProps<ResponseDTOOptionalOrganizationDTO, FailureDTO | ErrorDTO, void, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization
 */
export const GetOrganization = ({ accountIdentifier, organizationIdentifier, ...props }: GetOrganizationProps) => (
  <Get<ResponseDTOOptionalOrganizationDTO, FailureDTO | ErrorDTO, void, GetOrganizationPathParams>
    path={`/accounts/${accountIdentifier}/organizations/${organizationIdentifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetOrganizationProps = Omit<
  UseGetProps<ResponseDTOOptionalOrganizationDTO, void, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization
 */
export const useGetOrganization = ({ accountIdentifier, organizationIdentifier, ...props }: UseGetOrganizationProps) =>
  useGet<ResponseDTOOptionalOrganizationDTO, FailureDTO | ErrorDTO, void, GetOrganizationPathParams>(
    ({ accountIdentifier, organizationIdentifier }: GetOrganizationPathParams) =>
      `/accounts/${accountIdentifier}/organizations/${organizationIdentifier}`,
    { base: '/cd/api', pathParams: { accountIdentifier, organizationIdentifier }, ...props }
  )

export interface PutOrganizationPathParams {
  accountIdentifier: string
  organizationIdentifier: string
}

export type PutOrganizationProps = Omit<
  MutateProps<
    ResponseDTOOptionalOrganizationDTO,
    FailureDTO | ErrorDTO,
    void,
    UpdateOrganizationDTO,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update Organization by identifier
 */
export const PutOrganization = ({ accountIdentifier, organizationIdentifier, ...props }: PutOrganizationProps) => (
  <Mutate<
    ResponseDTOOptionalOrganizationDTO,
    FailureDTO | ErrorDTO,
    void,
    UpdateOrganizationDTO,
    PutOrganizationPathParams
  >
    verb="PUT"
    path={`/accounts/${accountIdentifier}/organizations/${organizationIdentifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePutOrganizationProps = Omit<
  UseMutateProps<ResponseDTOOptionalOrganizationDTO, void, UpdateOrganizationDTO, PutOrganizationPathParams>,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update Organization by identifier
 */
export const usePutOrganization = ({ accountIdentifier, organizationIdentifier, ...props }: UsePutOrganizationProps) =>
  useMutate<
    ResponseDTOOptionalOrganizationDTO,
    FailureDTO | ErrorDTO,
    void,
    UpdateOrganizationDTO,
    PutOrganizationPathParams
  >(
    'PUT',
    ({ accountIdentifier, organizationIdentifier }: PutOrganizationPathParams) =>
      `/accounts/${accountIdentifier}/organizations/${organizationIdentifier}`,
    { base: '/cd/api', pathParams: { accountIdentifier, organizationIdentifier }, ...props }
  )

export interface DeleteOrganizationPathParams {
  accountIdentifier: string
}

export type DeleteOrganizationProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, string, DeleteOrganizationPathParams>,
  'path' | 'verb'
> &
  DeleteOrganizationPathParams

/**
 * Delete Organization by identifier
 */
export const DeleteOrganization = ({ accountIdentifier, ...props }: DeleteOrganizationProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, string, DeleteOrganizationPathParams>
    verb="DELETE"
    path={`/accounts/${accountIdentifier}/organizations`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseDeleteOrganizationProps = Omit<
  UseMutateProps<ResponseDTOBoolean, void, string, DeleteOrganizationPathParams>,
  'path' | 'verb'
> &
  DeleteOrganizationPathParams

/**
 * Delete Organization by identifier
 */
export const useDeleteOrganization = ({ accountIdentifier, ...props }: UseDeleteOrganizationProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, string, DeleteOrganizationPathParams>(
    'DELETE',
    ({ accountIdentifier }: DeleteOrganizationPathParams) => `/accounts/${accountIdentifier}/organizations`,
    { base: '/cd/api', pathParams: { accountIdentifier }, ...props }
  )

export interface GetProjectListForAccountQueryParams {
  page?: number
  size?: number
  sort?: string[]
}

export interface GetProjectListForAccountPathParams {
  accountIdentifier: string
}

export type GetProjectListForAccountProps = Omit<
  GetProps<
    ResponseDTOPageProjectDTO,
    FailureDTO | ErrorDTO,
    GetProjectListForAccountQueryParams,
    GetProjectListForAccountPathParams
  >,
  'path'
> &
  GetProjectListForAccountPathParams

/**
 * Gets Project list for an account
 */
export const GetProjectListForAccount = ({ accountIdentifier, ...props }: GetProjectListForAccountProps) => (
  <Get<
    ResponseDTOPageProjectDTO,
    FailureDTO | ErrorDTO,
    GetProjectListForAccountQueryParams,
    GetProjectListForAccountPathParams
  >
    path={`/accounts/${accountIdentifier}/projects`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetProjectListForAccountProps = Omit<
  UseGetProps<ResponseDTOPageProjectDTO, GetProjectListForAccountQueryParams, GetProjectListForAccountPathParams>,
  'path'
> &
  GetProjectListForAccountPathParams

/**
 * Gets Project list for an account
 */
export const useGetProjectListForAccount = ({ accountIdentifier, ...props }: UseGetProjectListForAccountProps) =>
  useGet<
    ResponseDTOPageProjectDTO,
    FailureDTO | ErrorDTO,
    GetProjectListForAccountQueryParams,
    GetProjectListForAccountPathParams
  >(({ accountIdentifier }: GetProjectListForAccountPathParams) => `/accounts/${accountIdentifier}/projects`, {
    base: '/cd/api',
    pathParams: { accountIdentifier },
    ...props
  })

export interface GetConnectorListQueryParams {
  page?: number
  size?: number
  accountIdentifier?: string
}

export type GetConnectorListProps = Omit<
  GetProps<PageConnectorSummaryDTO, unknown, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const GetConnectorList = (props: GetConnectorListProps) => (
  <Get<PageConnectorSummaryDTO, unknown, GetConnectorListQueryParams, void>
    path={`/connectors`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetConnectorListProps = Omit<
  UseGetProps<PageConnectorSummaryDTO, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const useGetConnectorList = (props: UseGetConnectorListProps) =>
  useGet<PageConnectorSummaryDTO, unknown, GetConnectorListQueryParams, void>(`/connectors`, {
    base: '/cd/api',
    ...props
  })

export interface CreateConnectorQueryParams {
  accountIdentifier?: string
}

export type CreateConnectorProps = Omit<
  MutateProps<ConnectorDTO, unknown, CreateConnectorQueryParams, ConnectorRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const CreateConnector = (props: CreateConnectorProps) => (
  <Mutate<ConnectorDTO, unknown, CreateConnectorQueryParams, ConnectorRequestDTORequestBody, void>
    verb="POST"
    path={`/connectors`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseCreateConnectorProps = Omit<
  UseMutateProps<ConnectorDTO, CreateConnectorQueryParams, ConnectorRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const useCreateConnector = (props: UseCreateConnectorProps) =>
  useMutate<ConnectorDTO, unknown, CreateConnectorQueryParams, ConnectorRequestDTORequestBody, void>(
    'POST',
    `/connectors`,
    { base: '/cd/api', ...props }
  )

export interface UpdateConnectorQueryParams {
  accountIdentifier?: string
}

export type UpdateConnectorProps = Omit<
  MutateProps<ConnectorDTO, unknown, UpdateConnectorQueryParams, ConnectorRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const UpdateConnector = (props: UpdateConnectorProps) => (
  <Mutate<ConnectorDTO, unknown, UpdateConnectorQueryParams, ConnectorRequestDTORequestBody, void>
    verb="PUT"
    path={`/connectors`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseUpdateConnectorProps = Omit<
  UseMutateProps<ConnectorDTO, UpdateConnectorQueryParams, ConnectorRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const useUpdateConnector = (props: UseUpdateConnectorProps) =>
  useMutate<ConnectorDTO, unknown, UpdateConnectorQueryParams, ConnectorRequestDTORequestBody, void>(
    'PUT',
    `/connectors`,
    { base: '/cd/api', ...props }
  )

export interface GetConnectorStatusQueryParams {
  accountIdentifier?: string
}

export type GetConnectorStatusProps = Omit<
  MutateProps<
    RestResponseConnectorValidationResult,
    unknown,
    GetConnectorStatusQueryParams,
    ConnectorRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get the connectivity status of the Connector
 */
export const GetConnectorStatus = (props: GetConnectorStatusProps) => (
  <Mutate<
    RestResponseConnectorValidationResult,
    unknown,
    GetConnectorStatusQueryParams,
    ConnectorRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/connectors/validate`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetConnectorStatusProps = Omit<
  UseMutateProps<
    RestResponseConnectorValidationResult,
    GetConnectorStatusQueryParams,
    ConnectorRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get the connectivity status of the Connector
 */
export const useGetConnectorStatus = (props: UseGetConnectorStatusProps) =>
  useMutate<
    RestResponseConnectorValidationResult,
    unknown,
    GetConnectorStatusQueryParams,
    ConnectorRequestDTORequestBody,
    void
  >('POST', `/connectors/validate`, { base: '/cd/api', ...props })

export interface GetConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetConnectorPathParams {
  connectorIdentifier: string
}

export type GetConnectorProps = Omit<
  GetProps<ConnectorDTO, unknown, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const GetConnector = ({ connectorIdentifier, ...props }: GetConnectorProps) => (
  <Get<ConnectorDTO, unknown, GetConnectorQueryParams, GetConnectorPathParams>
    path={`/connectors/${connectorIdentifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetConnectorProps = Omit<
  UseGetProps<ConnectorDTO, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const useGetConnector = ({ connectorIdentifier, ...props }: UseGetConnectorProps) =>
  useGet<ConnectorDTO, unknown, GetConnectorQueryParams, GetConnectorPathParams>(
    ({ connectorIdentifier }: GetConnectorPathParams) => `/connectors/${connectorIdentifier}`,
    { base: '/cd/api', pathParams: { connectorIdentifier }, ...props }
  )

export interface DeleteConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteConnectorProps = Omit<
  MutateProps<boolean, unknown, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const DeleteConnector = (props: DeleteConnectorProps) => (
  <Mutate<boolean, unknown, DeleteConnectorQueryParams, string, void>
    verb="DELETE"
    path={`/connectors`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseDeleteConnectorProps = Omit<
  UseMutateProps<boolean, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const useDeleteConnector = (props: UseDeleteConnectorProps) =>
  useMutate<boolean, unknown, DeleteConnectorQueryParams, string, void>('DELETE', `/connectors`, {
    base: '/cd/api',
    ...props
  })

export interface PostDelegateQueryParams {
  accountId?: string
}

export type PostDelegateProps = Omit<GetProps<ResponseData, unknown, PostDelegateQueryParams, void>, 'path'>

/**
 * Create a delegate tasks
 */
export const PostDelegate = (props: PostDelegateProps) => (
  <Get<ResponseData, unknown, PostDelegateQueryParams, void> path={`/delegate-tasks`} base={'/cd/api'} {...props} />
)

export type UsePostDelegateProps = Omit<UseGetProps<ResponseData, PostDelegateQueryParams, void>, 'path'>

/**
 * Create a delegate tasks
 */
export const usePostDelegate = (props: UsePostDelegateProps) =>
  useGet<ResponseData, unknown, PostDelegateQueryParams, void>(`/delegate-tasks`, { base: '/cd/api', ...props })

export interface CreateSamplePTaskQueryParams {
  accountId?: string
  country?: string
  population?: number
}

export type CreateSamplePTaskProps = Omit<
  MutateProps<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a sample perpetual task
 */
export const CreateSamplePTask = (props: CreateSamplePTaskProps) => (
  <Mutate<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>
    verb="POST"
    path={`/delegate-tasks/perpetual-tasks/sample`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseCreateSamplePTaskProps = Omit<
  UseMutateProps<RestResponseString, CreateSamplePTaskQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a sample perpetual task
 */
export const useCreateSamplePTask = (props: UseCreateSamplePTaskProps) =>
  useMutate<RestResponseString, unknown, CreateSamplePTaskQueryParams, void, void>(
    'POST',
    `/delegate-tasks/perpetual-tasks/sample`,
    { base: '/cd/api', ...props }
  )

export interface ResetSamplePTaskQueryParams {
  accountId?: string
  country?: string
  population?: number
}

export interface ResetSamplePTaskPathParams {
  taskId: string
}

export type ResetSamplePTaskProps = Omit<
  MutateProps<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>,
  'path' | 'verb'
> &
  ResetSamplePTaskPathParams

/**
 * reset sample perpetual task
 */
export const ResetSamplePTask = ({ taskId, ...props }: ResetSamplePTaskProps) => (
  <Mutate<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>
    verb="PUT"
    path={`/delegate-tasks/perpetual-tasks/sample/${taskId}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseResetSamplePTaskProps = Omit<
  UseMutateProps<RestResponseBoolean, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>,
  'path' | 'verb'
> &
  ResetSamplePTaskPathParams

/**
 * reset sample perpetual task
 */
export const useResetSamplePTask = ({ taskId, ...props }: UseResetSamplePTaskProps) =>
  useMutate<RestResponseBoolean, unknown, ResetSamplePTaskQueryParams, void, ResetSamplePTaskPathParams>(
    'PUT',
    ({ taskId }: ResetSamplePTaskPathParams) => `/delegate-tasks/perpetual-tasks/sample/${taskId}`,
    { base: '/cd/api', pathParams: { taskId }, ...props }
  )

export interface DeleteSamplePTaskQueryParams {
  accountId?: string
}

export type DeleteSamplePTaskProps = Omit<
  MutateProps<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete sample perpetual task
 */
export const DeleteSamplePTask = (props: DeleteSamplePTaskProps) => (
  <Mutate<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>
    verb="DELETE"
    path={`/delegate-tasks/perpetual-tasks/sample`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseDeleteSamplePTaskProps = Omit<
  UseMutateProps<RestResponseBoolean, DeleteSamplePTaskQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete sample perpetual task
 */
export const useDeleteSamplePTask = (props: UseDeleteSamplePTaskProps) =>
  useMutate<RestResponseBoolean, unknown, DeleteSamplePTaskQueryParams, string, void>(
    'DELETE',
    `/delegate-tasks/perpetual-tasks/sample`,
    { base: '/cd/api', ...props }
  )

export interface ListGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export type ListGitSyncProps = Omit<GetProps<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const ListGitSync = (props: ListGitSyncProps) => (
  <Get<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void> path={`/git-sync`} base={'/cd/api'} {...props} />
)

export type UseListGitSyncProps = Omit<UseGetProps<GitSyncConfigDTO[], ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const useListGitSync = (props: UseListGitSyncProps) =>
  useGet<GitSyncConfigDTO[], unknown, ListGitSyncQueryParams, void>(`/git-sync`, { base: '/cd/api', ...props })

export interface PostGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export type PostGitSyncProps = Omit<
  MutateProps<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const PostGitSync = (props: PostGitSyncProps) => (
  <Mutate<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>
    verb="POST"
    path={`/git-sync`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePostGitSyncProps = Omit<
  UseMutateProps<GitSyncConfigDTO, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const usePostGitSync = (props: UsePostGitSyncProps) =>
  useMutate<GitSyncConfigDTO, unknown, PostGitSyncQueryParams, GitSyncConfigDTORequestBody, void>('POST', `/git-sync`, {
    base: '/cd/api',
    ...props
  })

export interface PutGitSyncQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncPathParams {
  identifier: string
}

export type PutGitSyncProps = Omit<
  MutateProps<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>,
  'path' | 'verb'
> &
  PutGitSyncPathParams

/**
 * Update Git Sync by id
 */
export const PutGitSync = ({ identifier, ...props }: PutGitSyncProps) => (
  <Mutate<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>
    verb="PUT"
    path={`/git-sync/${identifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePutGitSyncProps = Omit<
  UseMutateProps<GitSyncConfigDTO, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>,
  'path' | 'verb'
> &
  PutGitSyncPathParams

/**
 * Update Git Sync by id
 */
export const usePutGitSync = ({ identifier, ...props }: UsePutGitSyncProps) =>
  useMutate<GitSyncConfigDTO, unknown, PutGitSyncQueryParams, GitSyncConfigDTORequestBody, PutGitSyncPathParams>(
    'PUT',
    ({ identifier }: PutGitSyncPathParams) => `/git-sync/${identifier}`,
    { base: '/cd/api', pathParams: { identifier }, ...props }
  )

export interface PutGitSyncDefaultQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncDefaultPathParams {
  identifier: string
  folderIdentifier: string
}

export type PutGitSyncDefaultProps = Omit<
  MutateProps<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const PutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: PutGitSyncDefaultProps) => (
  <Mutate<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>
    verb="PUT"
    path={`/git-sync/${identifier}/folder/${folderIdentifier}/default`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePutGitSyncDefaultProps = Omit<
  UseMutateProps<GitSyncConfigDTO[], PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const usePutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: UsePutGitSyncDefaultProps) =>
  useMutate<GitSyncConfigDTO[], unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    ({ identifier, folderIdentifier }: PutGitSyncDefaultPathParams) =>
      `/git-sync/${identifier}/folder/${folderIdentifier}/default`,
    { base: '/cd/api', pathParams: { identifier, folderIdentifier }, ...props }
  )

export interface GetGraphQueryParams {
  planExecutionId?: string
}

export type GetGraphProps = Omit<GetProps<RestResponseGraph, unknown, GetGraphQueryParams, void>, 'path'>

/**
 * generate graph for plan execution
 */
export const GetGraph = (props: GetGraphProps) => (
  <Get<RestResponseGraph, unknown, GetGraphQueryParams, void>
    path={`/orchestration/get-graph`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetGraphProps = Omit<UseGetProps<RestResponseGraph, GetGraphQueryParams, void>, 'path'>

/**
 * generate graph for plan execution
 */
export const useGetGraph = (props: UseGetGraphProps) =>
  useGet<RestResponseGraph, unknown, GetGraphQueryParams, void>(`/orchestration/get-graph`, {
    base: '/cd/api',
    ...props
  })

export interface GetGraphVisualizationQueryParams {
  planExecutionId?: string
}

export type GetGraphVisualizationProps = Omit<GetProps<void, unknown, GetGraphVisualizationQueryParams, void>, 'path'>

/**
 * generate graph execution visualization
 */
export const GetGraphVisualization = (props: GetGraphVisualizationProps) => (
  <Get<void, unknown, GetGraphVisualizationQueryParams, void>
    path={`/orchestration/get-graph-visualization`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetGraphVisualizationProps = Omit<UseGetProps<void, GetGraphVisualizationQueryParams, void>, 'path'>

/**
 * generate graph execution visualization
 */
export const useGetGraphVisualization = (props: UseGetGraphVisualizationProps) =>
  useGet<void, unknown, GetGraphVisualizationQueryParams, void>(`/orchestration/get-graph-visualization`, {
    base: '/cd/api',
    ...props
  })

export interface HttpV2QueryParams {
  accountId: string
  appId: string
}

export type HttpV2Props = Omit<GetProps<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>, 'path'>

/**
 * Triggers a task v2 Plan
 */
export const HttpV2 = (props: HttpV2Props) => (
  <Get<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>
    path={`/orchestration/http-v2`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseHttpV2Props = Omit<UseGetProps<RestResponsePlanExecution, HttpV2QueryParams, void>, 'path'>

/**
 * Triggers a task v2 Plan
 */
export const useHttpV2 = (props: UseHttpV2Props) =>
  useGet<RestResponsePlanExecution, unknown, HttpV2QueryParams, void>(`/orchestration/http-v2`, {
    base: '/cd/api',
    ...props
  })

export interface TestExecutionPlanQueryParams {
  accountId?: string
}

export type TestExecutionPlanProps = Omit<
  MutateProps<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * create and run an execution plan
 */
export const TestExecutionPlan = (props: TestExecutionPlanProps) => (
  <Mutate<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>
    verb="POST"
    path={`/orchestration/test-execution-plan`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseTestExecutionPlanProps = Omit<
  UseMutateProps<RestResponsePlanExecution, TestExecutionPlanQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * create and run an execution plan
 */
export const useTestExecutionPlan = (props: UseTestExecutionPlanProps) =>
  useMutate<RestResponsePlanExecution, unknown, TestExecutionPlanQueryParams, void, void>(
    'POST',
    `/orchestration/test-execution-plan`,
    { base: '/cd/api', ...props }
  )

export interface GetProjectListForOrganizationQueryParams {
  page?: number
  size?: number
  sort?: string[]
}

export interface GetProjectListForOrganizationPathParams {
  orgIdentifier: string
}

export type GetProjectListForOrganizationProps = Omit<
  GetProps<
    ResponseDTONGPageResponseProjectDTO,
    FailureDTO | ErrorDTO,
    GetProjectListForOrganizationQueryParams,
    GetProjectListForOrganizationPathParams
  >,
  'path'
> &
  GetProjectListForOrganizationPathParams

/**
 * Gets Project list for an organization
 */
export const GetProjectListForOrganization = ({ orgIdentifier, ...props }: GetProjectListForOrganizationProps) => (
  <Get<
    ResponseDTONGPageResponseProjectDTO,
    FailureDTO | ErrorDTO,
    GetProjectListForOrganizationQueryParams,
    GetProjectListForOrganizationPathParams
  >
    path={`/organizations/${orgIdentifier}/projects`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetProjectListForOrganizationProps = Omit<
  UseGetProps<
    ResponseDTONGPageResponseProjectDTO,
    GetProjectListForOrganizationQueryParams,
    GetProjectListForOrganizationPathParams
  >,
  'path'
> &
  GetProjectListForOrganizationPathParams

/**
 * Gets Project list for an organization
 */
export const useGetProjectListForOrganization = ({ orgIdentifier, ...props }: UseGetProjectListForOrganizationProps) =>
  useGet<
    ResponseDTONGPageResponseProjectDTO,
    FailureDTO | ErrorDTO,
    GetProjectListForOrganizationQueryParams,
    GetProjectListForOrganizationPathParams
  >(({ orgIdentifier }: GetProjectListForOrganizationPathParams) => `/organizations/${orgIdentifier}/projects`, {
    base: '/cd/api',
    pathParams: { orgIdentifier },
    ...props
  })

export interface PostProjectPathParams {
  orgIdentifier: string
}

export type PostProjectProps = Omit<
  MutateProps<ResponseDTOProjectDTO, FailureDTO | ErrorDTO, void, CreateProjectDTO, PostProjectPathParams>,
  'path' | 'verb'
> &
  PostProjectPathParams

/**
 * Create a Project
 */
export const PostProject = ({ orgIdentifier, ...props }: PostProjectProps) => (
  <Mutate<ResponseDTOProjectDTO, FailureDTO | ErrorDTO, void, CreateProjectDTO, PostProjectPathParams>
    verb="POST"
    path={`/organizations/${orgIdentifier}/projects`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePostProjectProps = Omit<
  UseMutateProps<ResponseDTOProjectDTO, void, CreateProjectDTO, PostProjectPathParams>,
  'path' | 'verb'
> &
  PostProjectPathParams

/**
 * Create a Project
 */
export const usePostProject = ({ orgIdentifier, ...props }: UsePostProjectProps) =>
  useMutate<ResponseDTOProjectDTO, FailureDTO | ErrorDTO, void, CreateProjectDTO, PostProjectPathParams>(
    'POST',
    ({ orgIdentifier }: PostProjectPathParams) => `/organizations/${orgIdentifier}/projects`,
    { base: '/cd/api', pathParams: { orgIdentifier }, ...props }
  )

export interface GetProjectPathParams {
  orgIdentifier: string
  projectIdentifier: string
}

export type GetProjectProps = Omit<
  GetProps<ResponseDTOOptionalProjectDTO, FailureDTO | ErrorDTO, void, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const GetProject = ({ orgIdentifier, projectIdentifier, ...props }: GetProjectProps) => (
  <Get<ResponseDTOOptionalProjectDTO, FailureDTO | ErrorDTO, void, GetProjectPathParams>
    path={`/organizations/${orgIdentifier}/projects/${projectIdentifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetProjectProps = Omit<UseGetProps<ResponseDTOOptionalProjectDTO, void, GetProjectPathParams>, 'path'> &
  GetProjectPathParams

/**
 * Gets a Project by identifier
 */
export const useGetProject = ({ orgIdentifier, projectIdentifier, ...props }: UseGetProjectProps) =>
  useGet<ResponseDTOOptionalProjectDTO, FailureDTO | ErrorDTO, void, GetProjectPathParams>(
    ({ orgIdentifier, projectIdentifier }: GetProjectPathParams) =>
      `/organizations/${orgIdentifier}/projects/${projectIdentifier}`,
    { base: '/cd/api', pathParams: { orgIdentifier, projectIdentifier }, ...props }
  )

export interface PutProjectPathParams {
  orgIdentifier: string
  projectIdentifier: string
}

export type PutProjectProps = Omit<
  MutateProps<ResponseDTOOptionalProjectDTO, FailureDTO | ErrorDTO, void, UpdateProjectDTO, PutProjectPathParams>,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const PutProject = ({ orgIdentifier, projectIdentifier, ...props }: PutProjectProps) => (
  <Mutate<ResponseDTOOptionalProjectDTO, FailureDTO | ErrorDTO, void, UpdateProjectDTO, PutProjectPathParams>
    verb="PUT"
    path={`/organizations/${orgIdentifier}/projects/${projectIdentifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePutProjectProps = Omit<
  UseMutateProps<ResponseDTOOptionalProjectDTO, void, UpdateProjectDTO, PutProjectPathParams>,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a project by identifier
 */
export const usePutProject = ({ orgIdentifier, projectIdentifier, ...props }: UsePutProjectProps) =>
  useMutate<ResponseDTOOptionalProjectDTO, FailureDTO | ErrorDTO, void, UpdateProjectDTO, PutProjectPathParams>(
    'PUT',
    ({ orgIdentifier, projectIdentifier }: PutProjectPathParams) =>
      `/organizations/${orgIdentifier}/projects/${projectIdentifier}`,
    { base: '/cd/api', pathParams: { orgIdentifier, projectIdentifier }, ...props }
  )

export interface DeleteProjectPathParams {
  orgIdentifier: string
}

export type DeleteProjectProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, string, DeleteProjectPathParams>,
  'path' | 'verb'
> &
  DeleteProjectPathParams

/**
 * Delete a project by identifier
 */
export const DeleteProject = ({ orgIdentifier, ...props }: DeleteProjectProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, string, DeleteProjectPathParams>
    verb="DELETE"
    path={`/organizations/${orgIdentifier}/projects`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseDeleteProjectProps = Omit<
  UseMutateProps<ResponseDTOBoolean, void, string, DeleteProjectPathParams>,
  'path' | 'verb'
> &
  DeleteProjectPathParams

/**
 * Delete a project by identifier
 */
export const useDeleteProject = ({ orgIdentifier, ...props }: UseDeleteProjectProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, void, string, DeleteProjectPathParams>(
    'DELETE',
    ({ orgIdentifier }: DeleteProjectPathParams) => `/organizations/${orgIdentifier}/projects`,
    { base: '/cd/api', pathParams: { orgIdentifier }, ...props }
  )

export interface GetPipelineListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetPipelineListProps = Omit<
  GetProps<ResponseDTOPageCDPipelineDTO, unknown, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const GetPipelineList = (props: GetPipelineListProps) => (
  <Get<ResponseDTOPageCDPipelineDTO, unknown, GetPipelineListQueryParams, void>
    path={`/pipelines`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetPipelineListProps = Omit<
  UseGetProps<ResponseDTOPageCDPipelineDTO, GetPipelineListQueryParams, void>,
  'path'
>

/**
 * Gets Pipeline list
 */
export const useGetPipelineList = (props: UseGetPipelineListProps) =>
  useGet<ResponseDTOPageCDPipelineDTO, unknown, GetPipelineListQueryParams, void>(`/pipelines`, {
    base: '/cd/api',
    ...props
  })

export interface PostPipelineDummyQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
}

export type PostPipelineDummyProps = Omit<
  MutateProps<ResponseDTOCDPipelineDTO, unknown, PostPipelineDummyQueryParams, CDPipelineDTO, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const PostPipelineDummy = (props: PostPipelineDummyProps) => (
  <Mutate<ResponseDTOCDPipelineDTO, unknown, PostPipelineDummyQueryParams, CDPipelineDTO, void>
    verb="POST"
    path={`/pipelines`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePostPipelineDummyProps = Omit<
  UseMutateProps<ResponseDTOCDPipelineDTO, PostPipelineDummyQueryParams, CDPipelineDTO, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const usePostPipelineDummy = (props: UsePostPipelineDummyProps) =>
  useMutate<ResponseDTOCDPipelineDTO, unknown, PostPipelineDummyQueryParams, CDPipelineDTO, void>(
    'POST',
    `/pipelines`,
    { base: '/cd/api', ...props }
  )

export interface PutPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier: string
}

export type PutPipelineProps = Omit<MutateProps<void, unknown, PutPipelineQueryParams, void, void>, 'path' | 'verb'>

/**
 * Update a Pipeline
 */
export const PutPipeline = (props: PutPipelineProps) => (
  <Mutate<void, unknown, PutPipelineQueryParams, void, void>
    verb="PUT"
    path={`/pipelines`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePutPipelineProps = Omit<UseMutateProps<void, PutPipelineQueryParams, void, void>, 'path' | 'verb'>

/**
 * Update a Pipeline
 */
export const usePutPipeline = (props: UsePutPipelineProps) =>
  useMutate<void, unknown, PutPipelineQueryParams, void, void>('PUT', `/pipelines`, { base: '/cd/api', ...props })

export interface GetPipelineYamlStringQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetPipelineYamlStringPathParams {
  pipelineIdentifier: string
}

export type GetPipelineYamlStringProps = Omit<
  GetProps<void, unknown, GetPipelineYamlStringQueryParams, GetPipelineYamlStringPathParams>,
  'path'
> &
  GetPipelineYamlStringPathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipelineYamlString = ({ pipelineIdentifier, ...props }: GetPipelineYamlStringProps) => (
  <Get<void, unknown, GetPipelineYamlStringQueryParams, GetPipelineYamlStringPathParams>
    path={`/pipelines/yaml/${pipelineIdentifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetPipelineYamlStringProps = Omit<
  UseGetProps<void, GetPipelineYamlStringQueryParams, GetPipelineYamlStringPathParams>,
  'path'
> &
  GetPipelineYamlStringPathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipelineYamlString = ({ pipelineIdentifier, ...props }: UseGetPipelineYamlStringProps) =>
  useGet<void, unknown, GetPipelineYamlStringQueryParams, GetPipelineYamlStringPathParams>(
    ({ pipelineIdentifier }: GetPipelineYamlStringPathParams) => `/pipelines/yaml/${pipelineIdentifier}`,
    { base: '/cd/api', pathParams: { pipelineIdentifier }, ...props }
  )

export interface PostPipelineExecuteQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  appId?: string
}

export interface PostPipelineExecutePathParams {
  identifier: string
}

export type PostPipelineExecuteProps = Omit<
  MutateProps<ResponseDTOPlanExecution, unknown, PostPipelineExecuteQueryParams, void, PostPipelineExecutePathParams>,
  'path' | 'verb'
> &
  PostPipelineExecutePathParams

/**
 * Execute a pipeline
 */
export const PostPipelineExecute = ({ identifier, ...props }: PostPipelineExecuteProps) => (
  <Mutate<ResponseDTOPlanExecution, unknown, PostPipelineExecuteQueryParams, void, PostPipelineExecutePathParams>
    verb="POST"
    path={`/pipelines/${identifier}/execute`}
    base={'/cd/api'}
    {...props}
  />
)

export type UsePostPipelineExecuteProps = Omit<
  UseMutateProps<ResponseDTOPlanExecution, PostPipelineExecuteQueryParams, void, PostPipelineExecutePathParams>,
  'path' | 'verb'
> &
  PostPipelineExecutePathParams

/**
 * Execute a pipeline
 */
export const usePostPipelineExecute = ({ identifier, ...props }: UsePostPipelineExecuteProps) =>
  useMutate<ResponseDTOPlanExecution, unknown, PostPipelineExecuteQueryParams, void, PostPipelineExecutePathParams>(
    'POST',
    ({ identifier }: PostPipelineExecutePathParams) => `/pipelines/${identifier}/execute`,
    { base: '/cd/api', pathParams: { identifier }, ...props }
  )

export interface GetPipelineYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetPipelineYamlPathParams {
  pipelineIdentifier: string
}

export type GetPipelineYamlProps = Omit<
  GetProps<void, unknown, GetPipelineYamlQueryParams, GetPipelineYamlPathParams>,
  'path'
> &
  GetPipelineYamlPathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipelineYaml = ({ pipelineIdentifier, ...props }: GetPipelineYamlProps) => (
  <Get<void, unknown, GetPipelineYamlQueryParams, GetPipelineYamlPathParams>
    path={`/pipelines/${pipelineIdentifier}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetPipelineYamlProps = Omit<
  UseGetProps<void, GetPipelineYamlQueryParams, GetPipelineYamlPathParams>,
  'path'
> &
  GetPipelineYamlPathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipelineYaml = ({ pipelineIdentifier, ...props }: UseGetPipelineYamlProps) =>
  useGet<void, unknown, GetPipelineYamlQueryParams, GetPipelineYamlPathParams>(
    ({ pipelineIdentifier }: GetPipelineYamlPathParams) => `/pipelines/${pipelineIdentifier}`,
    { base: '/cd/api', pathParams: { pipelineIdentifier }, ...props }
  )

export interface ListSecretManagersQueryParams {
  accountIdentifier: string
}

export type ListSecretManagersProps = Omit<
  GetProps<ResponseDTOListSecretManagerConfig, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>,
  'path'
>

/**
 * Get secret managers for an account
 */
export const ListSecretManagers = (props: ListSecretManagersProps) => (
  <Get<ResponseDTOListSecretManagerConfig, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>
    path={`/secret-managers`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseListSecretManagersProps = Omit<
  UseGetProps<ResponseDTOListSecretManagerConfig, ListSecretManagersQueryParams, void>,
  'path'
>

/**
 * Get secret managers for an account
 */
export const useListSecretManagers = (props: UseListSecretManagersProps) =>
  useGet<ResponseDTOListSecretManagerConfig, FailureDTO | ErrorDTO, ListSecretManagersQueryParams, void>(
    `/secret-managers`,
    { base: '/cd/api', ...props }
  )

export interface SaveOrUpdateSecretManagerQueryParams {
  accountIdentifier: string
}

export type SaveOrUpdateSecretManagerProps = Omit<
  MutateProps<
    ResponseDTOString,
    FailureDTO | ErrorDTO,
    SaveOrUpdateSecretManagerQueryParams,
    SecretManagerConfig,
    void
  >,
  'path' | 'verb'
>

/**
 * Create or update a secret manager
 */
export const SaveOrUpdateSecretManager = (props: SaveOrUpdateSecretManagerProps) => (
  <Mutate<ResponseDTOString, FailureDTO | ErrorDTO, SaveOrUpdateSecretManagerQueryParams, SecretManagerConfig, void>
    verb="POST"
    path={`/secret-managers`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseSaveOrUpdateSecretManagerProps = Omit<
  UseMutateProps<ResponseDTOString, SaveOrUpdateSecretManagerQueryParams, SecretManagerConfig, void>,
  'path' | 'verb'
>

/**
 * Create or update a secret manager
 */
export const useSaveOrUpdateSecretManager = (props: UseSaveOrUpdateSecretManagerProps) =>
  useMutate<ResponseDTOString, FailureDTO | ErrorDTO, SaveOrUpdateSecretManagerQueryParams, SecretManagerConfig, void>(
    'POST',
    `/secret-managers`,
    { base: '/cd/api', ...props }
  )

export interface GetSecretManagerByIdQueryParams {
  accountIdentifier: string
}

export interface GetSecretManagerByIdPathParams {
  kmsId: string
}

export type GetSecretManagerByIdProps = Omit<
  GetProps<
    ResponseDTOSecretManagerConfig,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdQueryParams,
    GetSecretManagerByIdPathParams
  >,
  'path'
> &
  GetSecretManagerByIdPathParams

/**
 * Get a secret manager by kmsId
 */
export const GetSecretManagerById = ({ kmsId, ...props }: GetSecretManagerByIdProps) => (
  <Get<
    ResponseDTOSecretManagerConfig,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdQueryParams,
    GetSecretManagerByIdPathParams
  >
    path={`/secret-managers/${kmsId}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetSecretManagerByIdProps = Omit<
  UseGetProps<ResponseDTOSecretManagerConfig, GetSecretManagerByIdQueryParams, GetSecretManagerByIdPathParams>,
  'path'
> &
  GetSecretManagerByIdPathParams

/**
 * Get a secret manager by kmsId
 */
export const useGetSecretManagerById = ({ kmsId, ...props }: UseGetSecretManagerByIdProps) =>
  useGet<
    ResponseDTOSecretManagerConfig,
    FailureDTO | ErrorDTO,
    GetSecretManagerByIdQueryParams,
    GetSecretManagerByIdPathParams
  >(({ kmsId }: GetSecretManagerByIdPathParams) => `/secret-managers/${kmsId}`, {
    base: '/cd/api',
    pathParams: { kmsId },
    ...props
  })

export interface DeleteSecretManagerQueryParams {
  accountIdentifier: string
}

export type DeleteSecretManagerProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret manager
 */
export const DeleteSecretManager = (props: DeleteSecretManagerProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>
    verb="DELETE"
    path={`/secret-managers`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseDeleteSecretManagerProps = Omit<
  UseMutateProps<ResponseDTOBoolean, DeleteSecretManagerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret manager
 */
export const useDeleteSecretManager = (props: UseDeleteSecretManagerProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretManagerQueryParams, string, void>(
    'DELETE',
    `/secret-managers`,
    { base: '/cd/api', ...props }
  )

export interface ListSecretsForAccountQueryParams {
  accountIdentifier: string
  type?: 'CONFIG_FILE' | 'SECRET_TEXT'
}

export type ListSecretsForAccountProps = Omit<
  GetProps<ResponseDTOListEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsForAccountQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const ListSecretsForAccount = (props: ListSecretsForAccountProps) => (
  <Get<ResponseDTOListEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsForAccountQueryParams, void>
    path={`/secrets`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseListSecretsForAccountProps = Omit<
  UseGetProps<ResponseDTOListEncryptedDataDTO, ListSecretsForAccountQueryParams, void>,
  'path'
>

/**
 * Get secrets for an account
 */
export const useListSecretsForAccount = (props: UseListSecretsForAccountProps) =>
  useGet<ResponseDTOListEncryptedDataDTO, FailureDTO | ErrorDTO, ListSecretsForAccountQueryParams, void>(`/secrets`, {
    base: '/cd/api',
    ...props
  })

export interface CreateSecretTextQueryParams {
  accountId?: string
  local?: boolean
}

export type CreateSecretTextProps = Omit<
  MutateProps<ResponseDTOString, FailureDTO | ErrorDTO, CreateSecretTextQueryParams, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const CreateSecretText = (props: CreateSecretTextProps) => (
  <Mutate<ResponseDTOString, FailureDTO | ErrorDTO, CreateSecretTextQueryParams, SecretTextDTORequestBody, void>
    verb="POST"
    path={`/secrets`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseCreateSecretTextProps = Omit<
  UseMutateProps<ResponseDTOString, CreateSecretTextQueryParams, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a secret text
 */
export const useCreateSecretText = (props: UseCreateSecretTextProps) =>
  useMutate<ResponseDTOString, FailureDTO | ErrorDTO, CreateSecretTextQueryParams, SecretTextDTORequestBody, void>(
    'POST',
    `/secrets`,
    { base: '/cd/api', ...props }
  )

export interface UpdateSecretTextQueryParams {
  accountId?: string
  uuid?: string
}

export type UpdateSecretTextProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, UpdateSecretTextQueryParams, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a secret text
 */
export const UpdateSecretText = (props: UpdateSecretTextProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, UpdateSecretTextQueryParams, SecretTextDTORequestBody, void>
    verb="PUT"
    path={`/secrets`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseUpdateSecretTextProps = Omit<
  UseMutateProps<ResponseDTOBoolean, UpdateSecretTextQueryParams, SecretTextDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a secret text
 */
export const useUpdateSecretText = (props: UseUpdateSecretTextProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, UpdateSecretTextQueryParams, SecretTextDTORequestBody, void>(
    'PUT',
    `/secrets`,
    { base: '/cd/api', ...props }
  )

export interface DeleteSecretTextQueryParams {
  accountId?: string
  uuid?: string
}

export type DeleteSecretTextProps = Omit<
  MutateProps<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretTextQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const DeleteSecretText = (props: DeleteSecretTextProps) => (
  <Mutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretTextQueryParams, void, void>
    verb="DELETE"
    path={`/secrets`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseDeleteSecretTextProps = Omit<
  UseMutateProps<ResponseDTOBoolean, DeleteSecretTextQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete a secret text
 */
export const useDeleteSecretText = (props: UseDeleteSecretTextProps) =>
  useMutate<ResponseDTOBoolean, FailureDTO | ErrorDTO, DeleteSecretTextQueryParams, void, void>('DELETE', `/secrets`, {
    base: '/cd/api',
    ...props
  })

export type TestProps = Omit<GetProps<ResponseDTOListEncryptedDataDetail, FailureDTO | ErrorDTO, void, void>, 'path'>

/**
 * test
 */
export const Test = (props: TestProps) => (
  <Get<ResponseDTOListEncryptedDataDetail, FailureDTO | ErrorDTO, void, void>
    path={`/secrets/test`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseTestProps = Omit<UseGetProps<ResponseDTOListEncryptedDataDetail, void, void>, 'path'>

/**
 * test
 */
export const useTest = (props: UseTestProps) =>
  useGet<ResponseDTOListEncryptedDataDetail, FailureDTO | ErrorDTO, void, void>(`/secrets/test`, {
    base: '/cd/api',
    ...props
  })

export interface GetSecretByIdQueryParams {
  accountIdentifier: string
}

export interface GetSecretByIdPathParams {
  secretId: string
}

export type GetSecretByIdProps = Omit<
  GetProps<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretByIdQueryParams, GetSecretByIdPathParams>,
  'path'
> &
  GetSecretByIdPathParams

/**
 * Gets a secret by id
 */
export const GetSecretById = ({ secretId, ...props }: GetSecretByIdProps) => (
  <Get<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretByIdQueryParams, GetSecretByIdPathParams>
    path={`/secrets/${secretId}`}
    base={'/cd/api'}
    {...props}
  />
)

export type UseGetSecretByIdProps = Omit<
  UseGetProps<ResponseDTOEncryptedDataDTO, GetSecretByIdQueryParams, GetSecretByIdPathParams>,
  'path'
> &
  GetSecretByIdPathParams

/**
 * Gets a secret by id
 */
export const useGetSecretById = ({ secretId, ...props }: UseGetSecretByIdProps) =>
  useGet<ResponseDTOEncryptedDataDTO, FailureDTO | ErrorDTO, GetSecretByIdQueryParams, GetSecretByIdPathParams>(
    ({ secretId }: GetSecretByIdPathParams) => `/secrets/${secretId}`,
    { base: '/cd/api', pathParams: { secretId }, ...props }
  )
